{
  "version": 3,
  "sources": ["../../jotai/esm/vanilla.mjs", "../../jotai/esm/react.mjs"],
  "sourcesContent": ["let keyCount = 0;\nfunction atom(read, write) {\n  const key = `atom${++keyCount}`;\n  const config = {\n    toString: () => key\n  };\n  if (typeof read === \"function\") {\n    config.read = read;\n  } else {\n    config.init = read;\n    config.read = (get) => get(config);\n    config.write = (get, set, arg) => set(\n      config,\n      typeof arg === \"function\" ? arg(get(config)) : arg\n    );\n  }\n  if (write) {\n    config.write = write;\n  }\n  return config;\n}\n\nconst hasInitialValue = (atom) => \"init\" in atom;\nconst isActuallyWritableAtom = (atom) => !!atom.write;\nconst cancelPromiseMap = /* @__PURE__ */ new WeakMap();\nconst registerCancelPromise = (promise, cancel) => {\n  cancelPromiseMap.set(promise, cancel);\n  promise.catch(() => {\n  }).finally(() => cancelPromiseMap.delete(promise));\n};\nconst cancelPromise = (promise, next) => {\n  const cancel = cancelPromiseMap.get(promise);\n  if (cancel) {\n    cancelPromiseMap.delete(promise);\n    cancel(next);\n  }\n};\nconst resolvePromise = (promise, value) => {\n  promise.status = \"fulfilled\";\n  promise.value = value;\n};\nconst rejectPromise = (promise, e) => {\n  promise.status = \"rejected\";\n  promise.reason = e;\n};\nconst isPromiseLike = (x) => typeof (x == null ? void 0 : x.then) === \"function\";\nconst isEqualAtomValue = (a, b) => \"v\" in a && \"v\" in b && Object.is(a.v, b.v);\nconst isEqualAtomError = (a, b) => \"e\" in a && \"e\" in b && Object.is(a.e, b.e);\nconst hasPromiseAtomValue = (a) => \"v\" in a && a.v instanceof Promise;\nconst isEqualPromiseAtomValue = (a, b) => \"v\" in a && \"v\" in b && a.v.orig && a.v.orig === b.v.orig;\nconst returnAtomValue = (atomState) => {\n  if (\"e\" in atomState) {\n    throw atomState.e;\n  }\n  return atomState.v;\n};\nconst createStore = () => {\n  const atomStateMap = /* @__PURE__ */ new WeakMap();\n  const mountedMap = /* @__PURE__ */ new WeakMap();\n  const pendingMap = /* @__PURE__ */ new Map();\n  let storeListeners;\n  let mountedAtoms;\n  if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n    storeListeners = /* @__PURE__ */ new Set();\n    mountedAtoms = /* @__PURE__ */ new Set();\n  }\n  const getAtomState = (atom) => atomStateMap.get(atom);\n  const setAtomState = (atom, atomState) => {\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      Object.freeze(atomState);\n    }\n    const prevAtomState = atomStateMap.get(atom);\n    atomStateMap.set(atom, atomState);\n    if (!pendingMap.has(atom)) {\n      pendingMap.set(atom, prevAtomState);\n    }\n    if (prevAtomState && hasPromiseAtomValue(prevAtomState)) {\n      const next = \"v\" in atomState ? atomState.v instanceof Promise ? atomState.v : Promise.resolve(atomState.v) : Promise.reject(atomState.e);\n      cancelPromise(prevAtomState.v, next);\n    }\n  };\n  const updateDependencies = (atom, nextAtomState, nextDependencies) => {\n    const dependencies = /* @__PURE__ */ new Map();\n    let changed = false;\n    nextDependencies.forEach((aState, a) => {\n      if (!aState && a === atom) {\n        aState = nextAtomState;\n      }\n      if (aState) {\n        dependencies.set(a, aState);\n        if (nextAtomState.d.get(a) !== aState) {\n          changed = true;\n        }\n      } else if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n        console.warn(\"[Bug] atom state not found\");\n      }\n    });\n    if (changed || nextAtomState.d.size !== dependencies.size) {\n      nextAtomState.d = dependencies;\n    }\n  };\n  const setAtomValue = (atom, value, nextDependencies) => {\n    const prevAtomState = getAtomState(atom);\n    const nextAtomState = {\n      d: (prevAtomState == null ? void 0 : prevAtomState.d) || /* @__PURE__ */ new Map(),\n      v: value\n    };\n    if (nextDependencies) {\n      updateDependencies(atom, nextAtomState, nextDependencies);\n    }\n    if (prevAtomState && isEqualAtomValue(prevAtomState, nextAtomState) && prevAtomState.d === nextAtomState.d) {\n      return prevAtomState;\n    }\n    if (prevAtomState && hasPromiseAtomValue(prevAtomState) && hasPromiseAtomValue(nextAtomState) && isEqualPromiseAtomValue(prevAtomState, nextAtomState)) {\n      if (prevAtomState.d === nextAtomState.d) {\n        return prevAtomState;\n      } else {\n        nextAtomState.v = prevAtomState.v;\n      }\n    }\n    setAtomState(atom, nextAtomState);\n    return nextAtomState;\n  };\n  const setAtomValueOrPromise = (atom, valueOrPromise, nextDependencies, abortPromise) => {\n    if (isPromiseLike(valueOrPromise)) {\n      let continuePromise;\n      const promise = new Promise((resolve, reject) => {\n        let settled = false;\n        valueOrPromise.then(\n          (v) => {\n            if (!settled) {\n              settled = true;\n              const prevAtomState = getAtomState(atom);\n              const nextAtomState = setAtomValue(\n                atom,\n                promise,\n                nextDependencies\n              );\n              resolvePromise(promise, v);\n              resolve(v);\n              if ((prevAtomState == null ? void 0 : prevAtomState.d) !== nextAtomState.d) {\n                mountDependencies(atom, nextAtomState, prevAtomState == null ? void 0 : prevAtomState.d);\n              }\n            }\n          },\n          (e) => {\n            if (!settled) {\n              settled = true;\n              const prevAtomState = getAtomState(atom);\n              const nextAtomState = setAtomValue(\n                atom,\n                promise,\n                nextDependencies\n              );\n              rejectPromise(promise, e);\n              reject(e);\n              if ((prevAtomState == null ? void 0 : prevAtomState.d) !== nextAtomState.d) {\n                mountDependencies(atom, nextAtomState, prevAtomState == null ? void 0 : prevAtomState.d);\n              }\n            }\n          }\n        );\n        continuePromise = (next) => {\n          if (!settled) {\n            settled = true;\n            next.then(\n              (v) => resolvePromise(promise, v),\n              (e) => rejectPromise(promise, e)\n            );\n            resolve(next);\n          }\n        };\n      });\n      promise.orig = valueOrPromise;\n      promise.status = \"pending\";\n      registerCancelPromise(promise, (next) => {\n        if (next) {\n          continuePromise(next);\n        }\n        abortPromise == null ? void 0 : abortPromise();\n      });\n      return setAtomValue(atom, promise, nextDependencies);\n    }\n    return setAtomValue(atom, valueOrPromise, nextDependencies);\n  };\n  const setAtomError = (atom, error, nextDependencies) => {\n    const prevAtomState = getAtomState(atom);\n    const nextAtomState = {\n      d: (prevAtomState == null ? void 0 : prevAtomState.d) || /* @__PURE__ */ new Map(),\n      e: error\n    };\n    if (nextDependencies) {\n      updateDependencies(atom, nextAtomState, nextDependencies);\n    }\n    if (prevAtomState && isEqualAtomError(prevAtomState, nextAtomState) && prevAtomState.d === nextAtomState.d) {\n      return prevAtomState;\n    }\n    setAtomState(atom, nextAtomState);\n    return nextAtomState;\n  };\n  const readAtomState = (atom) => {\n    const atomState = getAtomState(atom);\n    if (atomState) {\n      atomState.d.forEach((_, a) => {\n        if (a !== atom && !mountedMap.has(a)) {\n          readAtomState(a);\n        }\n      });\n      if (Array.from(atomState.d).every(\n        ([a, s]) => a === atom || getAtomState(a) === s\n      )) {\n        return atomState;\n      }\n    }\n    const nextDependencies = /* @__PURE__ */ new Map();\n    let isSync = true;\n    const getter = (a) => {\n      if (a === atom) {\n        const aState2 = getAtomState(a);\n        if (aState2) {\n          nextDependencies.set(a, aState2);\n          return returnAtomValue(aState2);\n        }\n        if (hasInitialValue(a)) {\n          nextDependencies.set(a, void 0);\n          return a.init;\n        }\n        throw new Error(\"no atom init\");\n      }\n      const aState = readAtomState(a);\n      nextDependencies.set(a, aState);\n      return returnAtomValue(aState);\n    };\n    let controller;\n    let setSelf;\n    const options = {\n      get signal() {\n        if (!controller) {\n          controller = new AbortController();\n        }\n        return controller.signal;\n      },\n      get setSelf() {\n        if ((import.meta.env && import.meta.env.MODE) !== \"production\" && !isActuallyWritableAtom(atom)) {\n          console.warn(\"setSelf function cannot be used with read-only atom\");\n        }\n        if (!setSelf && isActuallyWritableAtom(atom)) {\n          setSelf = (...args) => {\n            if ((import.meta.env && import.meta.env.MODE) !== \"production\" && isSync) {\n              console.warn(\"setSelf function cannot be called in sync\");\n            }\n            if (!isSync) {\n              return writeAtom(atom, ...args);\n            }\n          };\n        }\n        return setSelf;\n      }\n    };\n    try {\n      const valueOrPromise = atom.read(getter, options);\n      return setAtomValueOrPromise(\n        atom,\n        valueOrPromise,\n        nextDependencies,\n        () => controller == null ? void 0 : controller.abort()\n      );\n    } catch (error) {\n      return setAtomError(atom, error, nextDependencies);\n    } finally {\n      isSync = false;\n    }\n  };\n  const readAtom = (atom) => returnAtomValue(readAtomState(atom));\n  const addAtom = (atom) => {\n    let mounted = mountedMap.get(atom);\n    if (!mounted) {\n      mounted = mountAtom(atom);\n    }\n    return mounted;\n  };\n  const canUnmountAtom = (atom, mounted) => !mounted.l.size && (!mounted.t.size || mounted.t.size === 1 && mounted.t.has(atom));\n  const delAtom = (atom) => {\n    const mounted = mountedMap.get(atom);\n    if (mounted && canUnmountAtom(atom, mounted)) {\n      unmountAtom(atom);\n    }\n  };\n  const recomputeDependents = (atom) => {\n    const dependencyMap = /* @__PURE__ */ new Map();\n    const dirtyMap = /* @__PURE__ */ new WeakMap();\n    const loop1 = (a) => {\n      const mounted = mountedMap.get(a);\n      mounted == null ? void 0 : mounted.t.forEach((dependent) => {\n        if (dependent !== a) {\n          dependencyMap.set(\n            dependent,\n            (dependencyMap.get(dependent) || /* @__PURE__ */ new Set()).add(a)\n          );\n          dirtyMap.set(dependent, (dirtyMap.get(dependent) || 0) + 1);\n          loop1(dependent);\n        }\n      });\n    };\n    loop1(atom);\n    const loop2 = (a) => {\n      const mounted = mountedMap.get(a);\n      mounted == null ? void 0 : mounted.t.forEach((dependent) => {\n        var _a;\n        if (dependent !== a) {\n          let dirtyCount = dirtyMap.get(dependent);\n          if (dirtyCount) {\n            dirtyMap.set(dependent, --dirtyCount);\n          }\n          if (!dirtyCount) {\n            let isChanged = !!((_a = dependencyMap.get(dependent)) == null ? void 0 : _a.size);\n            if (isChanged) {\n              const prevAtomState = getAtomState(dependent);\n              const nextAtomState = readAtomState(dependent);\n              isChanged = !prevAtomState || !isEqualAtomValue(prevAtomState, nextAtomState);\n            }\n            if (!isChanged) {\n              dependencyMap.forEach((s) => s.delete(dependent));\n            }\n          }\n          loop2(dependent);\n        }\n      });\n    };\n    loop2(atom);\n  };\n  const writeAtomState = (atom, ...args) => {\n    let isSync = true;\n    const getter = (a) => returnAtomValue(readAtomState(a));\n    const setter = (a, ...args2) => {\n      let r;\n      if (a === atom) {\n        if (!hasInitialValue(a)) {\n          throw new Error(\"atom not writable\");\n        }\n        const prevAtomState = getAtomState(a);\n        const nextAtomState = setAtomValueOrPromise(a, args2[0]);\n        if (!prevAtomState || !isEqualAtomValue(prevAtomState, nextAtomState)) {\n          recomputeDependents(a);\n        }\n      } else {\n        r = writeAtomState(a, ...args2);\n      }\n      if (!isSync) {\n        flushPending();\n      }\n      return r;\n    };\n    const result = atom.write(getter, setter, ...args);\n    isSync = false;\n    return result;\n  };\n  const writeAtom = (atom, ...args) => {\n    const result = writeAtomState(atom, ...args);\n    flushPending();\n    return result;\n  };\n  const mountAtom = (atom, initialDependent) => {\n    const mounted = {\n      t: new Set(initialDependent && [initialDependent]),\n      l: /* @__PURE__ */ new Set()\n    };\n    mountedMap.set(atom, mounted);\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      mountedAtoms.add(atom);\n    }\n    readAtomState(atom).d.forEach((_, a) => {\n      const aMounted = mountedMap.get(a);\n      if (aMounted) {\n        aMounted.t.add(atom);\n      } else {\n        if (a !== atom) {\n          mountAtom(a, atom);\n        }\n      }\n    });\n    readAtomState(atom);\n    if (isActuallyWritableAtom(atom) && atom.onMount) {\n      const onUnmount = atom.onMount((...args) => writeAtom(atom, ...args));\n      if (onUnmount) {\n        mounted.u = onUnmount;\n      }\n    }\n    return mounted;\n  };\n  const unmountAtom = (atom) => {\n    var _a;\n    const onUnmount = (_a = mountedMap.get(atom)) == null ? void 0 : _a.u;\n    if (onUnmount) {\n      onUnmount();\n    }\n    mountedMap.delete(atom);\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      mountedAtoms.delete(atom);\n    }\n    const atomState = getAtomState(atom);\n    if (atomState) {\n      if (hasPromiseAtomValue(atomState)) {\n        cancelPromise(atomState.v);\n      }\n      atomState.d.forEach((_, a) => {\n        if (a !== atom) {\n          const mounted = mountedMap.get(a);\n          if (mounted) {\n            mounted.t.delete(atom);\n            if (canUnmountAtom(a, mounted)) {\n              unmountAtom(a);\n            }\n          }\n        }\n      });\n    } else if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      console.warn(\"[Bug] could not find atom state to unmount\", atom);\n    }\n  };\n  const mountDependencies = (atom, atomState, prevDependencies) => {\n    const depSet = new Set(atomState.d.keys());\n    prevDependencies == null ? void 0 : prevDependencies.forEach((_, a) => {\n      if (depSet.has(a)) {\n        depSet.delete(a);\n        return;\n      }\n      const mounted = mountedMap.get(a);\n      if (mounted) {\n        mounted.t.delete(atom);\n        if (canUnmountAtom(a, mounted)) {\n          unmountAtom(a);\n        }\n      }\n    });\n    depSet.forEach((a) => {\n      const mounted = mountedMap.get(a);\n      if (mounted) {\n        mounted.t.add(atom);\n      } else if (mountedMap.has(atom)) {\n        mountAtom(a, atom);\n      }\n    });\n  };\n  const flushPending = () => {\n    while (pendingMap.size) {\n      const pending = Array.from(pendingMap);\n      pendingMap.clear();\n      pending.forEach(([atom, prevAtomState]) => {\n        const atomState = getAtomState(atom);\n        if (atomState) {\n          if (atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {\n            mountDependencies(atom, atomState, prevAtomState == null ? void 0 : prevAtomState.d);\n          }\n          const mounted = mountedMap.get(atom);\n          if (mounted && !// TODO This seems pretty hacky. Hope to fix it.\n          // Maybe we could `mountDependencies` in `setAtomState`?\n          (prevAtomState && !hasPromiseAtomValue(prevAtomState) && (isEqualAtomValue(prevAtomState, atomState) || isEqualAtomError(prevAtomState, atomState)))) {\n            mounted.l.forEach((listener) => listener());\n          }\n        } else if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n          console.warn(\"[Bug] no atom state to flush\");\n        }\n      });\n    }\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      storeListeners.forEach((l) => l(\"state\"));\n    }\n  };\n  const subscribeAtom = (atom, listener) => {\n    const mounted = addAtom(atom);\n    flushPending();\n    const listeners = mounted.l;\n    listeners.add(listener);\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      storeListeners.forEach((l) => l(\"sub\"));\n    }\n    return () => {\n      listeners.delete(listener);\n      delAtom(atom);\n      if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n        storeListeners.forEach((l) => l(\"unsub\"));\n      }\n    };\n  };\n  if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n    return {\n      get: readAtom,\n      set: writeAtom,\n      sub: subscribeAtom,\n      // store dev methods (these are tentative and subject to change without notice)\n      dev_subscribe_store: (l) => {\n        storeListeners.add(l);\n        return () => {\n          storeListeners.delete(l);\n        };\n      },\n      dev_get_mounted_atoms: () => mountedAtoms.values(),\n      dev_get_atom_state: (a) => atomStateMap.get(a),\n      dev_get_mounted: (a) => mountedMap.get(a),\n      dev_restore_atoms: (values) => {\n        for (const [atom, valueOrPromise] of values) {\n          if (hasInitialValue(atom)) {\n            setAtomValueOrPromise(atom, valueOrPromise);\n            recomputeDependents(atom);\n          }\n        }\n        flushPending();\n      }\n    };\n  }\n  return {\n    get: readAtom,\n    set: writeAtom,\n    sub: subscribeAtom\n  };\n};\nlet defaultStore;\nconst getDefaultStore = () => {\n  if (!defaultStore) {\n    defaultStore = createStore();\n  }\n  return defaultStore;\n};\n\nexport { atom, createStore, getDefaultStore };\n", "import ReactExports, { createContext, useContext, useRef, createElement, useReducer, useEffect, useDebugValue, useCallback } from 'react';\nimport { getDefaultStore, createStore } from 'jotai/vanilla';\n\nconst StoreContext = createContext(void 0);\nconst useStore = (options) => {\n  const store = useContext(StoreContext);\n  return (options == null ? void 0 : options.store) || store || getDefaultStore();\n};\nconst Provider = ({\n  children,\n  store\n}) => {\n  const storeRef = useRef();\n  if (!store && !storeRef.current) {\n    storeRef.current = createStore();\n  }\n  return createElement(\n    StoreContext.Provider,\n    {\n      value: store || storeRef.current\n    },\n    children\n  );\n};\n\nconst isPromiseLike = (x) => typeof (x == null ? void 0 : x.then) === \"function\";\nconst use = ReactExports.use || ((promise) => {\n  if (promise.status === \"pending\") {\n    throw promise;\n  } else if (promise.status === \"fulfilled\") {\n    return promise.value;\n  } else if (promise.status === \"rejected\") {\n    throw promise.reason;\n  } else {\n    promise.status = \"pending\";\n    promise.then(\n      (v) => {\n        promise.status = \"fulfilled\";\n        promise.value = v;\n      },\n      (e) => {\n        promise.status = \"rejected\";\n        promise.reason = e;\n      }\n    );\n    throw promise;\n  }\n});\nfunction useAtomValue(atom, options) {\n  const store = useStore(options);\n  const [[valueFromReducer, storeFromReducer, atomFromReducer], rerender] = useReducer(\n    (prev) => {\n      const nextValue = store.get(atom);\n      if (Object.is(prev[0], nextValue) && prev[1] === store && prev[2] === atom) {\n        return prev;\n      }\n      return [nextValue, store, atom];\n    },\n    void 0,\n    () => [store.get(atom), store, atom]\n  );\n  let value = valueFromReducer;\n  if (storeFromReducer !== store || atomFromReducer !== atom) {\n    rerender();\n    value = store.get(atom);\n  }\n  const delay = options == null ? void 0 : options.delay;\n  useEffect(() => {\n    const unsub = store.sub(atom, () => {\n      if (typeof delay === \"number\") {\n        setTimeout(rerender, delay);\n        return;\n      }\n      rerender();\n    });\n    rerender();\n    return unsub;\n  }, [store, atom, delay]);\n  useDebugValue(value);\n  return isPromiseLike(value) ? use(value) : value;\n}\n\nfunction useSetAtom(atom, options) {\n  const store = useStore(options);\n  const setAtom = useCallback(\n    (...args) => {\n      if ((import.meta.env && import.meta.env.MODE) !== \"production\" && !(\"write\" in atom)) {\n        throw new Error(\"not writable atom\");\n      }\n      return store.set(atom, ...args);\n    },\n    [store, atom]\n  );\n  return setAtom;\n}\n\nfunction useAtom(atom, options) {\n  return [\n    useAtomValue(atom, options),\n    // We do wrong type assertion here, which results in throwing an error.\n    useSetAtom(atom, options)\n  ];\n}\n\nexport { Provider, useAtom, useAtomValue, useSetAtom, useStore };\n"],
  "mappings": "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",
  "names": ["atom", "isPromiseLike", "ReactExports", "atom"]
}
