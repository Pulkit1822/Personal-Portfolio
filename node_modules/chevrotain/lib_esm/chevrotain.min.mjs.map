{
  "version": 3,
  "sources": ["../src/version.ts", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isPrototype.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_overArg.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_nativeKeys.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseKeys.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_freeGlobal.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_root.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Symbol.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getRawTag.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_objectToString.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseGetTag.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isObject.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isFunction.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_coreJsData.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isMasked.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_toSource.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsNative.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getValue.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getNative.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_DataView.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Map.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Promise.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Set.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_WeakMap.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getTag.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isObjectLike.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsArguments.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isArguments.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isArray.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isLength.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isArrayLike.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/stubFalse.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isBuffer.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsTypedArray.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseUnary.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_nodeUtil.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isTypedArray.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isEmpty.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayMap.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_listCacheClear.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/eq.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_assocIndexOf.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_listCacheDelete.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_listCacheGet.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_listCacheHas.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_listCacheSet.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_ListCache.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stackClear.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stackDelete.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stackGet.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stackHas.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_nativeCreate.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hashClear.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hashDelete.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hashGet.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hashHas.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hashSet.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Hash.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapCacheClear.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isKeyable.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getMapData.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapCacheDelete.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapCacheGet.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapCacheHas.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapCacheSet.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_MapCache.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stackSet.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Stack.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_setCacheAdd.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_setCacheHas.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_SetCache.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arraySome.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_cacheHas.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_equalArrays.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Uint8Array.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapToArray.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_setToArray.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_equalByTag.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayPush.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseGetAllKeys.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayFilter.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/stubArray.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getSymbols.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseTimes.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isIndex.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayLikeKeys.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/keys.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getAllKeys.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_equalObjects.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsEqualDeep.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsEqual.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsMatch.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isStrictComparable.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getMatchData.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_matchesStrictComparable.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseMatches.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isSymbol.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isKey.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/memoize.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_memoizeCapped.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stringToPath.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseToString.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/toString.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_castPath.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_toKey.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseGet.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/get.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseHasIn.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hasPath.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/hasIn.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseMatchesProperty.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/identity.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseProperty.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_basePropertyDeep.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/property.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIteratee.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_createBaseFor.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseFor.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseForOwn.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_createBaseEach.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseEach.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseMap.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/map.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayEach.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_castFunction.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/forEach.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseValues.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/values.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseHas.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/has.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_defineProperty.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseAssignValue.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_assignValue.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_copyObject.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseAssign.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_nativeKeysIn.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseKeysIn.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/keysIn.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseAssignIn.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_cloneBuffer.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_copyArray.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_copySymbols.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getPrototype.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getSymbolsIn.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_copySymbolsIn.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getAllKeysIn.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_initCloneArray.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_cloneArrayBuffer.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_cloneDataView.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_cloneRegExp.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_cloneSymbol.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_cloneTypedArray.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_initCloneByTag.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseCreate.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_initCloneObject.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsMap.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isMap.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsSet.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isSet.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseClone.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/clone.js", "../../utils/src/print.ts", "../../utils/src/timer.ts", "../../utils/src/to-fast-properties.ts", "../../utils/src/api.ts", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseSlice.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_trimmedEndIndex.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseTrim.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/toNumber.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/toFinite.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/toInteger.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/drop.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isString.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsRegExp.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isRegExp.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseSet.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_basePickBy.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/pickBy.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_apply.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_overRest.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/constant.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseSetToString.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_shortOut.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_setToString.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseRest.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isIterateeCall.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_createAssigner.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/assign.js", "../../gast/src/model.ts", "../../gast/src/visitor.ts", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseSome.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/some.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayEvery.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseEvery.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/every.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseFindIndex.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsNaN.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_strictIndexOf.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIndexOf.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/includes.js", "../../gast/src/helpers.ts", "../../gast/src/api.ts", "../src/parse/grammar/rest.ts", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isFlattenable.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseFlatten.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/flatten.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayIncludes.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayIncludesWith.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/noop.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_createSet.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseUniq.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/uniq.js", "../src/parse/grammar/first.ts", "../src/parse/constants.ts", "../src/parse/grammar/follow.ts", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isUndefined.js", "../../../node_modules/.pnpm/regexp-to-ast@0.5.0/node_modules/regexp-to-ast/lib/regexp-to-ast.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/head.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/first.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/compact.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseFilter.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/negate.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/reject.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseDifference.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isArrayLikeObject.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/difference.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/indexOf.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_createFind.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/findIndex.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/find.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/filter.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/defaults.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayReduce.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseReduce.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/reduce.js", "../src/scan/reg_exp_parser.ts", "../src/scan/reg_exp.ts", "../src/scan/lexer.ts", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/last.js", "../src/scan/tokens.ts", "../src/scan/lexer_errors_public.ts", "../src/scan/lexer_public.ts", "../src/scan/tokens_public.ts", "../src/parse/errors_public.ts", "../src/parse/grammar/resolver.ts", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayAggregator.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseAggregator.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_createAggregator.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/groupBy.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/flatMap.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/dropRight.js", "../src/parse/grammar/interpreter.ts", "../src/parse/grammar/lookahead.ts", "../src/parse/grammar/checks.ts", "../src/parse/grammar/gast/gast_resolver_public.ts", "../src/parse/exceptions_public.ts", "../src/parse/parser/traits/recoverable.ts", "../src/parse/grammar/keys.ts", "../src/parse/grammar/llk_lookahead.ts", "../src/parse/parser/traits/looksahead.ts", "../src/parse/cst/cst.ts", "../src/lang/lang_extensions.ts", "../src/parse/cst/cst_visitor.ts", "../src/parse/parser/traits/tree_builder.ts", "../src/parse/parser/traits/lexer_adapter.ts", "../src/parse/parser/traits/recognizer_api.ts", "../src/parse/parser/traits/recognizer_engine.ts", "../src/parse/parser/traits/error_handler.ts", "../src/parse/parser/traits/context_assist.ts", "../src/parse/parser/traits/gast_recorder.ts", "../src/parse/parser/traits/perf_tracer.ts", "../src/parse/parser/utils/apply_mixins.ts", "../src/parse/parser/parser.ts", "../../cst-dts-gen/src/model.ts", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_castSlice.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hasUnicode.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_asciiToArray.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_unicodeToArray.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stringToArray.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_createCaseFirst.js", "../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/upperFirst.js", "../../cst-dts-gen/src/generate.ts", "../../cst-dts-gen/src/api.ts", "../src/diagrams/render_public.ts", "../src/api.ts"],
  "sourcesContent": ["// needs a separate module as this is required inside chevrotain productive code\n// and also in the entry point for webpack(api.ts).\n// A separate file avoids cyclic dependencies and webpack errors.\nexport const VERSION = \"10.5.0\"\n", "/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n  return value === proto;\n}\n\nmodule.exports = isPrototype;\n", "/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\nmodule.exports = overArg;\n", "var overArg = require('./_overArg');\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeKeys = overArg(Object.keys, Object);\n\nmodule.exports = nativeKeys;\n", "var isPrototype = require('./_isPrototype'),\n    nativeKeys = require('./_nativeKeys');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeys(object) {\n  if (!isPrototype(object)) {\n    return nativeKeys(object);\n  }\n  var result = [];\n  for (var key in Object(object)) {\n    if (hasOwnProperty.call(object, key) && key != 'constructor') {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseKeys;\n", "/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\nmodule.exports = freeGlobal;\n", "var freeGlobal = require('./_freeGlobal');\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\nmodule.exports = root;\n", "var root = require('./_root');\n\n/** Built-in value references. */\nvar Symbol = root.Symbol;\n\nmodule.exports = Symbol;\n", "var Symbol = require('./_Symbol');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\nmodule.exports = getRawTag;\n", "/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\nmodule.exports = objectToString;\n", "var Symbol = require('./_Symbol'),\n    getRawTag = require('./_getRawTag'),\n    objectToString = require('./_objectToString');\n\n/** `Object#toString` result references. */\nvar nullTag = '[object Null]',\n    undefinedTag = '[object Undefined]';\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\nmodule.exports = baseGetTag;\n", "/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\nmodule.exports = isObject;\n", "var baseGetTag = require('./_baseGetTag'),\n    isObject = require('./isObject');\n\n/** `Object#toString` result references. */\nvar asyncTag = '[object AsyncFunction]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    proxyTag = '[object Proxy]';\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n  var tag = baseGetTag(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\n\nmodule.exports = isFunction;\n", "var root = require('./_root');\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\nmodule.exports = coreJsData;\n", "var coreJsData = require('./_coreJsData');\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\nmodule.exports = isMasked;\n", "/** Used for built-in method references. */\nvar funcProto = Function.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to convert.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\nmodule.exports = toSource;\n", "var isFunction = require('./isFunction'),\n    isMasked = require('./_isMasked'),\n    isObject = require('./isObject'),\n    toSource = require('./_toSource');\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used for built-in method references. */\nvar funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\nmodule.exports = baseIsNative;\n", "/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\nmodule.exports = getValue;\n", "var baseIsNative = require('./_baseIsNative'),\n    getValue = require('./_getValue');\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\nmodule.exports = getNative;\n", "var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar DataView = getNative(root, 'DataView');\n\nmodule.exports = DataView;\n", "var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar Map = getNative(root, 'Map');\n\nmodule.exports = Map;\n", "var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar Promise = getNative(root, 'Promise');\n\nmodule.exports = Promise;\n", "var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar Set = getNative(root, 'Set');\n\nmodule.exports = Set;\n", "var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar WeakMap = getNative(root, 'WeakMap');\n\nmodule.exports = WeakMap;\n", "var DataView = require('./_DataView'),\n    Map = require('./_Map'),\n    Promise = require('./_Promise'),\n    Set = require('./_Set'),\n    WeakMap = require('./_WeakMap'),\n    baseGetTag = require('./_baseGetTag'),\n    toSource = require('./_toSource');\n\n/** `Object#toString` result references. */\nvar mapTag = '[object Map]',\n    objectTag = '[object Object]',\n    promiseTag = '[object Promise]',\n    setTag = '[object Set]',\n    weakMapTag = '[object WeakMap]';\n\nvar dataViewTag = '[object DataView]';\n\n/** Used to detect maps, sets, and weakmaps. */\nvar dataViewCtorString = toSource(DataView),\n    mapCtorString = toSource(Map),\n    promiseCtorString = toSource(Promise),\n    setCtorString = toSource(Set),\n    weakMapCtorString = toSource(WeakMap);\n\n/**\n * Gets the `toStringTag` of `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nvar getTag = baseGetTag;\n\n// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.\nif ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\n    (Map && getTag(new Map) != mapTag) ||\n    (Promise && getTag(Promise.resolve()) != promiseTag) ||\n    (Set && getTag(new Set) != setTag) ||\n    (WeakMap && getTag(new WeakMap) != weakMapTag)) {\n  getTag = function(value) {\n    var result = baseGetTag(value),\n        Ctor = result == objectTag ? value.constructor : undefined,\n        ctorString = Ctor ? toSource(Ctor) : '';\n\n    if (ctorString) {\n      switch (ctorString) {\n        case dataViewCtorString: return dataViewTag;\n        case mapCtorString: return mapTag;\n        case promiseCtorString: return promiseTag;\n        case setCtorString: return setTag;\n        case weakMapCtorString: return weakMapTag;\n      }\n    }\n    return result;\n  };\n}\n\nmodule.exports = getTag;\n", "/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\nmodule.exports = isObjectLike;\n", "var baseGetTag = require('./_baseGetTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]';\n\n/**\n * The base implementation of `_.isArguments`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n */\nfunction baseIsArguments(value) {\n  return isObjectLike(value) && baseGetTag(value) == argsTag;\n}\n\nmodule.exports = baseIsArguments;\n", "var baseIsArguments = require('./_baseIsArguments'),\n    isObjectLike = require('./isObjectLike');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Built-in value references. */\nvar propertyIsEnumerable = objectProto.propertyIsEnumerable;\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nvar isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {\n  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&\n    !propertyIsEnumerable.call(value, 'callee');\n};\n\nmodule.exports = isArguments;\n", "/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\nmodule.exports = isArray;\n", "/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\nmodule.exports = isLength;\n", "var isFunction = require('./isFunction'),\n    isLength = require('./isLength');\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\nmodule.exports = isArrayLike;\n", "/**\n * This method returns `false`.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {boolean} Returns `false`.\n * @example\n *\n * _.times(2, _.stubFalse);\n * // => [false, false]\n */\nfunction stubFalse() {\n  return false;\n}\n\nmodule.exports = stubFalse;\n", "var root = require('./_root'),\n    stubFalse = require('./stubFalse');\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;\n\n/**\n * Checks if `value` is a buffer.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n * @example\n *\n * _.isBuffer(new Buffer(2));\n * // => true\n *\n * _.isBuffer(new Uint8Array(2));\n * // => false\n */\nvar isBuffer = nativeIsBuffer || stubFalse;\n\nmodule.exports = isBuffer;\n", "var baseGetTag = require('./_baseGetTag'),\n    isLength = require('./isLength'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    objectTag = '[object Object]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/** Used to identify `toStringTag` values of typed arrays. */\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\ntypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\ntypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\ntypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\ntypedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag] = typedArrayTags[arrayTag] =\ntypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\ntypedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\ntypedArrayTags[errorTag] = typedArrayTags[funcTag] =\ntypedArrayTags[mapTag] = typedArrayTags[numberTag] =\ntypedArrayTags[objectTag] = typedArrayTags[regexpTag] =\ntypedArrayTags[setTag] = typedArrayTags[stringTag] =\ntypedArrayTags[weakMapTag] = false;\n\n/**\n * The base implementation of `_.isTypedArray` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n */\nfunction baseIsTypedArray(value) {\n  return isObjectLike(value) &&\n    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n}\n\nmodule.exports = baseIsTypedArray;\n", "/**\n * The base implementation of `_.unary` without support for storing metadata.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @returns {Function} Returns the new capped function.\n */\nfunction baseUnary(func) {\n  return function(value) {\n    return func(value);\n  };\n}\n\nmodule.exports = baseUnary;\n", "var freeGlobal = require('./_freeGlobal');\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Detect free variable `process` from Node.js. */\nvar freeProcess = moduleExports && freeGlobal.process;\n\n/** Used to access faster Node.js helpers. */\nvar nodeUtil = (function() {\n  try {\n    // Use `util.types` for Node.js 10+.\n    var types = freeModule && freeModule.require && freeModule.require('util').types;\n\n    if (types) {\n      return types;\n    }\n\n    // Legacy `process.binding('util')` for Node.js < 10.\n    return freeProcess && freeProcess.binding && freeProcess.binding('util');\n  } catch (e) {}\n}());\n\nmodule.exports = nodeUtil;\n", "var baseIsTypedArray = require('./_baseIsTypedArray'),\n    baseUnary = require('./_baseUnary'),\n    nodeUtil = require('./_nodeUtil');\n\n/* Node.js helper references. */\nvar nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n/**\n * Checks if `value` is classified as a typed array.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n * @example\n *\n * _.isTypedArray(new Uint8Array);\n * // => true\n *\n * _.isTypedArray([]);\n * // => false\n */\nvar isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\nmodule.exports = isTypedArray;\n", "var baseKeys = require('./_baseKeys'),\n    getTag = require('./_getTag'),\n    isArguments = require('./isArguments'),\n    isArray = require('./isArray'),\n    isArrayLike = require('./isArrayLike'),\n    isBuffer = require('./isBuffer'),\n    isPrototype = require('./_isPrototype'),\n    isTypedArray = require('./isTypedArray');\n\n/** `Object#toString` result references. */\nvar mapTag = '[object Map]',\n    setTag = '[object Set]';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Checks if `value` is an empty object, collection, map, or set.\n *\n * Objects are considered empty if they have no own enumerable string keyed\n * properties.\n *\n * Array-like values such as `arguments` objects, arrays, buffers, strings, or\n * jQuery-like collections are considered empty if they have a `length` of `0`.\n * Similarly, maps and sets are considered empty if they have a `size` of `0`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is empty, else `false`.\n * @example\n *\n * _.isEmpty(null);\n * // => true\n *\n * _.isEmpty(true);\n * // => true\n *\n * _.isEmpty(1);\n * // => true\n *\n * _.isEmpty([1, 2, 3]);\n * // => false\n *\n * _.isEmpty({ 'a': 1 });\n * // => false\n */\nfunction isEmpty(value) {\n  if (value == null) {\n    return true;\n  }\n  if (isArrayLike(value) &&\n      (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||\n        isBuffer(value) || isTypedArray(value) || isArguments(value))) {\n    return !value.length;\n  }\n  var tag = getTag(value);\n  if (tag == mapTag || tag == setTag) {\n    return !value.size;\n  }\n  if (isPrototype(value)) {\n    return !baseKeys(value).length;\n  }\n  for (var key in value) {\n    if (hasOwnProperty.call(value, key)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nmodule.exports = isEmpty;\n", "/**\n * A specialized version of `_.map` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */\nfunction arrayMap(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      result = Array(length);\n\n  while (++index < length) {\n    result[index] = iteratee(array[index], index, array);\n  }\n  return result;\n}\n\nmodule.exports = arrayMap;\n", "/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n  this.size = 0;\n}\n\nmodule.exports = listCacheClear;\n", "/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\nmodule.exports = eq;\n", "var eq = require('./eq');\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\nmodule.exports = assocIndexOf;\n", "var assocIndexOf = require('./_assocIndexOf');\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype;\n\n/** Built-in value references. */\nvar splice = arrayProto.splice;\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  --this.size;\n  return true;\n}\n\nmodule.exports = listCacheDelete;\n", "var assocIndexOf = require('./_assocIndexOf');\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\nmodule.exports = listCacheGet;\n", "var assocIndexOf = require('./_assocIndexOf');\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\nmodule.exports = listCacheHas;\n", "var assocIndexOf = require('./_assocIndexOf');\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    ++this.size;\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\nmodule.exports = listCacheSet;\n", "var listCacheClear = require('./_listCacheClear'),\n    listCacheDelete = require('./_listCacheDelete'),\n    listCacheGet = require('./_listCacheGet'),\n    listCacheHas = require('./_listCacheHas'),\n    listCacheSet = require('./_listCacheSet');\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\nmodule.exports = ListCache;\n", "var ListCache = require('./_ListCache');\n\n/**\n * Removes all key-value entries from the stack.\n *\n * @private\n * @name clear\n * @memberOf Stack\n */\nfunction stackClear() {\n  this.__data__ = new ListCache;\n  this.size = 0;\n}\n\nmodule.exports = stackClear;\n", "/**\n * Removes `key` and its value from the stack.\n *\n * @private\n * @name delete\n * @memberOf Stack\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction stackDelete(key) {\n  var data = this.__data__,\n      result = data['delete'](key);\n\n  this.size = data.size;\n  return result;\n}\n\nmodule.exports = stackDelete;\n", "/**\n * Gets the stack value for `key`.\n *\n * @private\n * @name get\n * @memberOf Stack\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction stackGet(key) {\n  return this.__data__.get(key);\n}\n\nmodule.exports = stackGet;\n", "/**\n * Checks if a stack value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Stack\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction stackHas(key) {\n  return this.__data__.has(key);\n}\n\nmodule.exports = stackHas;\n", "var getNative = require('./_getNative');\n\n/* Built-in method references that are verified to be native. */\nvar nativeCreate = getNative(Object, 'create');\n\nmodule.exports = nativeCreate;\n", "var nativeCreate = require('./_nativeCreate');\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n  this.size = 0;\n}\n\nmodule.exports = hashClear;\n", "/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  var result = this.has(key) && delete this.__data__[key];\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\nmodule.exports = hashDelete;\n", "var nativeCreate = require('./_nativeCreate');\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\nmodule.exports = hashGet;\n", "var nativeCreate = require('./_nativeCreate');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);\n}\n\nmodule.exports = hashHas;\n", "var nativeCreate = require('./_nativeCreate');\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  this.size += this.has(key) ? 0 : 1;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\nmodule.exports = hashSet;\n", "var hashClear = require('./_hashClear'),\n    hashDelete = require('./_hashDelete'),\n    hashGet = require('./_hashGet'),\n    hashHas = require('./_hashHas'),\n    hashSet = require('./_hashSet');\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\nmodule.exports = Hash;\n", "var Hash = require('./_Hash'),\n    ListCache = require('./_ListCache'),\n    Map = require('./_Map');\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.size = 0;\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\nmodule.exports = mapCacheClear;\n", "/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\nmodule.exports = isKeyable;\n", "var isKeyable = require('./_isKeyable');\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\nmodule.exports = getMapData;\n", "var getMapData = require('./_getMapData');\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  var result = getMapData(this, key)['delete'](key);\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\nmodule.exports = mapCacheDelete;\n", "var getMapData = require('./_getMapData');\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\nmodule.exports = mapCacheGet;\n", "var getMapData = require('./_getMapData');\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\nmodule.exports = mapCacheHas;\n", "var getMapData = require('./_getMapData');\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  var data = getMapData(this, key),\n      size = data.size;\n\n  data.set(key, value);\n  this.size += data.size == size ? 0 : 1;\n  return this;\n}\n\nmodule.exports = mapCacheSet;\n", "var mapCacheClear = require('./_mapCacheClear'),\n    mapCacheDelete = require('./_mapCacheDelete'),\n    mapCacheGet = require('./_mapCacheGet'),\n    mapCacheHas = require('./_mapCacheHas'),\n    mapCacheSet = require('./_mapCacheSet');\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\nmodule.exports = MapCache;\n", "var ListCache = require('./_ListCache'),\n    Map = require('./_Map'),\n    MapCache = require('./_MapCache');\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/**\n * Sets the stack `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Stack\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the stack cache instance.\n */\nfunction stackSet(key, value) {\n  var data = this.__data__;\n  if (data instanceof ListCache) {\n    var pairs = data.__data__;\n    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n      pairs.push([key, value]);\n      this.size = ++data.size;\n      return this;\n    }\n    data = this.__data__ = new MapCache(pairs);\n  }\n  data.set(key, value);\n  this.size = data.size;\n  return this;\n}\n\nmodule.exports = stackSet;\n", "var ListCache = require('./_ListCache'),\n    stackClear = require('./_stackClear'),\n    stackDelete = require('./_stackDelete'),\n    stackGet = require('./_stackGet'),\n    stackHas = require('./_stackHas'),\n    stackSet = require('./_stackSet');\n\n/**\n * Creates a stack cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Stack(entries) {\n  var data = this.__data__ = new ListCache(entries);\n  this.size = data.size;\n}\n\n// Add methods to `Stack`.\nStack.prototype.clear = stackClear;\nStack.prototype['delete'] = stackDelete;\nStack.prototype.get = stackGet;\nStack.prototype.has = stackHas;\nStack.prototype.set = stackSet;\n\nmodule.exports = Stack;\n", "/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/**\n * Adds `value` to the array cache.\n *\n * @private\n * @name add\n * @memberOf SetCache\n * @alias push\n * @param {*} value The value to cache.\n * @returns {Object} Returns the cache instance.\n */\nfunction setCacheAdd(value) {\n  this.__data__.set(value, HASH_UNDEFINED);\n  return this;\n}\n\nmodule.exports = setCacheAdd;\n", "/**\n * Checks if `value` is in the array cache.\n *\n * @private\n * @name has\n * @memberOf SetCache\n * @param {*} value The value to search for.\n * @returns {number} Returns `true` if `value` is found, else `false`.\n */\nfunction setCacheHas(value) {\n  return this.__data__.has(value);\n}\n\nmodule.exports = setCacheHas;\n", "var MapCache = require('./_MapCache'),\n    setCacheAdd = require('./_setCacheAdd'),\n    setCacheHas = require('./_setCacheHas');\n\n/**\n *\n * Creates an array cache object to store unique values.\n *\n * @private\n * @constructor\n * @param {Array} [values] The values to cache.\n */\nfunction SetCache(values) {\n  var index = -1,\n      length = values == null ? 0 : values.length;\n\n  this.__data__ = new MapCache;\n  while (++index < length) {\n    this.add(values[index]);\n  }\n}\n\n// Add methods to `SetCache`.\nSetCache.prototype.add = SetCache.prototype.push = setCacheAdd;\nSetCache.prototype.has = setCacheHas;\n\nmodule.exports = SetCache;\n", "/**\n * A specialized version of `_.some` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {boolean} Returns `true` if any element passes the predicate check,\n *  else `false`.\n */\nfunction arraySome(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (predicate(array[index], index, array)) {\n      return true;\n    }\n  }\n  return false;\n}\n\nmodule.exports = arraySome;\n", "/**\n * Checks if a `cache` value for `key` exists.\n *\n * @private\n * @param {Object} cache The cache to query.\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction cacheHas(cache, key) {\n  return cache.has(key);\n}\n\nmodule.exports = cacheHas;\n", "var SetCache = require('./_SetCache'),\n    arraySome = require('./_arraySome'),\n    cacheHas = require('./_cacheHas');\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/**\n * A specialized version of `baseIsEqualDeep` for arrays with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Array} array The array to compare.\n * @param {Array} other The other array to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `array` and `other` objects.\n * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\n */\nfunction equalArrays(array, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n      arrLength = array.length,\n      othLength = other.length;\n\n  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n    return false;\n  }\n  // Check that cyclic values are equal.\n  var arrStacked = stack.get(array);\n  var othStacked = stack.get(other);\n  if (arrStacked && othStacked) {\n    return arrStacked == other && othStacked == array;\n  }\n  var index = -1,\n      result = true,\n      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;\n\n  stack.set(array, other);\n  stack.set(other, array);\n\n  // Ignore non-index properties.\n  while (++index < arrLength) {\n    var arrValue = array[index],\n        othValue = other[index];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, arrValue, index, other, array, stack)\n        : customizer(arrValue, othValue, index, array, other, stack);\n    }\n    if (compared !== undefined) {\n      if (compared) {\n        continue;\n      }\n      result = false;\n      break;\n    }\n    // Recursively compare arrays (susceptible to call stack limits).\n    if (seen) {\n      if (!arraySome(other, function(othValue, othIndex) {\n            if (!cacheHas(seen, othIndex) &&\n                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {\n              return seen.push(othIndex);\n            }\n          })) {\n        result = false;\n        break;\n      }\n    } else if (!(\n          arrValue === othValue ||\n            equalFunc(arrValue, othValue, bitmask, customizer, stack)\n        )) {\n      result = false;\n      break;\n    }\n  }\n  stack['delete'](array);\n  stack['delete'](other);\n  return result;\n}\n\nmodule.exports = equalArrays;\n", "var root = require('./_root');\n\n/** Built-in value references. */\nvar Uint8Array = root.Uint8Array;\n\nmodule.exports = Uint8Array;\n", "/**\n * Converts `map` to its key-value pairs.\n *\n * @private\n * @param {Object} map The map to convert.\n * @returns {Array} Returns the key-value pairs.\n */\nfunction mapToArray(map) {\n  var index = -1,\n      result = Array(map.size);\n\n  map.forEach(function(value, key) {\n    result[++index] = [key, value];\n  });\n  return result;\n}\n\nmodule.exports = mapToArray;\n", "/**\n * Converts `set` to an array of its values.\n *\n * @private\n * @param {Object} set The set to convert.\n * @returns {Array} Returns the values.\n */\nfunction setToArray(set) {\n  var index = -1,\n      result = Array(set.size);\n\n  set.forEach(function(value) {\n    result[++index] = value;\n  });\n  return result;\n}\n\nmodule.exports = setToArray;\n", "var Symbol = require('./_Symbol'),\n    Uint8Array = require('./_Uint8Array'),\n    eq = require('./eq'),\n    equalArrays = require('./_equalArrays'),\n    mapToArray = require('./_mapToArray'),\n    setToArray = require('./_setToArray');\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/** `Object#toString` result references. */\nvar boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]';\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;\n\n/**\n * A specialized version of `baseIsEqualDeep` for comparing objects of\n * the same `toStringTag`.\n *\n * **Note:** This function only supports comparing values with tags of\n * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {string} tag The `toStringTag` of the objects to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {\n  switch (tag) {\n    case dataViewTag:\n      if ((object.byteLength != other.byteLength) ||\n          (object.byteOffset != other.byteOffset)) {\n        return false;\n      }\n      object = object.buffer;\n      other = other.buffer;\n\n    case arrayBufferTag:\n      if ((object.byteLength != other.byteLength) ||\n          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {\n        return false;\n      }\n      return true;\n\n    case boolTag:\n    case dateTag:\n    case numberTag:\n      // Coerce booleans to `1` or `0` and dates to milliseconds.\n      // Invalid dates are coerced to `NaN`.\n      return eq(+object, +other);\n\n    case errorTag:\n      return object.name == other.name && object.message == other.message;\n\n    case regexpTag:\n    case stringTag:\n      // Coerce regexes to strings and treat strings, primitives and objects,\n      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring\n      // for more details.\n      return object == (other + '');\n\n    case mapTag:\n      var convert = mapToArray;\n\n    case setTag:\n      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;\n      convert || (convert = setToArray);\n\n      if (object.size != other.size && !isPartial) {\n        return false;\n      }\n      // Assume cyclic values are equal.\n      var stacked = stack.get(object);\n      if (stacked) {\n        return stacked == other;\n      }\n      bitmask |= COMPARE_UNORDERED_FLAG;\n\n      // Recursively compare objects (susceptible to call stack limits).\n      stack.set(object, other);\n      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);\n      stack['delete'](object);\n      return result;\n\n    case symbolTag:\n      if (symbolValueOf) {\n        return symbolValueOf.call(object) == symbolValueOf.call(other);\n      }\n  }\n  return false;\n}\n\nmodule.exports = equalByTag;\n", "/**\n * Appends the elements of `values` to `array`.\n *\n * @private\n * @param {Array} array The array to modify.\n * @param {Array} values The values to append.\n * @returns {Array} Returns `array`.\n */\nfunction arrayPush(array, values) {\n  var index = -1,\n      length = values.length,\n      offset = array.length;\n\n  while (++index < length) {\n    array[offset + index] = values[index];\n  }\n  return array;\n}\n\nmodule.exports = arrayPush;\n", "var arrayPush = require('./_arrayPush'),\n    isArray = require('./isArray');\n\n/**\n * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @param {Function} symbolsFunc The function to get the symbols of `object`.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction baseGetAllKeys(object, keysFunc, symbolsFunc) {\n  var result = keysFunc(object);\n  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\n}\n\nmodule.exports = baseGetAllKeys;\n", "/**\n * A specialized version of `_.filter` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n */\nfunction arrayFilter(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      resIndex = 0,\n      result = [];\n\n  while (++index < length) {\n    var value = array[index];\n    if (predicate(value, index, array)) {\n      result[resIndex++] = value;\n    }\n  }\n  return result;\n}\n\nmodule.exports = arrayFilter;\n", "/**\n * This method returns a new empty array.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {Array} Returns the new empty array.\n * @example\n *\n * var arrays = _.times(2, _.stubArray);\n *\n * console.log(arrays);\n * // => [[], []]\n *\n * console.log(arrays[0] === arrays[1]);\n * // => false\n */\nfunction stubArray() {\n  return [];\n}\n\nmodule.exports = stubArray;\n", "var arrayFilter = require('./_arrayFilter'),\n    stubArray = require('./stubArray');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Built-in value references. */\nvar propertyIsEnumerable = objectProto.propertyIsEnumerable;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeGetSymbols = Object.getOwnPropertySymbols;\n\n/**\n * Creates an array of the own enumerable symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */\nvar getSymbols = !nativeGetSymbols ? stubArray : function(object) {\n  if (object == null) {\n    return [];\n  }\n  object = Object(object);\n  return arrayFilter(nativeGetSymbols(object), function(symbol) {\n    return propertyIsEnumerable.call(object, symbol);\n  });\n};\n\nmodule.exports = getSymbols;\n", "/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\nmodule.exports = baseTimes;\n", "/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  var type = typeof value;\n  length = length == null ? MAX_SAFE_INTEGER : length;\n\n  return !!length &&\n    (type == 'number' ||\n      (type != 'symbol' && reIsUint.test(value))) &&\n        (value > -1 && value % 1 == 0 && value < length);\n}\n\nmodule.exports = isIndex;\n", "var baseTimes = require('./_baseTimes'),\n    isArguments = require('./isArguments'),\n    isArray = require('./isArray'),\n    isBuffer = require('./isBuffer'),\n    isIndex = require('./_isIndex'),\n    isTypedArray = require('./isTypedArray');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  var isArr = isArray(value),\n      isArg = !isArr && isArguments(value),\n      isBuff = !isArr && !isArg && isBuffer(value),\n      isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n      skipIndexes = isArr || isArg || isBuff || isType,\n      result = skipIndexes ? baseTimes(value.length, String) : [],\n      length = result.length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty.call(value, key)) &&\n        !(skipIndexes && (\n           // Safari 9 has enumerable `arguments.length` in strict mode.\n           key == 'length' ||\n           // Node.js 0.10 has enumerable non-index properties on buffers.\n           (isBuff && (key == 'offset' || key == 'parent')) ||\n           // PhantomJS 2 has enumerable non-index properties on typed arrays.\n           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n           // Skip index properties.\n           isIndex(key, length)\n        ))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = arrayLikeKeys;\n", "var arrayLikeKeys = require('./_arrayLikeKeys'),\n    baseKeys = require('./_baseKeys'),\n    isArrayLike = require('./isArrayLike');\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nfunction keys(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n}\n\nmodule.exports = keys;\n", "var baseGetAllKeys = require('./_baseGetAllKeys'),\n    getSymbols = require('./_getSymbols'),\n    keys = require('./keys');\n\n/**\n * Creates an array of own enumerable property names and symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction getAllKeys(object) {\n  return baseGetAllKeys(object, keys, getSymbols);\n}\n\nmodule.exports = getAllKeys;\n", "var getAllKeys = require('./_getAllKeys');\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1;\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * A specialized version of `baseIsEqualDeep` for objects with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalObjects(object, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n      objProps = getAllKeys(object),\n      objLength = objProps.length,\n      othProps = getAllKeys(other),\n      othLength = othProps.length;\n\n  if (objLength != othLength && !isPartial) {\n    return false;\n  }\n  var index = objLength;\n  while (index--) {\n    var key = objProps[index];\n    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {\n      return false;\n    }\n  }\n  // Check that cyclic values are equal.\n  var objStacked = stack.get(object);\n  var othStacked = stack.get(other);\n  if (objStacked && othStacked) {\n    return objStacked == other && othStacked == object;\n  }\n  var result = true;\n  stack.set(object, other);\n  stack.set(other, object);\n\n  var skipCtor = isPartial;\n  while (++index < objLength) {\n    key = objProps[index];\n    var objValue = object[key],\n        othValue = other[key];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, objValue, key, other, object, stack)\n        : customizer(objValue, othValue, key, object, other, stack);\n    }\n    // Recursively compare objects (susceptible to call stack limits).\n    if (!(compared === undefined\n          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))\n          : compared\n        )) {\n      result = false;\n      break;\n    }\n    skipCtor || (skipCtor = key == 'constructor');\n  }\n  if (result && !skipCtor) {\n    var objCtor = object.constructor,\n        othCtor = other.constructor;\n\n    // Non `Object` object instances with different constructors are not equal.\n    if (objCtor != othCtor &&\n        ('constructor' in object && 'constructor' in other) &&\n        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&\n          typeof othCtor == 'function' && othCtor instanceof othCtor)) {\n      result = false;\n    }\n  }\n  stack['delete'](object);\n  stack['delete'](other);\n  return result;\n}\n\nmodule.exports = equalObjects;\n", "var Stack = require('./_Stack'),\n    equalArrays = require('./_equalArrays'),\n    equalByTag = require('./_equalByTag'),\n    equalObjects = require('./_equalObjects'),\n    getTag = require('./_getTag'),\n    isArray = require('./isArray'),\n    isBuffer = require('./isBuffer'),\n    isTypedArray = require('./isTypedArray');\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    objectTag = '[object Object]';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * A specialized version of `baseIsEqual` for arrays and objects which performs\n * deep comparisons and tracks traversed objects enabling objects with circular\n * references to be compared.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} [stack] Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {\n  var objIsArr = isArray(object),\n      othIsArr = isArray(other),\n      objTag = objIsArr ? arrayTag : getTag(object),\n      othTag = othIsArr ? arrayTag : getTag(other);\n\n  objTag = objTag == argsTag ? objectTag : objTag;\n  othTag = othTag == argsTag ? objectTag : othTag;\n\n  var objIsObj = objTag == objectTag,\n      othIsObj = othTag == objectTag,\n      isSameTag = objTag == othTag;\n\n  if (isSameTag && isBuffer(object)) {\n    if (!isBuffer(other)) {\n      return false;\n    }\n    objIsArr = true;\n    objIsObj = false;\n  }\n  if (isSameTag && !objIsObj) {\n    stack || (stack = new Stack);\n    return (objIsArr || isTypedArray(object))\n      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)\n      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);\n  }\n  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {\n    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),\n        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\n\n    if (objIsWrapped || othIsWrapped) {\n      var objUnwrapped = objIsWrapped ? object.value() : object,\n          othUnwrapped = othIsWrapped ? other.value() : other;\n\n      stack || (stack = new Stack);\n      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);\n    }\n  }\n  if (!isSameTag) {\n    return false;\n  }\n  stack || (stack = new Stack);\n  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);\n}\n\nmodule.exports = baseIsEqualDeep;\n", "var baseIsEqualDeep = require('./_baseIsEqualDeep'),\n    isObjectLike = require('./isObjectLike');\n\n/**\n * The base implementation of `_.isEqual` which supports partial comparisons\n * and tracks traversed objects.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @param {boolean} bitmask The bitmask flags.\n *  1 - Unordered comparison\n *  2 - Partial comparison\n * @param {Function} [customizer] The function to customize comparisons.\n * @param {Object} [stack] Tracks traversed `value` and `other` objects.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n */\nfunction baseIsEqual(value, other, bitmask, customizer, stack) {\n  if (value === other) {\n    return true;\n  }\n  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {\n    return value !== value && other !== other;\n  }\n  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);\n}\n\nmodule.exports = baseIsEqual;\n", "var Stack = require('./_Stack'),\n    baseIsEqual = require('./_baseIsEqual');\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/**\n * The base implementation of `_.isMatch` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The object to inspect.\n * @param {Object} source The object of property values to match.\n * @param {Array} matchData The property names, values, and compare flags to match.\n * @param {Function} [customizer] The function to customize comparisons.\n * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n */\nfunction baseIsMatch(object, source, matchData, customizer) {\n  var index = matchData.length,\n      length = index,\n      noCustomizer = !customizer;\n\n  if (object == null) {\n    return !length;\n  }\n  object = Object(object);\n  while (index--) {\n    var data = matchData[index];\n    if ((noCustomizer && data[2])\n          ? data[1] !== object[data[0]]\n          : !(data[0] in object)\n        ) {\n      return false;\n    }\n  }\n  while (++index < length) {\n    data = matchData[index];\n    var key = data[0],\n        objValue = object[key],\n        srcValue = data[1];\n\n    if (noCustomizer && data[2]) {\n      if (objValue === undefined && !(key in object)) {\n        return false;\n      }\n    } else {\n      var stack = new Stack;\n      if (customizer) {\n        var result = customizer(objValue, srcValue, key, object, source, stack);\n      }\n      if (!(result === undefined\n            ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)\n            : result\n          )) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\nmodule.exports = baseIsMatch;\n", "var isObject = require('./isObject');\n\n/**\n * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` if suitable for strict\n *  equality comparisons, else `false`.\n */\nfunction isStrictComparable(value) {\n  return value === value && !isObject(value);\n}\n\nmodule.exports = isStrictComparable;\n", "var isStrictComparable = require('./_isStrictComparable'),\n    keys = require('./keys');\n\n/**\n * Gets the property names, values, and compare flags of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the match data of `object`.\n */\nfunction getMatchData(object) {\n  var result = keys(object),\n      length = result.length;\n\n  while (length--) {\n    var key = result[length],\n        value = object[key];\n\n    result[length] = [key, value, isStrictComparable(value)];\n  }\n  return result;\n}\n\nmodule.exports = getMatchData;\n", "/**\n * A specialized version of `matchesProperty` for source values suitable\n * for strict equality comparisons, i.e. `===`.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @param {*} srcValue The value to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction matchesStrictComparable(key, srcValue) {\n  return function(object) {\n    if (object == null) {\n      return false;\n    }\n    return object[key] === srcValue &&\n      (srcValue !== undefined || (key in Object(object)));\n  };\n}\n\nmodule.exports = matchesStrictComparable;\n", "var baseIsMatch = require('./_baseIsMatch'),\n    getMatchData = require('./_getMatchData'),\n    matchesStrictComparable = require('./_matchesStrictComparable');\n\n/**\n * The base implementation of `_.matches` which doesn't clone `source`.\n *\n * @private\n * @param {Object} source The object of property values to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction baseMatches(source) {\n  var matchData = getMatchData(source);\n  if (matchData.length == 1 && matchData[0][2]) {\n    return matchesStrictComparable(matchData[0][0], matchData[0][1]);\n  }\n  return function(object) {\n    return object === source || baseIsMatch(object, source, matchData);\n  };\n}\n\nmodule.exports = baseMatches;\n", "var baseGetTag = require('./_baseGetTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && baseGetTag(value) == symbolTag);\n}\n\nmodule.exports = isSymbol;\n", "var isArray = require('./isArray'),\n    isSymbol = require('./isSymbol');\n\n/** Used to match property names within property paths. */\nvar reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n    reIsPlainProp = /^\\w*$/;\n\n/**\n * Checks if `value` is a property name and not a property path.\n *\n * @private\n * @param {*} value The value to check.\n * @param {Object} [object] The object to query keys on.\n * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n */\nfunction isKey(value, object) {\n  if (isArray(value)) {\n    return false;\n  }\n  var type = typeof value;\n  if (type == 'number' || type == 'symbol' || type == 'boolean' ||\n      value == null || isSymbol(value)) {\n    return true;\n  }\n  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n    (object != null && value in Object(object));\n}\n\nmodule.exports = isKey;\n", "var MapCache = require('./_MapCache');\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/**\n * Creates a function that memoizes the result of `func`. If `resolver` is\n * provided, it determines the cache key for storing the result based on the\n * arguments provided to the memoized function. By default, the first argument\n * provided to the memoized function is used as the map cache key. The `func`\n * is invoked with the `this` binding of the memoized function.\n *\n * **Note:** The cache is exposed as the `cache` property on the memoized\n * function. Its creation may be customized by replacing the `_.memoize.Cache`\n * constructor with one whose instances implement the\n * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n * method interface of `clear`, `delete`, `get`, `has`, and `set`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to have its output memoized.\n * @param {Function} [resolver] The function to resolve the cache key.\n * @returns {Function} Returns the new memoized function.\n * @example\n *\n * var object = { 'a': 1, 'b': 2 };\n * var other = { 'c': 3, 'd': 4 };\n *\n * var values = _.memoize(_.values);\n * values(object);\n * // => [1, 2]\n *\n * values(other);\n * // => [3, 4]\n *\n * object.a = 2;\n * values(object);\n * // => [1, 2]\n *\n * // Modify the result cache.\n * values.cache.set(object, ['a', 'b']);\n * values(object);\n * // => ['a', 'b']\n *\n * // Replace `_.memoize.Cache`.\n * _.memoize.Cache = WeakMap;\n */\nfunction memoize(func, resolver) {\n  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  var memoized = function() {\n    var args = arguments,\n        key = resolver ? resolver.apply(this, args) : args[0],\n        cache = memoized.cache;\n\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    var result = func.apply(this, args);\n    memoized.cache = cache.set(key, result) || cache;\n    return result;\n  };\n  memoized.cache = new (memoize.Cache || MapCache);\n  return memoized;\n}\n\n// Expose `MapCache`.\nmemoize.Cache = MapCache;\n\nmodule.exports = memoize;\n", "var memoize = require('./memoize');\n\n/** Used as the maximum memoize cache size. */\nvar MAX_MEMOIZE_SIZE = 500;\n\n/**\n * A specialized version of `_.memoize` which clears the memoized function's\n * cache when it exceeds `MAX_MEMOIZE_SIZE`.\n *\n * @private\n * @param {Function} func The function to have its output memoized.\n * @returns {Function} Returns the new memoized function.\n */\nfunction memoizeCapped(func) {\n  var result = memoize(func, function(key) {\n    if (cache.size === MAX_MEMOIZE_SIZE) {\n      cache.clear();\n    }\n    return key;\n  });\n\n  var cache = result.cache;\n  return result;\n}\n\nmodule.exports = memoizeCapped;\n", "var memoizeCapped = require('./_memoizeCapped');\n\n/** Used to match property names within property paths. */\nvar rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n\n/** Used to match backslashes in property paths. */\nvar reEscapeChar = /\\\\(\\\\)?/g;\n\n/**\n * Converts `string` to a property path array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the property path array.\n */\nvar stringToPath = memoizeCapped(function(string) {\n  var result = [];\n  if (string.charCodeAt(0) === 46 /* . */) {\n    result.push('');\n  }\n  string.replace(rePropName, function(match, number, quote, subString) {\n    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));\n  });\n  return result;\n});\n\nmodule.exports = stringToPath;\n", "var Symbol = require('./_Symbol'),\n    arrayMap = require('./_arrayMap'),\n    isArray = require('./isArray'),\n    isSymbol = require('./isSymbol');\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  if (isArray(value)) {\n    // Recursively convert values (susceptible to call stack limits).\n    return arrayMap(value, baseToString) + '';\n  }\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\nmodule.exports = baseToString;\n", "var baseToString = require('./_baseToString');\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\n\nmodule.exports = toString;\n", "var isArray = require('./isArray'),\n    isKey = require('./_isKey'),\n    stringToPath = require('./_stringToPath'),\n    toString = require('./toString');\n\n/**\n * Casts `value` to a path array if it's not one.\n *\n * @private\n * @param {*} value The value to inspect.\n * @param {Object} [object] The object to query keys on.\n * @returns {Array} Returns the cast property path array.\n */\nfunction castPath(value, object) {\n  if (isArray(value)) {\n    return value;\n  }\n  return isKey(value, object) ? [value] : stringToPath(toString(value));\n}\n\nmodule.exports = castPath;\n", "var isSymbol = require('./isSymbol');\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/**\n * Converts `value` to a string key if it's not a string or symbol.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {string|symbol} Returns the key.\n */\nfunction toKey(value) {\n  if (typeof value == 'string' || isSymbol(value)) {\n    return value;\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\nmodule.exports = toKey;\n", "var castPath = require('./_castPath'),\n    toKey = require('./_toKey');\n\n/**\n * The base implementation of `_.get` without support for default values.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @returns {*} Returns the resolved value.\n */\nfunction baseGet(object, path) {\n  path = castPath(path, object);\n\n  var index = 0,\n      length = path.length;\n\n  while (object != null && index < length) {\n    object = object[toKey(path[index++])];\n  }\n  return (index && index == length) ? object : undefined;\n}\n\nmodule.exports = baseGet;\n", "var baseGet = require('./_baseGet');\n\n/**\n * Gets the value at `path` of `object`. If the resolved value is\n * `undefined`, the `defaultValue` is returned in its place.\n *\n * @static\n * @memberOf _\n * @since 3.7.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n * @returns {*} Returns the resolved value.\n * @example\n *\n * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n *\n * _.get(object, 'a[0].b.c');\n * // => 3\n *\n * _.get(object, ['a', '0', 'b', 'c']);\n * // => 3\n *\n * _.get(object, 'a.b.c', 'default');\n * // => 'default'\n */\nfunction get(object, path, defaultValue) {\n  var result = object == null ? undefined : baseGet(object, path);\n  return result === undefined ? defaultValue : result;\n}\n\nmodule.exports = get;\n", "/**\n * The base implementation of `_.hasIn` without support for deep paths.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {Array|string} key The key to check.\n * @returns {boolean} Returns `true` if `key` exists, else `false`.\n */\nfunction baseHasIn(object, key) {\n  return object != null && key in Object(object);\n}\n\nmodule.exports = baseHasIn;\n", "var castPath = require('./_castPath'),\n    isArguments = require('./isArguments'),\n    isArray = require('./isArray'),\n    isIndex = require('./_isIndex'),\n    isLength = require('./isLength'),\n    toKey = require('./_toKey');\n\n/**\n * Checks if `path` exists on `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @param {Function} hasFunc The function to check properties.\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\n */\nfunction hasPath(object, path, hasFunc) {\n  path = castPath(path, object);\n\n  var index = -1,\n      length = path.length,\n      result = false;\n\n  while (++index < length) {\n    var key = toKey(path[index]);\n    if (!(result = object != null && hasFunc(object, key))) {\n      break;\n    }\n    object = object[key];\n  }\n  if (result || ++index != length) {\n    return result;\n  }\n  length = object == null ? 0 : object.length;\n  return !!length && isLength(length) && isIndex(key, length) &&\n    (isArray(object) || isArguments(object));\n}\n\nmodule.exports = hasPath;\n", "var baseHasIn = require('./_baseHasIn'),\n    hasPath = require('./_hasPath');\n\n/**\n * Checks if `path` is a direct or inherited property of `object`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\n * @example\n *\n * var object = _.create({ 'a': _.create({ 'b': 2 }) });\n *\n * _.hasIn(object, 'a');\n * // => true\n *\n * _.hasIn(object, 'a.b');\n * // => true\n *\n * _.hasIn(object, ['a', 'b']);\n * // => true\n *\n * _.hasIn(object, 'b');\n * // => false\n */\nfunction hasIn(object, path) {\n  return object != null && hasPath(object, path, baseHasIn);\n}\n\nmodule.exports = hasIn;\n", "var baseIsEqual = require('./_baseIsEqual'),\n    get = require('./get'),\n    hasIn = require('./hasIn'),\n    isKey = require('./_isKey'),\n    isStrictComparable = require('./_isStrictComparable'),\n    matchesStrictComparable = require('./_matchesStrictComparable'),\n    toKey = require('./_toKey');\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/**\n * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.\n *\n * @private\n * @param {string} path The path of the property to get.\n * @param {*} srcValue The value to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction baseMatchesProperty(path, srcValue) {\n  if (isKey(path) && isStrictComparable(srcValue)) {\n    return matchesStrictComparable(toKey(path), srcValue);\n  }\n  return function(object) {\n    var objValue = get(object, path);\n    return (objValue === undefined && objValue === srcValue)\n      ? hasIn(object, path)\n      : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);\n  };\n}\n\nmodule.exports = baseMatchesProperty;\n", "/**\n * This method returns the first argument it receives.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Util\n * @param {*} value Any value.\n * @returns {*} Returns `value`.\n * @example\n *\n * var object = { 'a': 1 };\n *\n * console.log(_.identity(object) === object);\n * // => true\n */\nfunction identity(value) {\n  return value;\n}\n\nmodule.exports = identity;\n", "/**\n * The base implementation of `_.property` without support for deep paths.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @returns {Function} Returns the new accessor function.\n */\nfunction baseProperty(key) {\n  return function(object) {\n    return object == null ? undefined : object[key];\n  };\n}\n\nmodule.exports = baseProperty;\n", "var baseGet = require('./_baseGet');\n\n/**\n * A specialized version of `baseProperty` which supports deep paths.\n *\n * @private\n * @param {Array|string} path The path of the property to get.\n * @returns {Function} Returns the new accessor function.\n */\nfunction basePropertyDeep(path) {\n  return function(object) {\n    return baseGet(object, path);\n  };\n}\n\nmodule.exports = basePropertyDeep;\n", "var baseProperty = require('./_baseProperty'),\n    basePropertyDeep = require('./_basePropertyDeep'),\n    isKey = require('./_isKey'),\n    toKey = require('./_toKey');\n\n/**\n * Creates a function that returns the value at `path` of a given object.\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Util\n * @param {Array|string} path The path of the property to get.\n * @returns {Function} Returns the new accessor function.\n * @example\n *\n * var objects = [\n *   { 'a': { 'b': 2 } },\n *   { 'a': { 'b': 1 } }\n * ];\n *\n * _.map(objects, _.property('a.b'));\n * // => [2, 1]\n *\n * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');\n * // => [1, 2]\n */\nfunction property(path) {\n  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);\n}\n\nmodule.exports = property;\n", "var baseMatches = require('./_baseMatches'),\n    baseMatchesProperty = require('./_baseMatchesProperty'),\n    identity = require('./identity'),\n    isArray = require('./isArray'),\n    property = require('./property');\n\n/**\n * The base implementation of `_.iteratee`.\n *\n * @private\n * @param {*} [value=_.identity] The value to convert to an iteratee.\n * @returns {Function} Returns the iteratee.\n */\nfunction baseIteratee(value) {\n  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.\n  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.\n  if (typeof value == 'function') {\n    return value;\n  }\n  if (value == null) {\n    return identity;\n  }\n  if (typeof value == 'object') {\n    return isArray(value)\n      ? baseMatchesProperty(value[0], value[1])\n      : baseMatches(value);\n  }\n  return property(value);\n}\n\nmodule.exports = baseIteratee;\n", "/**\n * Creates a base function for methods like `_.forIn` and `_.forOwn`.\n *\n * @private\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */\nfunction createBaseFor(fromRight) {\n  return function(object, iteratee, keysFunc) {\n    var index = -1,\n        iterable = Object(object),\n        props = keysFunc(object),\n        length = props.length;\n\n    while (length--) {\n      var key = props[fromRight ? length : ++index];\n      if (iteratee(iterable[key], key, iterable) === false) {\n        break;\n      }\n    }\n    return object;\n  };\n}\n\nmodule.exports = createBaseFor;\n", "var createBaseFor = require('./_createBaseFor');\n\n/**\n * The base implementation of `baseForOwn` which iterates over `object`\n * properties returned by `keysFunc` and invokes `iteratee` for each property.\n * Iteratee functions may exit iteration early by explicitly returning `false`.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @returns {Object} Returns `object`.\n */\nvar baseFor = createBaseFor();\n\nmodule.exports = baseFor;\n", "var baseFor = require('./_baseFor'),\n    keys = require('./keys');\n\n/**\n * The base implementation of `_.forOwn` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Object} Returns `object`.\n */\nfunction baseForOwn(object, iteratee) {\n  return object && baseFor(object, iteratee, keys);\n}\n\nmodule.exports = baseForOwn;\n", "var isArrayLike = require('./isArrayLike');\n\n/**\n * Creates a `baseEach` or `baseEachRight` function.\n *\n * @private\n * @param {Function} eachFunc The function to iterate over a collection.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */\nfunction createBaseEach(eachFunc, fromRight) {\n  return function(collection, iteratee) {\n    if (collection == null) {\n      return collection;\n    }\n    if (!isArrayLike(collection)) {\n      return eachFunc(collection, iteratee);\n    }\n    var length = collection.length,\n        index = fromRight ? length : -1,\n        iterable = Object(collection);\n\n    while ((fromRight ? index-- : ++index < length)) {\n      if (iteratee(iterable[index], index, iterable) === false) {\n        break;\n      }\n    }\n    return collection;\n  };\n}\n\nmodule.exports = createBaseEach;\n", "var baseForOwn = require('./_baseForOwn'),\n    createBaseEach = require('./_createBaseEach');\n\n/**\n * The base implementation of `_.forEach` without support for iteratee shorthands.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array|Object} Returns `collection`.\n */\nvar baseEach = createBaseEach(baseForOwn);\n\nmodule.exports = baseEach;\n", "var baseEach = require('./_baseEach'),\n    isArrayLike = require('./isArrayLike');\n\n/**\n * The base implementation of `_.map` without support for iteratee shorthands.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */\nfunction baseMap(collection, iteratee) {\n  var index = -1,\n      result = isArrayLike(collection) ? Array(collection.length) : [];\n\n  baseEach(collection, function(value, key, collection) {\n    result[++index] = iteratee(value, key, collection);\n  });\n  return result;\n}\n\nmodule.exports = baseMap;\n", "var arrayMap = require('./_arrayMap'),\n    baseIteratee = require('./_baseIteratee'),\n    baseMap = require('./_baseMap'),\n    isArray = require('./isArray');\n\n/**\n * Creates an array of values by running each element in `collection` thru\n * `iteratee`. The iteratee is invoked with three arguments:\n * (value, index|key, collection).\n *\n * Many lodash methods are guarded to work as iteratees for methods like\n * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.\n *\n * The guarded methods are:\n * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,\n * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,\n * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,\n * `template`, `trim`, `trimEnd`, `trimStart`, and `words`\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n * @example\n *\n * function square(n) {\n *   return n * n;\n * }\n *\n * _.map([4, 8], square);\n * // => [16, 64]\n *\n * _.map({ 'a': 4, 'b': 8 }, square);\n * // => [16, 64] (iteration order is not guaranteed)\n *\n * var users = [\n *   { 'user': 'barney' },\n *   { 'user': 'fred' }\n * ];\n *\n * // The `_.property` iteratee shorthand.\n * _.map(users, 'user');\n * // => ['barney', 'fred']\n */\nfunction map(collection, iteratee) {\n  var func = isArray(collection) ? arrayMap : baseMap;\n  return func(collection, baseIteratee(iteratee, 3));\n}\n\nmodule.exports = map;\n", "/**\n * A specialized version of `_.forEach` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns `array`.\n */\nfunction arrayEach(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (iteratee(array[index], index, array) === false) {\n      break;\n    }\n  }\n  return array;\n}\n\nmodule.exports = arrayEach;\n", "var identity = require('./identity');\n\n/**\n * Casts `value` to `identity` if it's not a function.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {Function} Returns cast function.\n */\nfunction castFunction(value) {\n  return typeof value == 'function' ? value : identity;\n}\n\nmodule.exports = castFunction;\n", "var arrayEach = require('./_arrayEach'),\n    baseEach = require('./_baseEach'),\n    castFunction = require('./_castFunction'),\n    isArray = require('./isArray');\n\n/**\n * Iterates over elements of `collection` and invokes `iteratee` for each element.\n * The iteratee is invoked with three arguments: (value, index|key, collection).\n * Iteratee functions may exit iteration early by explicitly returning `false`.\n *\n * **Note:** As with other \"Collections\" methods, objects with a \"length\"\n * property are iterated like arrays. To avoid this behavior use `_.forIn`\n * or `_.forOwn` for object iteration.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @alias each\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n * @returns {Array|Object} Returns `collection`.\n * @see _.forEachRight\n * @example\n *\n * _.forEach([1, 2], function(value) {\n *   console.log(value);\n * });\n * // => Logs `1` then `2`.\n *\n * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {\n *   console.log(key);\n * });\n * // => Logs 'a' then 'b' (iteration order is not guaranteed).\n */\nfunction forEach(collection, iteratee) {\n  var func = isArray(collection) ? arrayEach : baseEach;\n  return func(collection, castFunction(iteratee));\n}\n\nmodule.exports = forEach;\n", "var arrayMap = require('./_arrayMap');\n\n/**\n * The base implementation of `_.values` and `_.valuesIn` which creates an\n * array of `object` property values corresponding to the property names\n * of `props`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array} props The property names to get values for.\n * @returns {Object} Returns the array of property values.\n */\nfunction baseValues(object, props) {\n  return arrayMap(props, function(key) {\n    return object[key];\n  });\n}\n\nmodule.exports = baseValues;\n", "var baseValues = require('./_baseValues'),\n    keys = require('./keys');\n\n/**\n * Creates an array of the own enumerable string keyed property values of `object`.\n *\n * **Note:** Non-object values are coerced to objects.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property values.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.values(new Foo);\n * // => [1, 2] (iteration order is not guaranteed)\n *\n * _.values('hi');\n * // => ['h', 'i']\n */\nfunction values(object) {\n  return object == null ? [] : baseValues(object, keys(object));\n}\n\nmodule.exports = values;\n", "/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * The base implementation of `_.has` without support for deep paths.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {Array|string} key The key to check.\n * @returns {boolean} Returns `true` if `key` exists, else `false`.\n */\nfunction baseHas(object, key) {\n  return object != null && hasOwnProperty.call(object, key);\n}\n\nmodule.exports = baseHas;\n", "var baseHas = require('./_baseHas'),\n    hasPath = require('./_hasPath');\n\n/**\n * Checks if `path` is a direct property of `object`.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\n * @example\n *\n * var object = { 'a': { 'b': 2 } };\n * var other = _.create({ 'a': _.create({ 'b': 2 }) });\n *\n * _.has(object, 'a');\n * // => true\n *\n * _.has(object, 'a.b');\n * // => true\n *\n * _.has(object, ['a', 'b']);\n * // => true\n *\n * _.has(other, 'a');\n * // => false\n */\nfunction has(object, path) {\n  return object != null && hasPath(object, path, baseHas);\n}\n\nmodule.exports = has;\n", "var getNative = require('./_getNative');\n\nvar defineProperty = (function() {\n  try {\n    var func = getNative(Object, 'defineProperty');\n    func({}, '', {});\n    return func;\n  } catch (e) {}\n}());\n\nmodule.exports = defineProperty;\n", "var defineProperty = require('./_defineProperty');\n\n/**\n * The base implementation of `assignValue` and `assignMergeValue` without\n * value checks.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction baseAssignValue(object, key, value) {\n  if (key == '__proto__' && defineProperty) {\n    defineProperty(object, key, {\n      'configurable': true,\n      'enumerable': true,\n      'value': value,\n      'writable': true\n    });\n  } else {\n    object[key] = value;\n  }\n}\n\nmodule.exports = baseAssignValue;\n", "var baseAssignValue = require('./_baseAssignValue'),\n    eq = require('./eq');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Assigns `value` to `key` of `object` if the existing value is not equivalent\n * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * for equality comparisons.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction assignValue(object, key, value) {\n  var objValue = object[key];\n  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||\n      (value === undefined && !(key in object))) {\n    baseAssignValue(object, key, value);\n  }\n}\n\nmodule.exports = assignValue;\n", "var assignValue = require('./_assignValue'),\n    baseAssignValue = require('./_baseAssignValue');\n\n/**\n * Copies properties of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy properties from.\n * @param {Array} props The property identifiers to copy.\n * @param {Object} [object={}] The object to copy properties to.\n * @param {Function} [customizer] The function to customize copied values.\n * @returns {Object} Returns `object`.\n */\nfunction copyObject(source, props, object, customizer) {\n  var isNew = !object;\n  object || (object = {});\n\n  var index = -1,\n      length = props.length;\n\n  while (++index < length) {\n    var key = props[index];\n\n    var newValue = customizer\n      ? customizer(object[key], source[key], key, object, source)\n      : undefined;\n\n    if (newValue === undefined) {\n      newValue = source[key];\n    }\n    if (isNew) {\n      baseAssignValue(object, key, newValue);\n    } else {\n      assignValue(object, key, newValue);\n    }\n  }\n  return object;\n}\n\nmodule.exports = copyObject;\n", "var copyObject = require('./_copyObject'),\n    keys = require('./keys');\n\n/**\n * The base implementation of `_.assign` without support for multiple sources\n * or `customizer` functions.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @returns {Object} Returns `object`.\n */\nfunction baseAssign(object, source) {\n  return object && copyObject(source, keys(source), object);\n}\n\nmodule.exports = baseAssign;\n", "/**\n * This function is like\n * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * except that it includes inherited enumerable properties.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction nativeKeysIn(object) {\n  var result = [];\n  if (object != null) {\n    for (var key in Object(object)) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = nativeKeysIn;\n", "var isObject = require('./isObject'),\n    isPrototype = require('./_isPrototype'),\n    nativeKeysIn = require('./_nativeKeysIn');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeysIn(object) {\n  if (!isObject(object)) {\n    return nativeKeysIn(object);\n  }\n  var isProto = isPrototype(object),\n      result = [];\n\n  for (var key in object) {\n    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseKeysIn;\n", "var arrayLikeKeys = require('./_arrayLikeKeys'),\n    baseKeysIn = require('./_baseKeysIn'),\n    isArrayLike = require('./isArrayLike');\n\n/**\n * Creates an array of the own and inherited enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keysIn(new Foo);\n * // => ['a', 'b', 'c'] (iteration order is not guaranteed)\n */\nfunction keysIn(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);\n}\n\nmodule.exports = keysIn;\n", "var copyObject = require('./_copyObject'),\n    keysIn = require('./keysIn');\n\n/**\n * The base implementation of `_.assignIn` without support for multiple sources\n * or `customizer` functions.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @returns {Object} Returns `object`.\n */\nfunction baseAssignIn(object, source) {\n  return object && copyObject(source, keysIn(source), object);\n}\n\nmodule.exports = baseAssignIn;\n", "var root = require('./_root');\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined,\n    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;\n\n/**\n * Creates a clone of  `buffer`.\n *\n * @private\n * @param {Buffer} buffer The buffer to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Buffer} Returns the cloned buffer.\n */\nfunction cloneBuffer(buffer, isDeep) {\n  if (isDeep) {\n    return buffer.slice();\n  }\n  var length = buffer.length,\n      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);\n\n  buffer.copy(result);\n  return result;\n}\n\nmodule.exports = cloneBuffer;\n", "/**\n * Copies the values of `source` to `array`.\n *\n * @private\n * @param {Array} source The array to copy values from.\n * @param {Array} [array=[]] The array to copy values to.\n * @returns {Array} Returns `array`.\n */\nfunction copyArray(source, array) {\n  var index = -1,\n      length = source.length;\n\n  array || (array = Array(length));\n  while (++index < length) {\n    array[index] = source[index];\n  }\n  return array;\n}\n\nmodule.exports = copyArray;\n", "var copyObject = require('./_copyObject'),\n    getSymbols = require('./_getSymbols');\n\n/**\n * Copies own symbols of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy symbols from.\n * @param {Object} [object={}] The object to copy symbols to.\n * @returns {Object} Returns `object`.\n */\nfunction copySymbols(source, object) {\n  return copyObject(source, getSymbols(source), object);\n}\n\nmodule.exports = copySymbols;\n", "var overArg = require('./_overArg');\n\n/** Built-in value references. */\nvar getPrototype = overArg(Object.getPrototypeOf, Object);\n\nmodule.exports = getPrototype;\n", "var arrayPush = require('./_arrayPush'),\n    getPrototype = require('./_getPrototype'),\n    getSymbols = require('./_getSymbols'),\n    stubArray = require('./stubArray');\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeGetSymbols = Object.getOwnPropertySymbols;\n\n/**\n * Creates an array of the own and inherited enumerable symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */\nvar getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {\n  var result = [];\n  while (object) {\n    arrayPush(result, getSymbols(object));\n    object = getPrototype(object);\n  }\n  return result;\n};\n\nmodule.exports = getSymbolsIn;\n", "var copyObject = require('./_copyObject'),\n    getSymbolsIn = require('./_getSymbolsIn');\n\n/**\n * Copies own and inherited symbols of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy symbols from.\n * @param {Object} [object={}] The object to copy symbols to.\n * @returns {Object} Returns `object`.\n */\nfunction copySymbolsIn(source, object) {\n  return copyObject(source, getSymbolsIn(source), object);\n}\n\nmodule.exports = copySymbolsIn;\n", "var baseGetAllKeys = require('./_baseGetAllKeys'),\n    getSymbolsIn = require('./_getSymbolsIn'),\n    keysIn = require('./keysIn');\n\n/**\n * Creates an array of own and inherited enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction getAllKeysIn(object) {\n  return baseGetAllKeys(object, keysIn, getSymbolsIn);\n}\n\nmodule.exports = getAllKeysIn;\n", "/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Initializes an array clone.\n *\n * @private\n * @param {Array} array The array to clone.\n * @returns {Array} Returns the initialized clone.\n */\nfunction initCloneArray(array) {\n  var length = array.length,\n      result = new array.constructor(length);\n\n  // Add properties assigned by `RegExp#exec`.\n  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {\n    result.index = array.index;\n    result.input = array.input;\n  }\n  return result;\n}\n\nmodule.exports = initCloneArray;\n", "var Uint8Array = require('./_Uint8Array');\n\n/**\n * Creates a clone of `arrayBuffer`.\n *\n * @private\n * @param {ArrayBuffer} arrayBuffer The array buffer to clone.\n * @returns {ArrayBuffer} Returns the cloned array buffer.\n */\nfunction cloneArrayBuffer(arrayBuffer) {\n  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);\n  new Uint8Array(result).set(new Uint8Array(arrayBuffer));\n  return result;\n}\n\nmodule.exports = cloneArrayBuffer;\n", "var cloneArrayBuffer = require('./_cloneArrayBuffer');\n\n/**\n * Creates a clone of `dataView`.\n *\n * @private\n * @param {Object} dataView The data view to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned data view.\n */\nfunction cloneDataView(dataView, isDeep) {\n  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;\n  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);\n}\n\nmodule.exports = cloneDataView;\n", "/** Used to match `RegExp` flags from their coerced string values. */\nvar reFlags = /\\w*$/;\n\n/**\n * Creates a clone of `regexp`.\n *\n * @private\n * @param {Object} regexp The regexp to clone.\n * @returns {Object} Returns the cloned regexp.\n */\nfunction cloneRegExp(regexp) {\n  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));\n  result.lastIndex = regexp.lastIndex;\n  return result;\n}\n\nmodule.exports = cloneRegExp;\n", "var Symbol = require('./_Symbol');\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;\n\n/**\n * Creates a clone of the `symbol` object.\n *\n * @private\n * @param {Object} symbol The symbol object to clone.\n * @returns {Object} Returns the cloned symbol object.\n */\nfunction cloneSymbol(symbol) {\n  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};\n}\n\nmodule.exports = cloneSymbol;\n", "var cloneArrayBuffer = require('./_cloneArrayBuffer');\n\n/**\n * Creates a clone of `typedArray`.\n *\n * @private\n * @param {Object} typedArray The typed array to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned typed array.\n */\nfunction cloneTypedArray(typedArray, isDeep) {\n  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;\n  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);\n}\n\nmodule.exports = cloneTypedArray;\n", "var cloneArrayBuffer = require('./_cloneArrayBuffer'),\n    cloneDataView = require('./_cloneDataView'),\n    cloneRegExp = require('./_cloneRegExp'),\n    cloneSymbol = require('./_cloneSymbol'),\n    cloneTypedArray = require('./_cloneTypedArray');\n\n/** `Object#toString` result references. */\nvar boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/**\n * Initializes an object clone based on its `toStringTag`.\n *\n * **Note:** This function only supports cloning values with tags of\n * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.\n *\n * @private\n * @param {Object} object The object to clone.\n * @param {string} tag The `toStringTag` of the object to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the initialized clone.\n */\nfunction initCloneByTag(object, tag, isDeep) {\n  var Ctor = object.constructor;\n  switch (tag) {\n    case arrayBufferTag:\n      return cloneArrayBuffer(object);\n\n    case boolTag:\n    case dateTag:\n      return new Ctor(+object);\n\n    case dataViewTag:\n      return cloneDataView(object, isDeep);\n\n    case float32Tag: case float64Tag:\n    case int8Tag: case int16Tag: case int32Tag:\n    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:\n      return cloneTypedArray(object, isDeep);\n\n    case mapTag:\n      return new Ctor;\n\n    case numberTag:\n    case stringTag:\n      return new Ctor(object);\n\n    case regexpTag:\n      return cloneRegExp(object);\n\n    case setTag:\n      return new Ctor;\n\n    case symbolTag:\n      return cloneSymbol(object);\n  }\n}\n\nmodule.exports = initCloneByTag;\n", "var isObject = require('./isObject');\n\n/** Built-in value references. */\nvar objectCreate = Object.create;\n\n/**\n * The base implementation of `_.create` without support for assigning\n * properties to the created object.\n *\n * @private\n * @param {Object} proto The object to inherit from.\n * @returns {Object} Returns the new object.\n */\nvar baseCreate = (function() {\n  function object() {}\n  return function(proto) {\n    if (!isObject(proto)) {\n      return {};\n    }\n    if (objectCreate) {\n      return objectCreate(proto);\n    }\n    object.prototype = proto;\n    var result = new object;\n    object.prototype = undefined;\n    return result;\n  };\n}());\n\nmodule.exports = baseCreate;\n", "var baseCreate = require('./_baseCreate'),\n    getPrototype = require('./_getPrototype'),\n    isPrototype = require('./_isPrototype');\n\n/**\n * Initializes an object clone.\n *\n * @private\n * @param {Object} object The object to clone.\n * @returns {Object} Returns the initialized clone.\n */\nfunction initCloneObject(object) {\n  return (typeof object.constructor == 'function' && !isPrototype(object))\n    ? baseCreate(getPrototype(object))\n    : {};\n}\n\nmodule.exports = initCloneObject;\n", "var getTag = require('./_getTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar mapTag = '[object Map]';\n\n/**\n * The base implementation of `_.isMap` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a map, else `false`.\n */\nfunction baseIsMap(value) {\n  return isObjectLike(value) && getTag(value) == mapTag;\n}\n\nmodule.exports = baseIsMap;\n", "var baseIsMap = require('./_baseIsMap'),\n    baseUnary = require('./_baseUnary'),\n    nodeUtil = require('./_nodeUtil');\n\n/* Node.js helper references. */\nvar nodeIsMap = nodeUtil && nodeUtil.isMap;\n\n/**\n * Checks if `value` is classified as a `Map` object.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a map, else `false`.\n * @example\n *\n * _.isMap(new Map);\n * // => true\n *\n * _.isMap(new WeakMap);\n * // => false\n */\nvar isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;\n\nmodule.exports = isMap;\n", "var getTag = require('./_getTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar setTag = '[object Set]';\n\n/**\n * The base implementation of `_.isSet` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a set, else `false`.\n */\nfunction baseIsSet(value) {\n  return isObjectLike(value) && getTag(value) == setTag;\n}\n\nmodule.exports = baseIsSet;\n", "var baseIsSet = require('./_baseIsSet'),\n    baseUnary = require('./_baseUnary'),\n    nodeUtil = require('./_nodeUtil');\n\n/* Node.js helper references. */\nvar nodeIsSet = nodeUtil && nodeUtil.isSet;\n\n/**\n * Checks if `value` is classified as a `Set` object.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a set, else `false`.\n * @example\n *\n * _.isSet(new Set);\n * // => true\n *\n * _.isSet(new WeakSet);\n * // => false\n */\nvar isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;\n\nmodule.exports = isSet;\n", "var Stack = require('./_Stack'),\n    arrayEach = require('./_arrayEach'),\n    assignValue = require('./_assignValue'),\n    baseAssign = require('./_baseAssign'),\n    baseAssignIn = require('./_baseAssignIn'),\n    cloneBuffer = require('./_cloneBuffer'),\n    copyArray = require('./_copyArray'),\n    copySymbols = require('./_copySymbols'),\n    copySymbolsIn = require('./_copySymbolsIn'),\n    getAllKeys = require('./_getAllKeys'),\n    getAllKeysIn = require('./_getAllKeysIn'),\n    getTag = require('./_getTag'),\n    initCloneArray = require('./_initCloneArray'),\n    initCloneByTag = require('./_initCloneByTag'),\n    initCloneObject = require('./_initCloneObject'),\n    isArray = require('./isArray'),\n    isBuffer = require('./isBuffer'),\n    isMap = require('./isMap'),\n    isObject = require('./isObject'),\n    isSet = require('./isSet'),\n    keys = require('./keys'),\n    keysIn = require('./keysIn');\n\n/** Used to compose bitmasks for cloning. */\nvar CLONE_DEEP_FLAG = 1,\n    CLONE_FLAT_FLAG = 2,\n    CLONE_SYMBOLS_FLAG = 4;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    objectTag = '[object Object]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/** Used to identify `toStringTag` values supported by `_.clone`. */\nvar cloneableTags = {};\ncloneableTags[argsTag] = cloneableTags[arrayTag] =\ncloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =\ncloneableTags[boolTag] = cloneableTags[dateTag] =\ncloneableTags[float32Tag] = cloneableTags[float64Tag] =\ncloneableTags[int8Tag] = cloneableTags[int16Tag] =\ncloneableTags[int32Tag] = cloneableTags[mapTag] =\ncloneableTags[numberTag] = cloneableTags[objectTag] =\ncloneableTags[regexpTag] = cloneableTags[setTag] =\ncloneableTags[stringTag] = cloneableTags[symbolTag] =\ncloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =\ncloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;\ncloneableTags[errorTag] = cloneableTags[funcTag] =\ncloneableTags[weakMapTag] = false;\n\n/**\n * The base implementation of `_.clone` and `_.cloneDeep` which tracks\n * traversed objects.\n *\n * @private\n * @param {*} value The value to clone.\n * @param {boolean} bitmask The bitmask flags.\n *  1 - Deep clone\n *  2 - Flatten inherited properties\n *  4 - Clone symbols\n * @param {Function} [customizer] The function to customize cloning.\n * @param {string} [key] The key of `value`.\n * @param {Object} [object] The parent object of `value`.\n * @param {Object} [stack] Tracks traversed objects and their clone counterparts.\n * @returns {*} Returns the cloned value.\n */\nfunction baseClone(value, bitmask, customizer, key, object, stack) {\n  var result,\n      isDeep = bitmask & CLONE_DEEP_FLAG,\n      isFlat = bitmask & CLONE_FLAT_FLAG,\n      isFull = bitmask & CLONE_SYMBOLS_FLAG;\n\n  if (customizer) {\n    result = object ? customizer(value, key, object, stack) : customizer(value);\n  }\n  if (result !== undefined) {\n    return result;\n  }\n  if (!isObject(value)) {\n    return value;\n  }\n  var isArr = isArray(value);\n  if (isArr) {\n    result = initCloneArray(value);\n    if (!isDeep) {\n      return copyArray(value, result);\n    }\n  } else {\n    var tag = getTag(value),\n        isFunc = tag == funcTag || tag == genTag;\n\n    if (isBuffer(value)) {\n      return cloneBuffer(value, isDeep);\n    }\n    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {\n      result = (isFlat || isFunc) ? {} : initCloneObject(value);\n      if (!isDeep) {\n        return isFlat\n          ? copySymbolsIn(value, baseAssignIn(result, value))\n          : copySymbols(value, baseAssign(result, value));\n      }\n    } else {\n      if (!cloneableTags[tag]) {\n        return object ? value : {};\n      }\n      result = initCloneByTag(value, tag, isDeep);\n    }\n  }\n  // Check for circular references and return its corresponding clone.\n  stack || (stack = new Stack);\n  var stacked = stack.get(value);\n  if (stacked) {\n    return stacked;\n  }\n  stack.set(value, result);\n\n  if (isSet(value)) {\n    value.forEach(function(subValue) {\n      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));\n    });\n  } else if (isMap(value)) {\n    value.forEach(function(subValue, key) {\n      result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));\n    });\n  }\n\n  var keysFunc = isFull\n    ? (isFlat ? getAllKeysIn : getAllKeys)\n    : (isFlat ? keysIn : keys);\n\n  var props = isArr ? undefined : keysFunc(value);\n  arrayEach(props || value, function(subValue, key) {\n    if (props) {\n      key = subValue;\n      subValue = value[key];\n    }\n    // Recursively populate clone (susceptible to call stack limits).\n    assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));\n  });\n  return result;\n}\n\nmodule.exports = baseClone;\n", "var baseClone = require('./_baseClone');\n\n/** Used to compose bitmasks for cloning. */\nvar CLONE_SYMBOLS_FLAG = 4;\n\n/**\n * Creates a shallow clone of `value`.\n *\n * **Note:** This method is loosely based on the\n * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)\n * and supports cloning arrays, array buffers, booleans, date objects, maps,\n * numbers, `Object` objects, regexes, sets, strings, symbols, and typed\n * arrays. The own enumerable properties of `arguments` objects are cloned\n * as plain objects. An empty object is returned for uncloneable values such\n * as error objects, functions, DOM nodes, and WeakMaps.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to clone.\n * @returns {*} Returns the cloned value.\n * @see _.cloneDeep\n * @example\n *\n * var objects = [{ 'a': 1 }, { 'b': 2 }];\n *\n * var shallow = _.clone(objects);\n * console.log(shallow[0] === objects[0]);\n * // => true\n */\nfunction clone(value) {\n  return baseClone(value, CLONE_SYMBOLS_FLAG);\n}\n\nmodule.exports = clone;\n", "export function PRINT_ERROR(msg: string) {\n  /* istanbul ignore else - can't override global.console in node.js */\n  if (console && console.error) {\n    console.error(`Error: ${msg}`)\n  }\n}\n\nexport function PRINT_WARNING(msg: string) {\n  /* istanbul ignore else - can't override global.console in node.js*/\n  if (console && console.warn) {\n    // TODO: modify docs accordingly\n    console.warn(`Warning: ${msg}`)\n  }\n}\n", "export function timer<T>(func: () => T): { time: number; value: T } {\n  const start = new Date().getTime()\n  const val = func()\n  const end = new Date().getTime()\n  const total = end - start\n  return { time: total, value: val }\n}\n", "// based on: https://github.com/petkaantonov/bluebird/blob/b97c0d2d487e8c5076e8bd897e0dcd4622d31846/src/util.js#L201-L216\nexport function toFastProperties(toBecomeFast: any) {\n  function FakeConstructor() {}\n\n  // If our object is used as a constructor it would receive\n  FakeConstructor.prototype = toBecomeFast\n  const fakeInstance = new (FakeConstructor as any)()\n\n  function fakeAccess() {\n    return typeof fakeInstance.bar\n  }\n\n  // help V8 understand this is a \"real\" prototype by actually using\n  // the fake instance.\n  fakeAccess()\n  fakeAccess()\n\n  // Always true condition to suppress the Firefox warning of unreachable\n  // code after a return statement.\n  if (1) return toBecomeFast\n\n  // Eval prevents optimization of this method (even though this is dead code)\n  /* istanbul ignore next */\n  // tslint:disable-next-line\n  eval(toBecomeFast)\n}\n", "export { PRINT_WARNING, PRINT_ERROR } from \"./print\"\nexport { timer } from \"./timer\"\nexport { toFastProperties } from \"./to-fast-properties\"\n", "/**\n * The base implementation of `_.slice` without an iteratee call guard.\n *\n * @private\n * @param {Array} array The array to slice.\n * @param {number} [start=0] The start position.\n * @param {number} [end=array.length] The end position.\n * @returns {Array} Returns the slice of `array`.\n */\nfunction baseSlice(array, start, end) {\n  var index = -1,\n      length = array.length;\n\n  if (start < 0) {\n    start = -start > length ? 0 : (length + start);\n  }\n  end = end > length ? length : end;\n  if (end < 0) {\n    end += length;\n  }\n  length = start > end ? 0 : ((end - start) >>> 0);\n  start >>>= 0;\n\n  var result = Array(length);\n  while (++index < length) {\n    result[index] = array[index + start];\n  }\n  return result;\n}\n\nmodule.exports = baseSlice;\n", "/** Used to match a single whitespace character. */\nvar reWhitespace = /\\s/;\n\n/**\n * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace\n * character of `string`.\n *\n * @private\n * @param {string} string The string to inspect.\n * @returns {number} Returns the index of the last non-whitespace character.\n */\nfunction trimmedEndIndex(string) {\n  var index = string.length;\n\n  while (index-- && reWhitespace.test(string.charAt(index))) {}\n  return index;\n}\n\nmodule.exports = trimmedEndIndex;\n", "var trimmedEndIndex = require('./_trimmedEndIndex');\n\n/** Used to match leading whitespace. */\nvar reTrimStart = /^\\s+/;\n\n/**\n * The base implementation of `_.trim`.\n *\n * @private\n * @param {string} string The string to trim.\n * @returns {string} Returns the trimmed string.\n */\nfunction baseTrim(string) {\n  return string\n    ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')\n    : string;\n}\n\nmodule.exports = baseTrim;\n", "var baseTrim = require('./_baseTrim'),\n    isObject = require('./isObject'),\n    isSymbol = require('./isSymbol');\n\n/** Used as references for various `Number` constants. */\nvar NAN = 0 / 0;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return NAN;\n  }\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = baseTrim(value);\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\nmodule.exports = toNumber;\n", "var toNumber = require('./toNumber');\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0,\n    MAX_INTEGER = 1.7976931348623157e+308;\n\n/**\n * Converts `value` to a finite number.\n *\n * @static\n * @memberOf _\n * @since 4.12.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {number} Returns the converted number.\n * @example\n *\n * _.toFinite(3.2);\n * // => 3.2\n *\n * _.toFinite(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toFinite(Infinity);\n * // => 1.7976931348623157e+308\n *\n * _.toFinite('3.2');\n * // => 3.2\n */\nfunction toFinite(value) {\n  if (!value) {\n    return value === 0 ? value : 0;\n  }\n  value = toNumber(value);\n  if (value === INFINITY || value === -INFINITY) {\n    var sign = (value < 0 ? -1 : 1);\n    return sign * MAX_INTEGER;\n  }\n  return value === value ? value : 0;\n}\n\nmodule.exports = toFinite;\n", "var toFinite = require('./toFinite');\n\n/**\n * Converts `value` to an integer.\n *\n * **Note:** This method is loosely based on\n * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {number} Returns the converted integer.\n * @example\n *\n * _.toInteger(3.2);\n * // => 3\n *\n * _.toInteger(Number.MIN_VALUE);\n * // => 0\n *\n * _.toInteger(Infinity);\n * // => 1.7976931348623157e+308\n *\n * _.toInteger('3.2');\n * // => 3\n */\nfunction toInteger(value) {\n  var result = toFinite(value),\n      remainder = result % 1;\n\n  return result === result ? (remainder ? result - remainder : result) : 0;\n}\n\nmodule.exports = toInteger;\n", "var baseSlice = require('./_baseSlice'),\n    toInteger = require('./toInteger');\n\n/**\n * Creates a slice of `array` with `n` elements dropped from the beginning.\n *\n * @static\n * @memberOf _\n * @since 0.5.0\n * @category Array\n * @param {Array} array The array to query.\n * @param {number} [n=1] The number of elements to drop.\n * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n * @returns {Array} Returns the slice of `array`.\n * @example\n *\n * _.drop([1, 2, 3]);\n * // => [2, 3]\n *\n * _.drop([1, 2, 3], 2);\n * // => [3]\n *\n * _.drop([1, 2, 3], 5);\n * // => []\n *\n * _.drop([1, 2, 3], 0);\n * // => [1, 2, 3]\n */\nfunction drop(array, n, guard) {\n  var length = array == null ? 0 : array.length;\n  if (!length) {\n    return [];\n  }\n  n = (guard || n === undefined) ? 1 : toInteger(n);\n  return baseSlice(array, n < 0 ? 0 : n, length);\n}\n\nmodule.exports = drop;\n", "var baseGetTag = require('./_baseGetTag'),\n    isArray = require('./isArray'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar stringTag = '[object String]';\n\n/**\n * Checks if `value` is classified as a `String` primitive or object.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a string, else `false`.\n * @example\n *\n * _.isString('abc');\n * // => true\n *\n * _.isString(1);\n * // => false\n */\nfunction isString(value) {\n  return typeof value == 'string' ||\n    (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);\n}\n\nmodule.exports = isString;\n", "var baseGetTag = require('./_baseGetTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar regexpTag = '[object RegExp]';\n\n/**\n * The base implementation of `_.isRegExp` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.\n */\nfunction baseIsRegExp(value) {\n  return isObjectLike(value) && baseGetTag(value) == regexpTag;\n}\n\nmodule.exports = baseIsRegExp;\n", "var baseIsRegExp = require('./_baseIsRegExp'),\n    baseUnary = require('./_baseUnary'),\n    nodeUtil = require('./_nodeUtil');\n\n/* Node.js helper references. */\nvar nodeIsRegExp = nodeUtil && nodeUtil.isRegExp;\n\n/**\n * Checks if `value` is classified as a `RegExp` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.\n * @example\n *\n * _.isRegExp(/abc/);\n * // => true\n *\n * _.isRegExp('/abc/');\n * // => false\n */\nvar isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;\n\nmodule.exports = isRegExp;\n", "var assignValue = require('./_assignValue'),\n    castPath = require('./_castPath'),\n    isIndex = require('./_isIndex'),\n    isObject = require('./isObject'),\n    toKey = require('./_toKey');\n\n/**\n * The base implementation of `_.set`.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {Array|string} path The path of the property to set.\n * @param {*} value The value to set.\n * @param {Function} [customizer] The function to customize path creation.\n * @returns {Object} Returns `object`.\n */\nfunction baseSet(object, path, value, customizer) {\n  if (!isObject(object)) {\n    return object;\n  }\n  path = castPath(path, object);\n\n  var index = -1,\n      length = path.length,\n      lastIndex = length - 1,\n      nested = object;\n\n  while (nested != null && ++index < length) {\n    var key = toKey(path[index]),\n        newValue = value;\n\n    if (key === '__proto__' || key === 'constructor' || key === 'prototype') {\n      return object;\n    }\n\n    if (index != lastIndex) {\n      var objValue = nested[key];\n      newValue = customizer ? customizer(objValue, key, nested) : undefined;\n      if (newValue === undefined) {\n        newValue = isObject(objValue)\n          ? objValue\n          : (isIndex(path[index + 1]) ? [] : {});\n      }\n    }\n    assignValue(nested, key, newValue);\n    nested = nested[key];\n  }\n  return object;\n}\n\nmodule.exports = baseSet;\n", "var baseGet = require('./_baseGet'),\n    baseSet = require('./_baseSet'),\n    castPath = require('./_castPath');\n\n/**\n * The base implementation of  `_.pickBy` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The source object.\n * @param {string[]} paths The property paths to pick.\n * @param {Function} predicate The function invoked per property.\n * @returns {Object} Returns the new object.\n */\nfunction basePickBy(object, paths, predicate) {\n  var index = -1,\n      length = paths.length,\n      result = {};\n\n  while (++index < length) {\n    var path = paths[index],\n        value = baseGet(object, path);\n\n    if (predicate(value, path)) {\n      baseSet(result, castPath(path, object), value);\n    }\n  }\n  return result;\n}\n\nmodule.exports = basePickBy;\n", "var arrayMap = require('./_arrayMap'),\n    baseIteratee = require('./_baseIteratee'),\n    basePickBy = require('./_basePickBy'),\n    getAllKeysIn = require('./_getAllKeysIn');\n\n/**\n * Creates an object composed of the `object` properties `predicate` returns\n * truthy for. The predicate is invoked with two arguments: (value, key).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Object\n * @param {Object} object The source object.\n * @param {Function} [predicate=_.identity] The function invoked per property.\n * @returns {Object} Returns the new object.\n * @example\n *\n * var object = { 'a': 1, 'b': '2', 'c': 3 };\n *\n * _.pickBy(object, _.isNumber);\n * // => { 'a': 1, 'c': 3 }\n */\nfunction pickBy(object, predicate) {\n  if (object == null) {\n    return {};\n  }\n  var props = arrayMap(getAllKeysIn(object), function(prop) {\n    return [prop];\n  });\n  predicate = baseIteratee(predicate);\n  return basePickBy(object, props, function(value, path) {\n    return predicate(value, path[0]);\n  });\n}\n\nmodule.exports = pickBy;\n", "/**\n * A faster alternative to `Function#apply`, this function invokes `func`\n * with the `this` binding of `thisArg` and the arguments of `args`.\n *\n * @private\n * @param {Function} func The function to invoke.\n * @param {*} thisArg The `this` binding of `func`.\n * @param {Array} args The arguments to invoke `func` with.\n * @returns {*} Returns the result of `func`.\n */\nfunction apply(func, thisArg, args) {\n  switch (args.length) {\n    case 0: return func.call(thisArg);\n    case 1: return func.call(thisArg, args[0]);\n    case 2: return func.call(thisArg, args[0], args[1]);\n    case 3: return func.call(thisArg, args[0], args[1], args[2]);\n  }\n  return func.apply(thisArg, args);\n}\n\nmodule.exports = apply;\n", "var apply = require('./_apply');\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max;\n\n/**\n * A specialized version of `baseRest` which transforms the rest array.\n *\n * @private\n * @param {Function} func The function to apply a rest parameter to.\n * @param {number} [start=func.length-1] The start position of the rest parameter.\n * @param {Function} transform The rest array transform.\n * @returns {Function} Returns the new function.\n */\nfunction overRest(func, start, transform) {\n  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);\n  return function() {\n    var args = arguments,\n        index = -1,\n        length = nativeMax(args.length - start, 0),\n        array = Array(length);\n\n    while (++index < length) {\n      array[index] = args[start + index];\n    }\n    index = -1;\n    var otherArgs = Array(start + 1);\n    while (++index < start) {\n      otherArgs[index] = args[index];\n    }\n    otherArgs[start] = transform(array);\n    return apply(func, this, otherArgs);\n  };\n}\n\nmodule.exports = overRest;\n", "/**\n * Creates a function that returns `value`.\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Util\n * @param {*} value The value to return from the new function.\n * @returns {Function} Returns the new constant function.\n * @example\n *\n * var objects = _.times(2, _.constant({ 'a': 1 }));\n *\n * console.log(objects);\n * // => [{ 'a': 1 }, { 'a': 1 }]\n *\n * console.log(objects[0] === objects[1]);\n * // => true\n */\nfunction constant(value) {\n  return function() {\n    return value;\n  };\n}\n\nmodule.exports = constant;\n", "var constant = require('./constant'),\n    defineProperty = require('./_defineProperty'),\n    identity = require('./identity');\n\n/**\n * The base implementation of `setToString` without support for hot loop shorting.\n *\n * @private\n * @param {Function} func The function to modify.\n * @param {Function} string The `toString` result.\n * @returns {Function} Returns `func`.\n */\nvar baseSetToString = !defineProperty ? identity : function(func, string) {\n  return defineProperty(func, 'toString', {\n    'configurable': true,\n    'enumerable': false,\n    'value': constant(string),\n    'writable': true\n  });\n};\n\nmodule.exports = baseSetToString;\n", "/** Used to detect hot functions by number of calls within a span of milliseconds. */\nvar HOT_COUNT = 800,\n    HOT_SPAN = 16;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeNow = Date.now;\n\n/**\n * Creates a function that'll short out and invoke `identity` instead\n * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`\n * milliseconds.\n *\n * @private\n * @param {Function} func The function to restrict.\n * @returns {Function} Returns the new shortable function.\n */\nfunction shortOut(func) {\n  var count = 0,\n      lastCalled = 0;\n\n  return function() {\n    var stamp = nativeNow(),\n        remaining = HOT_SPAN - (stamp - lastCalled);\n\n    lastCalled = stamp;\n    if (remaining > 0) {\n      if (++count >= HOT_COUNT) {\n        return arguments[0];\n      }\n    } else {\n      count = 0;\n    }\n    return func.apply(undefined, arguments);\n  };\n}\n\nmodule.exports = shortOut;\n", "var baseSetToString = require('./_baseSetToString'),\n    shortOut = require('./_shortOut');\n\n/**\n * Sets the `toString` method of `func` to return `string`.\n *\n * @private\n * @param {Function} func The function to modify.\n * @param {Function} string The `toString` result.\n * @returns {Function} Returns `func`.\n */\nvar setToString = shortOut(baseSetToString);\n\nmodule.exports = setToString;\n", "var identity = require('./identity'),\n    overRest = require('./_overRest'),\n    setToString = require('./_setToString');\n\n/**\n * The base implementation of `_.rest` which doesn't validate or coerce arguments.\n *\n * @private\n * @param {Function} func The function to apply a rest parameter to.\n * @param {number} [start=func.length-1] The start position of the rest parameter.\n * @returns {Function} Returns the new function.\n */\nfunction baseRest(func, start) {\n  return setToString(overRest(func, start, identity), func + '');\n}\n\nmodule.exports = baseRest;\n", "var eq = require('./eq'),\n    isArrayLike = require('./isArrayLike'),\n    isIndex = require('./_isIndex'),\n    isObject = require('./isObject');\n\n/**\n * Checks if the given arguments are from an iteratee call.\n *\n * @private\n * @param {*} value The potential iteratee value argument.\n * @param {*} index The potential iteratee index or key argument.\n * @param {*} object The potential iteratee object argument.\n * @returns {boolean} Returns `true` if the arguments are from an iteratee call,\n *  else `false`.\n */\nfunction isIterateeCall(value, index, object) {\n  if (!isObject(object)) {\n    return false;\n  }\n  var type = typeof index;\n  if (type == 'number'\n        ? (isArrayLike(object) && isIndex(index, object.length))\n        : (type == 'string' && index in object)\n      ) {\n    return eq(object[index], value);\n  }\n  return false;\n}\n\nmodule.exports = isIterateeCall;\n", "var baseRest = require('./_baseRest'),\n    isIterateeCall = require('./_isIterateeCall');\n\n/**\n * Creates a function like `_.assign`.\n *\n * @private\n * @param {Function} assigner The function to assign values.\n * @returns {Function} Returns the new assigner function.\n */\nfunction createAssigner(assigner) {\n  return baseRest(function(object, sources) {\n    var index = -1,\n        length = sources.length,\n        customizer = length > 1 ? sources[length - 1] : undefined,\n        guard = length > 2 ? sources[2] : undefined;\n\n    customizer = (assigner.length > 3 && typeof customizer == 'function')\n      ? (length--, customizer)\n      : undefined;\n\n    if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n      customizer = length < 3 ? undefined : customizer;\n      length = 1;\n    }\n    object = Object(object);\n    while (++index < length) {\n      var source = sources[index];\n      if (source) {\n        assigner(object, source, index, customizer);\n      }\n    }\n    return object;\n  });\n}\n\nmodule.exports = createAssigner;\n", "var assignValue = require('./_assignValue'),\n    copyObject = require('./_copyObject'),\n    createAssigner = require('./_createAssigner'),\n    isArrayLike = require('./isArrayLike'),\n    isPrototype = require('./_isPrototype'),\n    keys = require('./keys');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Assigns own enumerable string keyed properties of source objects to the\n * destination object. Source objects are applied from left to right.\n * Subsequent sources overwrite property assignments of previous sources.\n *\n * **Note:** This method mutates `object` and is loosely based on\n * [`Object.assign`](https://mdn.io/Object/assign).\n *\n * @static\n * @memberOf _\n * @since 0.10.0\n * @category Object\n * @param {Object} object The destination object.\n * @param {...Object} [sources] The source objects.\n * @returns {Object} Returns `object`.\n * @see _.assignIn\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n * }\n *\n * function Bar() {\n *   this.c = 3;\n * }\n *\n * Foo.prototype.b = 2;\n * Bar.prototype.d = 4;\n *\n * _.assign({ 'a': 0 }, new Foo, new Bar);\n * // => { 'a': 1, 'c': 3 }\n */\nvar assign = createAssigner(function(object, source) {\n  if (isPrototype(source) || isArrayLike(source)) {\n    copyObject(source, keys(source), object);\n    return;\n  }\n  for (var key in source) {\n    if (hasOwnProperty.call(source, key)) {\n      assignValue(object, key, source[key]);\n    }\n  }\n});\n\nmodule.exports = assign;\n", "import map from \"lodash/map\"\nimport forEach from \"lodash/forEach\"\nimport isString from \"lodash/isString\"\nimport isRegExp from \"lodash/isRegExp\"\nimport pickBy from \"lodash/pickBy\"\nimport assign from \"lodash/assign\"\nimport {\n  IGASTVisitor,\n  IProduction,\n  IProductionWithOccurrence,\n  ISerializedGast,\n  TokenType\n} from \"@chevrotain/types\"\n\n// TODO: duplicated code to avoid extracting another sub-package -- how to avoid?\nfunction tokenLabel(tokType: TokenType): string {\n  if (hasTokenLabel(tokType)) {\n    return tokType.LABEL\n  } else {\n    return tokType.name\n  }\n}\n\n// TODO: duplicated code to avoid extracting another sub-package -- how to avoid?\nfunction hasTokenLabel(\n  obj: TokenType\n): obj is TokenType & Pick<Required<TokenType>, \"LABEL\"> {\n  return isString(obj.LABEL) && obj.LABEL !== \"\"\n}\n\nexport abstract class AbstractProduction<T extends IProduction = IProduction>\n  implements IProduction\n{\n  public get definition(): T[] {\n    return this._definition\n  }\n  public set definition(value: T[]) {\n    this._definition = value\n  }\n\n  constructor(protected _definition: T[]) {}\n\n  accept(visitor: IGASTVisitor): void {\n    visitor.visit(this)\n    forEach(this.definition, (prod) => {\n      prod.accept(visitor)\n    })\n  }\n}\n\nexport class NonTerminal\n  extends AbstractProduction\n  implements IProductionWithOccurrence\n{\n  public nonTerminalName!: string\n  public label?: string\n  public referencedRule!: Rule\n  public idx: number = 1\n\n  constructor(options: {\n    nonTerminalName: string\n    label?: string\n    referencedRule?: Rule\n    idx?: number\n  }) {\n    super([])\n    assign(\n      this,\n      pickBy(options, (v) => v !== undefined)\n    )\n  }\n\n  set definition(definition: IProduction[]) {\n    // immutable\n  }\n\n  get definition(): IProduction[] {\n    if (this.referencedRule !== undefined) {\n      return this.referencedRule.definition\n    }\n    return []\n  }\n\n  accept(visitor: IGASTVisitor): void {\n    visitor.visit(this)\n    // don't visit children of a reference, we will get cyclic infinite loops if we do so\n  }\n}\n\nexport class Rule extends AbstractProduction {\n  public name!: string\n  public orgText: string = \"\"\n\n  constructor(options: {\n    name: string\n    definition: IProduction[]\n    orgText?: string\n  }) {\n    super(options.definition)\n    assign(\n      this,\n      pickBy(options, (v) => v !== undefined)\n    )\n  }\n}\n\nexport class Alternative extends AbstractProduction {\n  public ignoreAmbiguities: boolean = false\n\n  constructor(options: {\n    definition: IProduction[]\n    ignoreAmbiguities?: boolean\n  }) {\n    super(options.definition)\n    assign(\n      this,\n      pickBy(options, (v) => v !== undefined)\n    )\n  }\n}\n\nexport class Option\n  extends AbstractProduction\n  implements IProductionWithOccurrence\n{\n  public idx: number = 1\n  public maxLookahead?: number\n\n  constructor(options: {\n    definition: IProduction[]\n    idx?: number\n    maxLookahead?: number\n  }) {\n    super(options.definition)\n    assign(\n      this,\n      pickBy(options, (v) => v !== undefined)\n    )\n  }\n}\n\nexport class RepetitionMandatory\n  extends AbstractProduction\n  implements IProductionWithOccurrence\n{\n  public idx: number = 1\n  public maxLookahead?: number\n\n  constructor(options: {\n    definition: IProduction[]\n    idx?: number\n    maxLookahead?: number\n  }) {\n    super(options.definition)\n    assign(\n      this,\n      pickBy(options, (v) => v !== undefined)\n    )\n  }\n}\n\nexport class RepetitionMandatoryWithSeparator\n  extends AbstractProduction\n  implements IProductionWithOccurrence\n{\n  public separator!: TokenType\n  public idx: number = 1\n  public maxLookahead?: number\n\n  constructor(options: {\n    definition: IProduction[]\n    separator: TokenType\n    idx?: number\n  }) {\n    super(options.definition)\n    assign(\n      this,\n      pickBy(options, (v) => v !== undefined)\n    )\n  }\n}\n\nexport class Repetition\n  extends AbstractProduction\n  implements IProductionWithOccurrence\n{\n  public separator!: TokenType\n  public idx: number = 1\n  public maxLookahead?: number\n\n  constructor(options: {\n    definition: IProduction[]\n    idx?: number\n    maxLookahead?: number\n  }) {\n    super(options.definition)\n    assign(\n      this,\n      pickBy(options, (v) => v !== undefined)\n    )\n  }\n}\n\nexport class RepetitionWithSeparator\n  extends AbstractProduction\n  implements IProductionWithOccurrence\n{\n  public separator!: TokenType\n  public idx: number = 1\n  public maxLookahead?: number\n\n  constructor(options: {\n    definition: IProduction[]\n    separator: TokenType\n    idx?: number\n  }) {\n    super(options.definition)\n    assign(\n      this,\n      pickBy(options, (v) => v !== undefined)\n    )\n  }\n}\n\nexport class Alternation\n  extends AbstractProduction<Alternative>\n  implements IProductionWithOccurrence\n{\n  public idx: number = 1\n  public ignoreAmbiguities: boolean = false\n  public hasPredicates: boolean = false\n  public maxLookahead?: number\n\n  public get definition(): Alternative[] {\n    return this._definition\n  }\n  public set definition(value: Alternative[]) {\n    this._definition = value\n  }\n\n  constructor(options: {\n    definition: Alternative[]\n    idx?: number\n    ignoreAmbiguities?: boolean\n    hasPredicates?: boolean\n    maxLookahead?: number\n  }) {\n    super(options.definition)\n    assign(\n      this,\n      pickBy(options, (v) => v !== undefined)\n    )\n  }\n}\n\nexport class Terminal implements IProductionWithOccurrence {\n  public terminalType!: TokenType\n  public label?: string\n  public idx: number = 1\n\n  constructor(options: {\n    terminalType: TokenType\n    label?: string\n    idx?: number\n  }) {\n    assign(\n      this,\n      pickBy(options, (v) => v !== undefined)\n    )\n  }\n\n  accept(visitor: IGASTVisitor): void {\n    visitor.visit(this)\n  }\n}\n\nexport interface ISerializedBasic extends ISerializedGast {\n  type:\n    | \"Alternative\"\n    | \"Option\"\n    | \"RepetitionMandatory\"\n    | \"Repetition\"\n    | \"Alternation\"\n  idx?: number\n}\n\nexport interface ISerializedGastRule extends ISerializedGast {\n  type: \"Rule\"\n  name: string\n  orgText: string\n}\n\nexport interface ISerializedNonTerminal extends ISerializedGast {\n  type: \"NonTerminal\"\n  name: string\n  label?: string\n  idx: number\n}\n\nexport interface ISerializedTerminal extends ISerializedGast {\n  type: \"Terminal\"\n  name: string\n  terminalLabel?: string\n  label?: string\n  pattern?: string\n  idx: number\n}\n\nexport interface ISerializedTerminalWithSeparator extends ISerializedGast {\n  type: \"RepetitionMandatoryWithSeparator\" | \"RepetitionWithSeparator\"\n  idx: number\n  separator: ISerializedTerminal\n}\n\nexport type ISerializedGastAny =\n  | ISerializedBasic\n  | ISerializedGastRule\n  | ISerializedNonTerminal\n  | ISerializedTerminal\n  | ISerializedTerminalWithSeparator\n\nexport function serializeGrammar(topRules: Rule[]): ISerializedGast[] {\n  return map(topRules, serializeProduction)\n}\n\nexport function serializeProduction(node: IProduction): ISerializedGast {\n  function convertDefinition(definition: IProduction[]): ISerializedGast[] {\n    return map(definition, serializeProduction)\n  }\n  /* istanbul ignore else */\n  if (node instanceof NonTerminal) {\n    const serializedNonTerminal: ISerializedNonTerminal = {\n      type: \"NonTerminal\",\n      name: node.nonTerminalName,\n      idx: node.idx\n    }\n\n    if (isString(node.label)) {\n      serializedNonTerminal.label = node.label\n    }\n\n    return serializedNonTerminal\n  } else if (node instanceof Alternative) {\n    return <ISerializedBasic>{\n      type: \"Alternative\",\n      definition: convertDefinition(node.definition)\n    }\n  } else if (node instanceof Option) {\n    return <ISerializedBasic>{\n      type: \"Option\",\n      idx: node.idx,\n      definition: convertDefinition(node.definition)\n    }\n  } else if (node instanceof RepetitionMandatory) {\n    return <ISerializedBasic>{\n      type: \"RepetitionMandatory\",\n      idx: node.idx,\n      definition: convertDefinition(node.definition)\n    }\n  } else if (node instanceof RepetitionMandatoryWithSeparator) {\n    return <ISerializedTerminalWithSeparator>{\n      type: \"RepetitionMandatoryWithSeparator\",\n      idx: node.idx,\n      separator: <ISerializedTerminal>(\n        serializeProduction(new Terminal({ terminalType: node.separator }))\n      ),\n      definition: convertDefinition(node.definition)\n    }\n  } else if (node instanceof RepetitionWithSeparator) {\n    return <ISerializedTerminalWithSeparator>{\n      type: \"RepetitionWithSeparator\",\n      idx: node.idx,\n      separator: <ISerializedTerminal>(\n        serializeProduction(new Terminal({ terminalType: node.separator }))\n      ),\n      definition: convertDefinition(node.definition)\n    }\n  } else if (node instanceof Repetition) {\n    return <ISerializedBasic>{\n      type: \"Repetition\",\n      idx: node.idx,\n      definition: convertDefinition(node.definition)\n    }\n  } else if (node instanceof Alternation) {\n    return <ISerializedBasic>{\n      type: \"Alternation\",\n      idx: node.idx,\n      definition: convertDefinition(node.definition)\n    }\n  } else if (node instanceof Terminal) {\n    const serializedTerminal = <ISerializedTerminal>{\n      type: \"Terminal\",\n      name: node.terminalType.name,\n      label: tokenLabel(node.terminalType),\n      idx: node.idx\n    }\n\n    if (isString(node.label)) {\n      serializedTerminal.terminalLabel = node.label\n    }\n\n    const pattern = node.terminalType.PATTERN\n    if (node.terminalType.PATTERN) {\n      serializedTerminal.pattern = isRegExp(pattern)\n        ? (<any>pattern).source\n        : pattern\n    }\n\n    return serializedTerminal\n  } else if (node instanceof Rule) {\n    return <ISerializedGastRule>{\n      type: \"Rule\",\n      name: node.name,\n      orgText: node.orgText,\n      definition: convertDefinition(node.definition)\n    }\n  } else {\n    throw Error(\"non exhaustive match\")\n  }\n}\n", "import {\n  Alternation,\n  Alternative,\n  NonTerminal,\n  Option,\n  Repetition,\n  RepetitionMandatory,\n  RepetitionMandatoryWithSeparator,\n  RepetitionWithSeparator,\n  Rule,\n  Terminal\n} from \"./model\"\nimport { IProduction } from \"@chevrotain/types\"\n\nexport abstract class GAstVisitor {\n  public visit(node: IProduction): any {\n    const nodeAny: any = node\n    switch (nodeAny.constructor) {\n      case NonTerminal:\n        return this.visitNonTerminal(nodeAny)\n      case Alternative:\n        return this.visitAlternative(nodeAny)\n      case Option:\n        return this.visitOption(nodeAny)\n      case RepetitionMandatory:\n        return this.visitRepetitionMandatory(nodeAny)\n      case RepetitionMandatoryWithSeparator:\n        return this.visitRepetitionMandatoryWithSeparator(nodeAny)\n      case RepetitionWithSeparator:\n        return this.visitRepetitionWithSeparator(nodeAny)\n      case Repetition:\n        return this.visitRepetition(nodeAny)\n      case Alternation:\n        return this.visitAlternation(nodeAny)\n      case Terminal:\n        return this.visitTerminal(nodeAny)\n      case Rule:\n        return this.visitRule(nodeAny)\n      /* istanbul ignore next */\n      default:\n        throw Error(\"non exhaustive match\")\n    }\n  }\n\n  /* istanbul ignore next - testing the fact a NOOP function exists is non-trivial  */\n  public visitNonTerminal(node: NonTerminal): any {}\n\n  /* istanbul ignore next - testing the fact a NOOP function exists is non-trivial  */\n  public visitAlternative(node: Alternative): any {}\n\n  /* istanbul ignore next - testing the fact a NOOP function exists is non-trivial  */\n  public visitOption(node: Option): any {}\n\n  /* istanbul ignore next - testing the fact a NOOP function exists is non-trivial  */\n  public visitRepetition(node: Repetition): any {}\n\n  /* istanbul ignore next - testing the fact a NOOP function exists is non-trivial  */\n  public visitRepetitionMandatory(node: RepetitionMandatory): any {}\n\n  /* istanbul ignore next - testing the fact a NOOP function exists is non-trivial  */\n  public visitRepetitionMandatoryWithSeparator(\n    node: RepetitionMandatoryWithSeparator\n  ): any {}\n\n  /* istanbul ignore next - testing the fact a NOOP function exists is non-trivial  */\n  public visitRepetitionWithSeparator(node: RepetitionWithSeparator): any {}\n\n  /* istanbul ignore next - testing the fact a NOOP function exists is non-trivial  */\n  public visitAlternation(node: Alternation): any {}\n\n  /* istanbul ignore next - testing the fact a NOOP function exists is non-trivial  */\n  public visitTerminal(node: Terminal): any {}\n\n  /* istanbul ignore next - testing the fact a NOOP function exists is non-trivial  */\n  public visitRule(node: Rule): any {}\n}\n", "var baseEach = require('./_baseEach');\n\n/**\n * The base implementation of `_.some` without support for iteratee shorthands.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {boolean} Returns `true` if any element passes the predicate check,\n *  else `false`.\n */\nfunction baseSome(collection, predicate) {\n  var result;\n\n  baseEach(collection, function(value, index, collection) {\n    result = predicate(value, index, collection);\n    return !result;\n  });\n  return !!result;\n}\n\nmodule.exports = baseSome;\n", "var arraySome = require('./_arraySome'),\n    baseIteratee = require('./_baseIteratee'),\n    baseSome = require('./_baseSome'),\n    isArray = require('./isArray'),\n    isIterateeCall = require('./_isIterateeCall');\n\n/**\n * Checks if `predicate` returns truthy for **any** element of `collection`.\n * Iteration is stopped once `predicate` returns truthy. The predicate is\n * invoked with three arguments: (value, index|key, collection).\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [predicate=_.identity] The function invoked per iteration.\n * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n * @returns {boolean} Returns `true` if any element passes the predicate check,\n *  else `false`.\n * @example\n *\n * _.some([null, 0, 'yes', false], Boolean);\n * // => true\n *\n * var users = [\n *   { 'user': 'barney', 'active': true },\n *   { 'user': 'fred',   'active': false }\n * ];\n *\n * // The `_.matches` iteratee shorthand.\n * _.some(users, { 'user': 'barney', 'active': false });\n * // => false\n *\n * // The `_.matchesProperty` iteratee shorthand.\n * _.some(users, ['active', false]);\n * // => true\n *\n * // The `_.property` iteratee shorthand.\n * _.some(users, 'active');\n * // => true\n */\nfunction some(collection, predicate, guard) {\n  var func = isArray(collection) ? arraySome : baseSome;\n  if (guard && isIterateeCall(collection, predicate, guard)) {\n    predicate = undefined;\n  }\n  return func(collection, baseIteratee(predicate, 3));\n}\n\nmodule.exports = some;\n", "/**\n * A specialized version of `_.every` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {boolean} Returns `true` if all elements pass the predicate check,\n *  else `false`.\n */\nfunction arrayEvery(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (!predicate(array[index], index, array)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nmodule.exports = arrayEvery;\n", "var baseEach = require('./_baseEach');\n\n/**\n * The base implementation of `_.every` without support for iteratee shorthands.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {boolean} Returns `true` if all elements pass the predicate check,\n *  else `false`\n */\nfunction baseEvery(collection, predicate) {\n  var result = true;\n  baseEach(collection, function(value, index, collection) {\n    result = !!predicate(value, index, collection);\n    return result;\n  });\n  return result;\n}\n\nmodule.exports = baseEvery;\n", "var arrayEvery = require('./_arrayEvery'),\n    baseEvery = require('./_baseEvery'),\n    baseIteratee = require('./_baseIteratee'),\n    isArray = require('./isArray'),\n    isIterateeCall = require('./_isIterateeCall');\n\n/**\n * Checks if `predicate` returns truthy for **all** elements of `collection`.\n * Iteration is stopped once `predicate` returns falsey. The predicate is\n * invoked with three arguments: (value, index|key, collection).\n *\n * **Note:** This method returns `true` for\n * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because\n * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of\n * elements of empty collections.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [predicate=_.identity] The function invoked per iteration.\n * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n * @returns {boolean} Returns `true` if all elements pass the predicate check,\n *  else `false`.\n * @example\n *\n * _.every([true, 1, null, 'yes'], Boolean);\n * // => false\n *\n * var users = [\n *   { 'user': 'barney', 'age': 36, 'active': false },\n *   { 'user': 'fred',   'age': 40, 'active': false }\n * ];\n *\n * // The `_.matches` iteratee shorthand.\n * _.every(users, { 'user': 'barney', 'active': false });\n * // => false\n *\n * // The `_.matchesProperty` iteratee shorthand.\n * _.every(users, ['active', false]);\n * // => true\n *\n * // The `_.property` iteratee shorthand.\n * _.every(users, 'active');\n * // => false\n */\nfunction every(collection, predicate, guard) {\n  var func = isArray(collection) ? arrayEvery : baseEvery;\n  if (guard && isIterateeCall(collection, predicate, guard)) {\n    predicate = undefined;\n  }\n  return func(collection, baseIteratee(predicate, 3));\n}\n\nmodule.exports = every;\n", "/**\n * The base implementation of `_.findIndex` and `_.findLastIndex` without\n * support for iteratee shorthands.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {Function} predicate The function invoked per iteration.\n * @param {number} fromIndex The index to search from.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction baseFindIndex(array, predicate, fromIndex, fromRight) {\n  var length = array.length,\n      index = fromIndex + (fromRight ? 1 : -1);\n\n  while ((fromRight ? index-- : ++index < length)) {\n    if (predicate(array[index], index, array)) {\n      return index;\n    }\n  }\n  return -1;\n}\n\nmodule.exports = baseFindIndex;\n", "/**\n * The base implementation of `_.isNaN` without support for number objects.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.\n */\nfunction baseIsNaN(value) {\n  return value !== value;\n}\n\nmodule.exports = baseIsNaN;\n", "/**\n * A specialized version of `_.indexOf` which performs strict equality\n * comparisons of values, i.e. `===`.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} value The value to search for.\n * @param {number} fromIndex The index to search from.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction strictIndexOf(array, value, fromIndex) {\n  var index = fromIndex - 1,\n      length = array.length;\n\n  while (++index < length) {\n    if (array[index] === value) {\n      return index;\n    }\n  }\n  return -1;\n}\n\nmodule.exports = strictIndexOf;\n", "var baseFindIndex = require('./_baseFindIndex'),\n    baseIsNaN = require('./_baseIsNaN'),\n    strictIndexOf = require('./_strictIndexOf');\n\n/**\n * The base implementation of `_.indexOf` without `fromIndex` bounds checks.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} value The value to search for.\n * @param {number} fromIndex The index to search from.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction baseIndexOf(array, value, fromIndex) {\n  return value === value\n    ? strictIndexOf(array, value, fromIndex)\n    : baseFindIndex(array, baseIsNaN, fromIndex);\n}\n\nmodule.exports = baseIndexOf;\n", "var baseIndexOf = require('./_baseIndexOf'),\n    isArrayLike = require('./isArrayLike'),\n    isString = require('./isString'),\n    toInteger = require('./toInteger'),\n    values = require('./values');\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max;\n\n/**\n * Checks if `value` is in `collection`. If `collection` is a string, it's\n * checked for a substring of `value`, otherwise\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * is used for equality comparisons. If `fromIndex` is negative, it's used as\n * the offset from the end of `collection`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object|string} collection The collection to inspect.\n * @param {*} value The value to search for.\n * @param {number} [fromIndex=0] The index to search from.\n * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.\n * @returns {boolean} Returns `true` if `value` is found, else `false`.\n * @example\n *\n * _.includes([1, 2, 3], 1);\n * // => true\n *\n * _.includes([1, 2, 3], 1, 2);\n * // => false\n *\n * _.includes({ 'a': 1, 'b': 2 }, 1);\n * // => true\n *\n * _.includes('abcd', 'bc');\n * // => true\n */\nfunction includes(collection, value, fromIndex, guard) {\n  collection = isArrayLike(collection) ? collection : values(collection);\n  fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;\n\n  var length = collection.length;\n  if (fromIndex < 0) {\n    fromIndex = nativeMax(length + fromIndex, 0);\n  }\n  return isString(collection)\n    ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)\n    : (!!length && baseIndexOf(collection, value, fromIndex) > -1);\n}\n\nmodule.exports = includes;\n", "import some from \"lodash/some\"\nimport every from \"lodash/every\"\nimport has from \"lodash/has\"\nimport includes from \"lodash/includes\"\nimport {\n  AbstractProduction,\n  Alternation,\n  Alternative,\n  NonTerminal,\n  Option,\n  Repetition,\n  RepetitionMandatory,\n  RepetitionMandatoryWithSeparator,\n  RepetitionWithSeparator,\n  Rule,\n  Terminal\n} from \"./model\"\nimport { GAstVisitor } from \"./visitor\"\nimport { IProduction, IProductionWithOccurrence } from \"@chevrotain/types\"\n\nexport function isSequenceProd(\n  prod: IProduction\n): prod is { definition: IProduction[] } & IProduction {\n  return (\n    prod instanceof Alternative ||\n    prod instanceof Option ||\n    prod instanceof Repetition ||\n    prod instanceof RepetitionMandatory ||\n    prod instanceof RepetitionMandatoryWithSeparator ||\n    prod instanceof RepetitionWithSeparator ||\n    prod instanceof Terminal ||\n    prod instanceof Rule\n  )\n}\n\nexport function isOptionalProd(\n  prod: IProduction,\n  alreadyVisited: NonTerminal[] = []\n): boolean {\n  const isDirectlyOptional =\n    prod instanceof Option ||\n    prod instanceof Repetition ||\n    prod instanceof RepetitionWithSeparator\n  if (isDirectlyOptional) {\n    return true\n  }\n\n  // note that this can cause infinite loop if one optional empty TOP production has a cyclic dependency with another\n  // empty optional top rule\n  // may be indirectly optional ((A?B?C?) | (D?E?F?))\n  if (prod instanceof Alternation) {\n    // for OR its enough for just one of the alternatives to be optional\n    return some((<Alternation>prod).definition, (subProd: IProduction) => {\n      return isOptionalProd(subProd, alreadyVisited)\n    })\n  } else if (prod instanceof NonTerminal && includes(alreadyVisited, prod)) {\n    // avoiding stack overflow due to infinite recursion\n    return false\n  } else if (prod instanceof AbstractProduction) {\n    if (prod instanceof NonTerminal) {\n      alreadyVisited.push(prod)\n    }\n    return every(\n      (<AbstractProduction>prod).definition,\n      (subProd: IProduction) => {\n        return isOptionalProd(subProd, alreadyVisited)\n      }\n    )\n  } else {\n    return false\n  }\n}\n\nexport function isBranchingProd(\n  prod: IProduction\n): prod is { definition: IProduction[] } & IProduction {\n  return prod instanceof Alternation\n}\n\nexport function getProductionDslName(prod: IProductionWithOccurrence): string {\n  /* istanbul ignore else */\n  if (prod instanceof NonTerminal) {\n    return \"SUBRULE\"\n  } else if (prod instanceof Option) {\n    return \"OPTION\"\n  } else if (prod instanceof Alternation) {\n    return \"OR\"\n  } else if (prod instanceof RepetitionMandatory) {\n    return \"AT_LEAST_ONE\"\n  } else if (prod instanceof RepetitionMandatoryWithSeparator) {\n    return \"AT_LEAST_ONE_SEP\"\n  } else if (prod instanceof RepetitionWithSeparator) {\n    return \"MANY_SEP\"\n  } else if (prod instanceof Repetition) {\n    return \"MANY\"\n  } else if (prod instanceof Terminal) {\n    return \"CONSUME\"\n  } else {\n    throw Error(\"non exhaustive match\")\n  }\n}\n", "export {\n  Rule,\n  Terminal,\n  NonTerminal,\n  Option,\n  Repetition,\n  RepetitionMandatory,\n  RepetitionMandatoryWithSeparator,\n  RepetitionWithSeparator,\n  Alternation,\n  Alternative,\n  serializeGrammar,\n  serializeProduction\n} from \"./model\"\n\nexport { GAstVisitor } from \"./visitor\"\n\nexport {\n  getProductionDslName,\n  isOptionalProd,\n  isBranchingProd,\n  isSequenceProd\n} from \"./helpers\"\n", "import drop from \"lodash/drop\"\nimport forEach from \"lodash/forEach\"\nimport {\n  Alternation,\n  Alternative,\n  NonTerminal,\n  Option,\n  Repetition,\n  RepetitionMandatory,\n  RepetitionMandatoryWithSeparator,\n  RepetitionWithSeparator,\n  Terminal\n} from \"@chevrotain/gast\"\nimport { IProduction } from \"@chevrotain/types\"\n\n/**\n *  A Grammar Walker that computes the \"remaining\" grammar \"after\" a productions in the grammar.\n */\nexport abstract class RestWalker {\n  walk(prod: { definition: IProduction[] }, prevRest: any[] = []): void {\n    forEach(prod.definition, (subProd: IProduction, index) => {\n      const currRest = drop(prod.definition, index + 1)\n      /* istanbul ignore else */\n      if (subProd instanceof NonTerminal) {\n        this.walkProdRef(subProd, currRest, prevRest)\n      } else if (subProd instanceof Terminal) {\n        this.walkTerminal(subProd, currRest, prevRest)\n      } else if (subProd instanceof Alternative) {\n        this.walkFlat(subProd, currRest, prevRest)\n      } else if (subProd instanceof Option) {\n        this.walkOption(subProd, currRest, prevRest)\n      } else if (subProd instanceof RepetitionMandatory) {\n        this.walkAtLeastOne(subProd, currRest, prevRest)\n      } else if (subProd instanceof RepetitionMandatoryWithSeparator) {\n        this.walkAtLeastOneSep(subProd, currRest, prevRest)\n      } else if (subProd instanceof RepetitionWithSeparator) {\n        this.walkManySep(subProd, currRest, prevRest)\n      } else if (subProd instanceof Repetition) {\n        this.walkMany(subProd, currRest, prevRest)\n      } else if (subProd instanceof Alternation) {\n        this.walkOr(subProd, currRest, prevRest)\n      } else {\n        throw Error(\"non exhaustive match\")\n      }\n    })\n  }\n\n  walkTerminal(\n    terminal: Terminal,\n    currRest: IProduction[],\n    prevRest: IProduction[]\n  ): void {}\n\n  walkProdRef(\n    refProd: NonTerminal,\n    currRest: IProduction[],\n    prevRest: IProduction[]\n  ): void {}\n\n  walkFlat(\n    flatProd: Alternative,\n    currRest: IProduction[],\n    prevRest: IProduction[]\n  ): void {\n    // ABCDEF => after the D the rest is EF\n    const fullOrRest = currRest.concat(prevRest)\n    this.walk(flatProd, <any>fullOrRest)\n  }\n\n  walkOption(\n    optionProd: Option,\n    currRest: IProduction[],\n    prevRest: IProduction[]\n  ): void {\n    // ABC(DE)?F => after the (DE)? the rest is F\n    const fullOrRest = currRest.concat(prevRest)\n    this.walk(optionProd, <any>fullOrRest)\n  }\n\n  walkAtLeastOne(\n    atLeastOneProd: RepetitionMandatory,\n    currRest: IProduction[],\n    prevRest: IProduction[]\n  ): void {\n    // ABC(DE)+F => after the (DE)+ the rest is (DE)?F\n    const fullAtLeastOneRest: IProduction[] = [\n      new Option({ definition: atLeastOneProd.definition })\n    ].concat(<any>currRest, <any>prevRest)\n    this.walk(atLeastOneProd, fullAtLeastOneRest)\n  }\n\n  walkAtLeastOneSep(\n    atLeastOneSepProd: RepetitionMandatoryWithSeparator,\n    currRest: IProduction[],\n    prevRest: IProduction[]\n  ): void {\n    // ABC DE(,DE)* F => after the (,DE)+ the rest is (,DE)?F\n    const fullAtLeastOneSepRest = restForRepetitionWithSeparator(\n      atLeastOneSepProd,\n      currRest,\n      prevRest\n    )\n    this.walk(atLeastOneSepProd, fullAtLeastOneSepRest)\n  }\n\n  walkMany(\n    manyProd: Repetition,\n    currRest: IProduction[],\n    prevRest: IProduction[]\n  ): void {\n    // ABC(DE)*F => after the (DE)* the rest is (DE)?F\n    const fullManyRest: IProduction[] = [\n      new Option({ definition: manyProd.definition })\n    ].concat(<any>currRest, <any>prevRest)\n    this.walk(manyProd, fullManyRest)\n  }\n\n  walkManySep(\n    manySepProd: RepetitionWithSeparator,\n    currRest: IProduction[],\n    prevRest: IProduction[]\n  ): void {\n    // ABC (DE(,DE)*)? F => after the (,DE)* the rest is (,DE)?F\n    const fullManySepRest = restForRepetitionWithSeparator(\n      manySepProd,\n      currRest,\n      prevRest\n    )\n    this.walk(manySepProd, fullManySepRest)\n  }\n\n  walkOr(\n    orProd: Alternation,\n    currRest: IProduction[],\n    prevRest: IProduction[]\n  ): void {\n    // ABC(D|E|F)G => when finding the (D|E|F) the rest is G\n    const fullOrRest = currRest.concat(prevRest)\n    // walk all different alternatives\n    forEach(orProd.definition, (alt) => {\n      // wrapping each alternative in a single definition wrapper\n      // to avoid errors in computing the rest of that alternative in the invocation to computeInProdFollows\n      // (otherwise for OR([alt1,alt2]) alt2 will be considered in 'rest' of alt1\n      const prodWrapper = new Alternative({ definition: [alt] })\n      this.walk(prodWrapper, <any>fullOrRest)\n    })\n  }\n}\n\nfunction restForRepetitionWithSeparator(\n  repSepProd: RepetitionWithSeparator,\n  currRest: IProduction[],\n  prevRest: IProduction[]\n) {\n  const repSepRest = [\n    new Option({\n      definition: [\n        new Terminal({ terminalType: repSepProd.separator }) as IProduction\n      ].concat(repSepProd.definition)\n    }) as IProduction\n  ]\n  const fullRepSepRest: IProduction[] = repSepRest.concat(currRest, prevRest)\n  return fullRepSepRest\n}\n", "var Symbol = require('./_Symbol'),\n    isArguments = require('./isArguments'),\n    isArray = require('./isArray');\n\n/** Built-in value references. */\nvar spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;\n\n/**\n * Checks if `value` is a flattenable `arguments` object or array.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.\n */\nfunction isFlattenable(value) {\n  return isArray(value) || isArguments(value) ||\n    !!(spreadableSymbol && value && value[spreadableSymbol]);\n}\n\nmodule.exports = isFlattenable;\n", "var arrayPush = require('./_arrayPush'),\n    isFlattenable = require('./_isFlattenable');\n\n/**\n * The base implementation of `_.flatten` with support for restricting flattening.\n *\n * @private\n * @param {Array} array The array to flatten.\n * @param {number} depth The maximum recursion depth.\n * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.\n * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.\n * @param {Array} [result=[]] The initial result value.\n * @returns {Array} Returns the new flattened array.\n */\nfunction baseFlatten(array, depth, predicate, isStrict, result) {\n  var index = -1,\n      length = array.length;\n\n  predicate || (predicate = isFlattenable);\n  result || (result = []);\n\n  while (++index < length) {\n    var value = array[index];\n    if (depth > 0 && predicate(value)) {\n      if (depth > 1) {\n        // Recursively flatten arrays (susceptible to call stack limits).\n        baseFlatten(value, depth - 1, predicate, isStrict, result);\n      } else {\n        arrayPush(result, value);\n      }\n    } else if (!isStrict) {\n      result[result.length] = value;\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseFlatten;\n", "var baseFlatten = require('./_baseFlatten');\n\n/**\n * Flattens `array` a single level deep.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {Array} array The array to flatten.\n * @returns {Array} Returns the new flattened array.\n * @example\n *\n * _.flatten([1, [2, [3, [4]], 5]]);\n * // => [1, 2, [3, [4]], 5]\n */\nfunction flatten(array) {\n  var length = array == null ? 0 : array.length;\n  return length ? baseFlatten(array, 1) : [];\n}\n\nmodule.exports = flatten;\n", "var baseIndexOf = require('./_baseIndexOf');\n\n/**\n * A specialized version of `_.includes` for arrays without support for\n * specifying an index to search from.\n *\n * @private\n * @param {Array} [array] The array to inspect.\n * @param {*} target The value to search for.\n * @returns {boolean} Returns `true` if `target` is found, else `false`.\n */\nfunction arrayIncludes(array, value) {\n  var length = array == null ? 0 : array.length;\n  return !!length && baseIndexOf(array, value, 0) > -1;\n}\n\nmodule.exports = arrayIncludes;\n", "/**\n * This function is like `arrayIncludes` except that it accepts a comparator.\n *\n * @private\n * @param {Array} [array] The array to inspect.\n * @param {*} target The value to search for.\n * @param {Function} comparator The comparator invoked per element.\n * @returns {boolean} Returns `true` if `target` is found, else `false`.\n */\nfunction arrayIncludesWith(array, value, comparator) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (comparator(value, array[index])) {\n      return true;\n    }\n  }\n  return false;\n}\n\nmodule.exports = arrayIncludesWith;\n", "/**\n * This method returns `undefined`.\n *\n * @static\n * @memberOf _\n * @since 2.3.0\n * @category Util\n * @example\n *\n * _.times(2, _.noop);\n * // => [undefined, undefined]\n */\nfunction noop() {\n  // No operation performed.\n}\n\nmodule.exports = noop;\n", "var Set = require('./_Set'),\n    noop = require('./noop'),\n    setToArray = require('./_setToArray');\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/**\n * Creates a set object of `values`.\n *\n * @private\n * @param {Array} values The values to add to the set.\n * @returns {Object} Returns the new set.\n */\nvar createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {\n  return new Set(values);\n};\n\nmodule.exports = createSet;\n", "var SetCache = require('./_SetCache'),\n    arrayIncludes = require('./_arrayIncludes'),\n    arrayIncludesWith = require('./_arrayIncludesWith'),\n    cacheHas = require('./_cacheHas'),\n    createSet = require('./_createSet'),\n    setToArray = require('./_setToArray');\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/**\n * The base implementation of `_.uniqBy` without support for iteratee shorthands.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {Function} [iteratee] The iteratee invoked per element.\n * @param {Function} [comparator] The comparator invoked per element.\n * @returns {Array} Returns the new duplicate free array.\n */\nfunction baseUniq(array, iteratee, comparator) {\n  var index = -1,\n      includes = arrayIncludes,\n      length = array.length,\n      isCommon = true,\n      result = [],\n      seen = result;\n\n  if (comparator) {\n    isCommon = false;\n    includes = arrayIncludesWith;\n  }\n  else if (length >= LARGE_ARRAY_SIZE) {\n    var set = iteratee ? null : createSet(array);\n    if (set) {\n      return setToArray(set);\n    }\n    isCommon = false;\n    includes = cacheHas;\n    seen = new SetCache;\n  }\n  else {\n    seen = iteratee ? [] : result;\n  }\n  outer:\n  while (++index < length) {\n    var value = array[index],\n        computed = iteratee ? iteratee(value) : value;\n\n    value = (comparator || value !== 0) ? value : 0;\n    if (isCommon && computed === computed) {\n      var seenIndex = seen.length;\n      while (seenIndex--) {\n        if (seen[seenIndex] === computed) {\n          continue outer;\n        }\n      }\n      if (iteratee) {\n        seen.push(computed);\n      }\n      result.push(value);\n    }\n    else if (!includes(seen, computed, comparator)) {\n      if (seen !== result) {\n        seen.push(computed);\n      }\n      result.push(value);\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseUniq;\n", "var baseUniq = require('./_baseUniq');\n\n/**\n * Creates a duplicate-free version of an array, using\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * for equality comparisons, in which only the first occurrence of each element\n * is kept. The order of result values is determined by the order they occur\n * in the array.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {Array} array The array to inspect.\n * @returns {Array} Returns the new duplicate free array.\n * @example\n *\n * _.uniq([2, 1, 2]);\n * // => [2, 1]\n */\nfunction uniq(array) {\n  return (array && array.length) ? baseUniq(array) : [];\n}\n\nmodule.exports = uniq;\n", "import flatten from \"lodash/flatten\"\nimport uniq from \"lodash/uniq\"\nimport map from \"lodash/map\"\nimport { NonTerminal, Terminal } from \"@chevrotain/gast\"\nimport {\n  isBranchingProd,\n  isOptionalProd,\n  isSequenceProd\n} from \"@chevrotain/gast\"\nimport { IProduction, TokenType } from \"@chevrotain/types\"\n\nexport function first(prod: IProduction): TokenType[] {\n  /* istanbul ignore else */\n  if (prod instanceof NonTerminal) {\n    // this could in theory cause infinite loops if\n    // (1) prod A refs prod B.\n    // (2) prod B refs prod A\n    // (3) AB can match the empty set\n    // in other words a cycle where everything is optional so the first will keep\n    // looking ahead for the next optional part and will never exit\n    // currently there is no safeguard for this unique edge case because\n    // (1) not sure a grammar in which this can happen is useful for anything (productive)\n    return first((<NonTerminal>prod).referencedRule)\n  } else if (prod instanceof Terminal) {\n    return firstForTerminal(<Terminal>prod)\n  } else if (isSequenceProd(prod)) {\n    return firstForSequence(prod)\n  } else if (isBranchingProd(prod)) {\n    return firstForBranching(prod)\n  } else {\n    throw Error(\"non exhaustive match\")\n  }\n}\n\nexport function firstForSequence(prod: {\n  definition: IProduction[]\n}): TokenType[] {\n  let firstSet: TokenType[] = []\n  const seq = prod.definition\n  let nextSubProdIdx = 0\n  let hasInnerProdsRemaining = seq.length > nextSubProdIdx\n  let currSubProd\n  // so we enter the loop at least once (if the definition is not empty\n  let isLastInnerProdOptional = true\n  // scan a sequence until it's end or until we have found a NONE optional production in it\n  while (hasInnerProdsRemaining && isLastInnerProdOptional) {\n    currSubProd = seq[nextSubProdIdx]\n    isLastInnerProdOptional = isOptionalProd(currSubProd)\n    firstSet = firstSet.concat(first(currSubProd))\n    nextSubProdIdx = nextSubProdIdx + 1\n    hasInnerProdsRemaining = seq.length > nextSubProdIdx\n  }\n\n  return uniq(firstSet)\n}\n\nexport function firstForBranching(prod: {\n  definition: IProduction[]\n}): TokenType[] {\n  const allAlternativesFirsts: TokenType[][] = map(\n    prod.definition,\n    (innerProd) => {\n      return first(innerProd)\n    }\n  )\n  return uniq(flatten<TokenType>(allAlternativesFirsts))\n}\n\nexport function firstForTerminal(terminal: Terminal): TokenType[] {\n  return [terminal.terminalType]\n}\n", "// TODO: can this be removed? where is it used?\nexport const IN = \"_~IN~_\"\n", "import { RestWalker } from \"./rest\"\nimport { first } from \"./first\"\nimport forEach from \"lodash/forEach\"\nimport assign from \"lodash/assign\"\nimport { IN } from \"../constants\"\nimport { Alternative, NonTerminal, Rule, Terminal } from \"@chevrotain/gast\"\nimport { IProduction, TokenType } from \"@chevrotain/types\"\n\n// This ResyncFollowsWalker computes all of the follows required for RESYNC\n// (skipping reference production).\nexport class ResyncFollowsWalker extends RestWalker {\n  public follows: Record<string, TokenType[]> = {}\n\n  constructor(private topProd: Rule) {\n    super()\n  }\n\n  startWalking(): Record<string, TokenType[]> {\n    this.walk(this.topProd)\n    return this.follows\n  }\n\n  walkTerminal(\n    terminal: Terminal,\n    currRest: IProduction[],\n    prevRest: IProduction[]\n  ): void {\n    // do nothing! just like in the public sector after 13:00\n  }\n\n  walkProdRef(\n    refProd: NonTerminal,\n    currRest: IProduction[],\n    prevRest: IProduction[]\n  ): void {\n    const followName =\n      buildBetweenProdsFollowPrefix(refProd.referencedRule, refProd.idx) +\n      this.topProd.name\n    const fullRest: IProduction[] = currRest.concat(prevRest)\n    const restProd = new Alternative({ definition: fullRest })\n    const t_in_topProd_follows = first(restProd)\n    this.follows[followName] = t_in_topProd_follows\n  }\n}\n\nexport function computeAllProdsFollows(\n  topProductions: Rule[]\n): Record<string, TokenType[]> {\n  const reSyncFollows = {}\n\n  forEach(topProductions, (topProd) => {\n    const currRefsFollow = new ResyncFollowsWalker(topProd).startWalking()\n    assign(reSyncFollows, currRefsFollow)\n  })\n  return reSyncFollows\n}\n\nexport function buildBetweenProdsFollowPrefix(\n  inner: Rule,\n  occurenceInParent: number\n): string {\n  return inner.name + occurenceInParent + IN\n}\n\nexport function buildInProdFollowPrefix(terminal: Terminal): string {\n  const terminalName = terminal.terminalType.name\n  return terminalName + terminal.idx + IN\n}\n", "/**\n * Checks if `value` is `undefined`.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.\n * @example\n *\n * _.isUndefined(void 0);\n * // => true\n *\n * _.isUndefined(null);\n * // => false\n */\nfunction isUndefined(value) {\n  return value === undefined;\n}\n\nmodule.exports = isUndefined;\n", ";(function(root, factory) {\n    // istanbul ignore next\n    if (typeof define === \"function\" && define.amd) {\n        // istanbul ignore next\n        define([], factory)\n    } else if (typeof module === \"object\" && module.exports) {\n        module.exports = factory()\n    } else {\n        // istanbul ignore next\n        root.regexpToAst = factory()\n    }\n})(\n    typeof self !== \"undefined\"\n        ? // istanbul ignore next\n          self\n        : this,\n    function() {\n        // references\n        // https://hackernoon.com/the-madness-of-parsing-real-world-javascript-regexps-d9ee336df983\n        // https://www.ecma-international.org/ecma-262/8.0/index.html#prod-Pattern\n        function RegExpParser() {}\n\n        RegExpParser.prototype.saveState = function() {\n            return {\n                idx: this.idx,\n                input: this.input,\n                groupIdx: this.groupIdx\n            }\n        }\n\n        RegExpParser.prototype.restoreState = function(newState) {\n            this.idx = newState.idx\n            this.input = newState.input\n            this.groupIdx = newState.groupIdx\n        }\n\n        RegExpParser.prototype.pattern = function(input) {\n            // parser state\n            this.idx = 0\n            this.input = input\n            this.groupIdx = 0\n\n            this.consumeChar(\"/\")\n            var value = this.disjunction()\n            this.consumeChar(\"/\")\n\n            var flags = {\n                type: \"Flags\",\n                loc: { begin: this.idx, end: input.length },\n                global: false,\n                ignoreCase: false,\n                multiLine: false,\n                unicode: false,\n                sticky: false\n            }\n\n            while (this.isRegExpFlag()) {\n                switch (this.popChar()) {\n                    case \"g\":\n                        addFlag(flags, \"global\")\n                        break\n                    case \"i\":\n                        addFlag(flags, \"ignoreCase\")\n                        break\n                    case \"m\":\n                        addFlag(flags, \"multiLine\")\n                        break\n                    case \"u\":\n                        addFlag(flags, \"unicode\")\n                        break\n                    case \"y\":\n                        addFlag(flags, \"sticky\")\n                        break\n                }\n            }\n\n            if (this.idx !== this.input.length) {\n                throw Error(\n                    \"Redundant input: \" + this.input.substring(this.idx)\n                )\n            }\n            return {\n                type: \"Pattern\",\n                flags: flags,\n                value: value,\n                loc: this.loc(0)\n            }\n        }\n\n        RegExpParser.prototype.disjunction = function() {\n            var alts = []\n            var begin = this.idx\n\n            alts.push(this.alternative())\n\n            while (this.peekChar() === \"|\") {\n                this.consumeChar(\"|\")\n                alts.push(this.alternative())\n            }\n\n            return { type: \"Disjunction\", value: alts, loc: this.loc(begin) }\n        }\n\n        RegExpParser.prototype.alternative = function() {\n            var terms = []\n            var begin = this.idx\n\n            while (this.isTerm()) {\n                terms.push(this.term())\n            }\n\n            return { type: \"Alternative\", value: terms, loc: this.loc(begin) }\n        }\n\n        RegExpParser.prototype.term = function() {\n            if (this.isAssertion()) {\n                return this.assertion()\n            } else {\n                return this.atom()\n            }\n        }\n\n        RegExpParser.prototype.assertion = function() {\n            var begin = this.idx\n            switch (this.popChar()) {\n                case \"^\":\n                    return {\n                        type: \"StartAnchor\",\n                        loc: this.loc(begin)\n                    }\n                case \"$\":\n                    return { type: \"EndAnchor\", loc: this.loc(begin) }\n                // '\\b' or '\\B'\n                case \"\\\\\":\n                    switch (this.popChar()) {\n                        case \"b\":\n                            return {\n                                type: \"WordBoundary\",\n                                loc: this.loc(begin)\n                            }\n                        case \"B\":\n                            return {\n                                type: \"NonWordBoundary\",\n                                loc: this.loc(begin)\n                            }\n                    }\n                    // istanbul ignore next\n                    throw Error(\"Invalid Assertion Escape\")\n                // '(?=' or '(?!'\n                case \"(\":\n                    this.consumeChar(\"?\")\n\n                    var type\n                    switch (this.popChar()) {\n                        case \"=\":\n                            type = \"Lookahead\"\n                            break\n                        case \"!\":\n                            type = \"NegativeLookahead\"\n                            break\n                    }\n                    ASSERT_EXISTS(type)\n\n                    var disjunction = this.disjunction()\n\n                    this.consumeChar(\")\")\n\n                    return {\n                        type: type,\n                        value: disjunction,\n                        loc: this.loc(begin)\n                    }\n            }\n            // istanbul ignore next\n            ASSERT_NEVER_REACH_HERE()\n        }\n\n        RegExpParser.prototype.quantifier = function(isBacktracking) {\n            var range\n            var begin = this.idx\n            switch (this.popChar()) {\n                case \"*\":\n                    range = {\n                        atLeast: 0,\n                        atMost: Infinity\n                    }\n                    break\n                case \"+\":\n                    range = {\n                        atLeast: 1,\n                        atMost: Infinity\n                    }\n                    break\n                case \"?\":\n                    range = {\n                        atLeast: 0,\n                        atMost: 1\n                    }\n                    break\n                case \"{\":\n                    var atLeast = this.integerIncludingZero()\n                    switch (this.popChar()) {\n                        case \"}\":\n                            range = {\n                                atLeast: atLeast,\n                                atMost: atLeast\n                            }\n                            break\n                        case \",\":\n                            var atMost\n                            if (this.isDigit()) {\n                                atMost = this.integerIncludingZero()\n                                range = {\n                                    atLeast: atLeast,\n                                    atMost: atMost\n                                }\n                            } else {\n                                range = {\n                                    atLeast: atLeast,\n                                    atMost: Infinity\n                                }\n                            }\n                            this.consumeChar(\"}\")\n                            break\n                    }\n                    // throwing exceptions from \"ASSERT_EXISTS\" during backtracking\n                    // causes severe performance degradations\n                    if (isBacktracking === true && range === undefined) {\n                        return undefined\n                    }\n                    ASSERT_EXISTS(range)\n                    break\n            }\n\n            // throwing exceptions from \"ASSERT_EXISTS\" during backtracking\n            // causes severe performance degradations\n            if (isBacktracking === true && range === undefined) {\n                return undefined\n            }\n\n            ASSERT_EXISTS(range)\n\n            if (this.peekChar(0) === \"?\") {\n                this.consumeChar(\"?\")\n                range.greedy = false\n            } else {\n                range.greedy = true\n            }\n\n            range.type = \"Quantifier\"\n            range.loc = this.loc(begin)\n            return range\n        }\n\n        RegExpParser.prototype.atom = function() {\n            var atom\n            var begin = this.idx\n            switch (this.peekChar()) {\n                case \".\":\n                    atom = this.dotAll()\n                    break\n                case \"\\\\\":\n                    atom = this.atomEscape()\n                    break\n                case \"[\":\n                    atom = this.characterClass()\n                    break\n                case \"(\":\n                    atom = this.group()\n                    break\n            }\n\n            if (atom === undefined && this.isPatternCharacter()) {\n                atom = this.patternCharacter()\n            }\n\n            ASSERT_EXISTS(atom)\n\n            atom.loc = this.loc(begin)\n\n            if (this.isQuantifier()) {\n                atom.quantifier = this.quantifier()\n            }\n\n            return atom\n        }\n\n        RegExpParser.prototype.dotAll = function() {\n            this.consumeChar(\".\")\n            return {\n                type: \"Set\",\n                complement: true,\n                value: [cc(\"\\n\"), cc(\"\\r\"), cc(\"\\u2028\"), cc(\"\\u2029\")]\n            }\n        }\n\n        RegExpParser.prototype.atomEscape = function() {\n            this.consumeChar(\"\\\\\")\n\n            switch (this.peekChar()) {\n                case \"1\":\n                case \"2\":\n                case \"3\":\n                case \"4\":\n                case \"5\":\n                case \"6\":\n                case \"7\":\n                case \"8\":\n                case \"9\":\n                    return this.decimalEscapeAtom()\n                case \"d\":\n                case \"D\":\n                case \"s\":\n                case \"S\":\n                case \"w\":\n                case \"W\":\n                    return this.characterClassEscape()\n                case \"f\":\n                case \"n\":\n                case \"r\":\n                case \"t\":\n                case \"v\":\n                    return this.controlEscapeAtom()\n                case \"c\":\n                    return this.controlLetterEscapeAtom()\n                case \"0\":\n                    return this.nulCharacterAtom()\n                case \"x\":\n                    return this.hexEscapeSequenceAtom()\n                case \"u\":\n                    return this.regExpUnicodeEscapeSequenceAtom()\n                default:\n                    return this.identityEscapeAtom()\n            }\n        }\n\n        RegExpParser.prototype.decimalEscapeAtom = function() {\n            var value = this.positiveInteger()\n\n            return { type: \"GroupBackReference\", value: value }\n        }\n\n        RegExpParser.prototype.characterClassEscape = function() {\n            var set\n            var complement = false\n            switch (this.popChar()) {\n                case \"d\":\n                    set = digitsCharCodes\n                    break\n                case \"D\":\n                    set = digitsCharCodes\n                    complement = true\n                    break\n                case \"s\":\n                    set = whitespaceCodes\n                    break\n                case \"S\":\n                    set = whitespaceCodes\n                    complement = true\n                    break\n                case \"w\":\n                    set = wordCharCodes\n                    break\n                case \"W\":\n                    set = wordCharCodes\n                    complement = true\n                    break\n            }\n\n            ASSERT_EXISTS(set)\n\n            return { type: \"Set\", value: set, complement: complement }\n        }\n\n        RegExpParser.prototype.controlEscapeAtom = function() {\n            var escapeCode\n            switch (this.popChar()) {\n                case \"f\":\n                    escapeCode = cc(\"\\f\")\n                    break\n                case \"n\":\n                    escapeCode = cc(\"\\n\")\n                    break\n                case \"r\":\n                    escapeCode = cc(\"\\r\")\n                    break\n                case \"t\":\n                    escapeCode = cc(\"\\t\")\n                    break\n                case \"v\":\n                    escapeCode = cc(\"\\v\")\n                    break\n            }\n            ASSERT_EXISTS(escapeCode)\n\n            return { type: \"Character\", value: escapeCode }\n        }\n\n        RegExpParser.prototype.controlLetterEscapeAtom = function() {\n            this.consumeChar(\"c\")\n            var letter = this.popChar()\n            if (/[a-zA-Z]/.test(letter) === false) {\n                throw Error(\"Invalid \")\n            }\n\n            var letterCode = letter.toUpperCase().charCodeAt(0) - 64\n            return { type: \"Character\", value: letterCode }\n        }\n\n        RegExpParser.prototype.nulCharacterAtom = function() {\n            // TODO implement '[lookahead \u2209 DecimalDigit]'\n            // TODO: for the deprecated octal escape sequence\n            this.consumeChar(\"0\")\n            return { type: \"Character\", value: cc(\"\\0\") }\n        }\n\n        RegExpParser.prototype.hexEscapeSequenceAtom = function() {\n            this.consumeChar(\"x\")\n            return this.parseHexDigits(2)\n        }\n\n        RegExpParser.prototype.regExpUnicodeEscapeSequenceAtom = function() {\n            this.consumeChar(\"u\")\n            return this.parseHexDigits(4)\n        }\n\n        RegExpParser.prototype.identityEscapeAtom = function() {\n            // TODO: implement \"SourceCharacter but not UnicodeIDContinue\"\n            // // http://unicode.org/reports/tr31/#Specific_Character_Adjustments\n            var escapedChar = this.popChar()\n            return { type: \"Character\", value: cc(escapedChar) }\n        }\n\n        RegExpParser.prototype.classPatternCharacterAtom = function() {\n            switch (this.peekChar()) {\n                // istanbul ignore next\n                case \"\\n\":\n                // istanbul ignore next\n                case \"\\r\":\n                // istanbul ignore next\n                case \"\\u2028\":\n                // istanbul ignore next\n                case \"\\u2029\":\n                // istanbul ignore next\n                case \"\\\\\":\n                // istanbul ignore next\n                case \"]\":\n                    throw Error(\"TBD\")\n                default:\n                    var nextChar = this.popChar()\n                    return { type: \"Character\", value: cc(nextChar) }\n            }\n        }\n\n        RegExpParser.prototype.characterClass = function() {\n            var set = []\n            var complement = false\n            this.consumeChar(\"[\")\n            if (this.peekChar(0) === \"^\") {\n                this.consumeChar(\"^\")\n                complement = true\n            }\n\n            while (this.isClassAtom()) {\n                var from = this.classAtom()\n                var isFromSingleChar = from.type === \"Character\"\n                if (isFromSingleChar && this.isRangeDash()) {\n                    this.consumeChar(\"-\")\n                    var to = this.classAtom()\n                    var isToSingleChar = to.type === \"Character\"\n\n                    // a range can only be used when both sides are single characters\n                    if (isToSingleChar) {\n                        if (to.value < from.value) {\n                            throw Error(\"Range out of order in character class\")\n                        }\n                        set.push({ from: from.value, to: to.value })\n                    } else {\n                        // literal dash\n                        insertToSet(from.value, set)\n                        set.push(cc(\"-\"))\n                        insertToSet(to.value, set)\n                    }\n                } else {\n                    insertToSet(from.value, set)\n                }\n            }\n\n            this.consumeChar(\"]\")\n\n            return { type: \"Set\", complement: complement, value: set }\n        }\n\n        RegExpParser.prototype.classAtom = function() {\n            switch (this.peekChar()) {\n                // istanbul ignore next\n                case \"]\":\n                // istanbul ignore next\n                case \"\\n\":\n                // istanbul ignore next\n                case \"\\r\":\n                // istanbul ignore next\n                case \"\\u2028\":\n                // istanbul ignore next\n                case \"\\u2029\":\n                    throw Error(\"TBD\")\n                case \"\\\\\":\n                    return this.classEscape()\n                default:\n                    return this.classPatternCharacterAtom()\n            }\n        }\n\n        RegExpParser.prototype.classEscape = function() {\n            this.consumeChar(\"\\\\\")\n            switch (this.peekChar()) {\n                // Matches a backspace.\n                // (Not to be confused with \\b word boundary outside characterClass)\n                case \"b\":\n                    this.consumeChar(\"b\")\n                    return { type: \"Character\", value: cc(\"\\u0008\") }\n                case \"d\":\n                case \"D\":\n                case \"s\":\n                case \"S\":\n                case \"w\":\n                case \"W\":\n                    return this.characterClassEscape()\n                case \"f\":\n                case \"n\":\n                case \"r\":\n                case \"t\":\n                case \"v\":\n                    return this.controlEscapeAtom()\n                case \"c\":\n                    return this.controlLetterEscapeAtom()\n                case \"0\":\n                    return this.nulCharacterAtom()\n                case \"x\":\n                    return this.hexEscapeSequenceAtom()\n                case \"u\":\n                    return this.regExpUnicodeEscapeSequenceAtom()\n                default:\n                    return this.identityEscapeAtom()\n            }\n        }\n\n        RegExpParser.prototype.group = function() {\n            var capturing = true\n            this.consumeChar(\"(\")\n            switch (this.peekChar(0)) {\n                case \"?\":\n                    this.consumeChar(\"?\")\n                    this.consumeChar(\":\")\n                    capturing = false\n                    break\n                default:\n                    this.groupIdx++\n                    break\n            }\n            var value = this.disjunction()\n            this.consumeChar(\")\")\n\n            var groupAst = {\n                type: \"Group\",\n                capturing: capturing,\n                value: value\n            }\n\n            if (capturing) {\n                groupAst.idx = this.groupIdx\n            }\n\n            return groupAst\n        }\n\n        RegExpParser.prototype.positiveInteger = function() {\n            var number = this.popChar()\n\n            // istanbul ignore next - can't ever get here due to previous lookahead checks\n            // still implementing this error checking in case this ever changes.\n            if (decimalPatternNoZero.test(number) === false) {\n                throw Error(\"Expecting a positive integer\")\n            }\n\n            while (decimalPattern.test(this.peekChar(0))) {\n                number += this.popChar()\n            }\n\n            return parseInt(number, 10)\n        }\n\n        RegExpParser.prototype.integerIncludingZero = function() {\n            var number = this.popChar()\n            if (decimalPattern.test(number) === false) {\n                throw Error(\"Expecting an integer\")\n            }\n\n            while (decimalPattern.test(this.peekChar(0))) {\n                number += this.popChar()\n            }\n\n            return parseInt(number, 10)\n        }\n\n        RegExpParser.prototype.patternCharacter = function() {\n            var nextChar = this.popChar()\n            switch (nextChar) {\n                // istanbul ignore next\n                case \"\\n\":\n                // istanbul ignore next\n                case \"\\r\":\n                // istanbul ignore next\n                case \"\\u2028\":\n                // istanbul ignore next\n                case \"\\u2029\":\n                // istanbul ignore next\n                case \"^\":\n                // istanbul ignore next\n                case \"$\":\n                // istanbul ignore next\n                case \"\\\\\":\n                // istanbul ignore next\n                case \".\":\n                // istanbul ignore next\n                case \"*\":\n                // istanbul ignore next\n                case \"+\":\n                // istanbul ignore next\n                case \"?\":\n                // istanbul ignore next\n                case \"(\":\n                // istanbul ignore next\n                case \")\":\n                // istanbul ignore next\n                case \"[\":\n                // istanbul ignore next\n                case \"|\":\n                    // istanbul ignore next\n                    throw Error(\"TBD\")\n                default:\n                    return { type: \"Character\", value: cc(nextChar) }\n            }\n        }\n        RegExpParser.prototype.isRegExpFlag = function() {\n            switch (this.peekChar(0)) {\n                case \"g\":\n                case \"i\":\n                case \"m\":\n                case \"u\":\n                case \"y\":\n                    return true\n                default:\n                    return false\n            }\n        }\n\n        RegExpParser.prototype.isRangeDash = function() {\n            return this.peekChar() === \"-\" && this.isClassAtom(1)\n        }\n\n        RegExpParser.prototype.isDigit = function() {\n            return decimalPattern.test(this.peekChar(0))\n        }\n\n        RegExpParser.prototype.isClassAtom = function(howMuch) {\n            if (howMuch === undefined) {\n                howMuch = 0\n            }\n\n            switch (this.peekChar(howMuch)) {\n                case \"]\":\n                case \"\\n\":\n                case \"\\r\":\n                case \"\\u2028\":\n                case \"\\u2029\":\n                    return false\n                default:\n                    return true\n            }\n        }\n\n        RegExpParser.prototype.isTerm = function() {\n            return this.isAtom() || this.isAssertion()\n        }\n\n        RegExpParser.prototype.isAtom = function() {\n            if (this.isPatternCharacter()) {\n                return true\n            }\n\n            switch (this.peekChar(0)) {\n                case \".\":\n                case \"\\\\\": // atomEscape\n                case \"[\": // characterClass\n                // TODO: isAtom must be called before isAssertion - disambiguate\n                case \"(\": // group\n                    return true\n                default:\n                    return false\n            }\n        }\n\n        RegExpParser.prototype.isAssertion = function() {\n            switch (this.peekChar(0)) {\n                case \"^\":\n                case \"$\":\n                    return true\n                // '\\b' or '\\B'\n                case \"\\\\\":\n                    switch (this.peekChar(1)) {\n                        case \"b\":\n                        case \"B\":\n                            return true\n                        default:\n                            return false\n                    }\n                // '(?=' or '(?!'\n                case \"(\":\n                    return (\n                        this.peekChar(1) === \"?\" &&\n                        (this.peekChar(2) === \"=\" || this.peekChar(2) === \"!\")\n                    )\n                default:\n                    return false\n            }\n        }\n\n        RegExpParser.prototype.isQuantifier = function() {\n            var prevState = this.saveState()\n            try {\n                return this.quantifier(true) !== undefined\n            } catch (e) {\n                return false\n            } finally {\n                this.restoreState(prevState)\n            }\n        }\n\n        RegExpParser.prototype.isPatternCharacter = function() {\n            switch (this.peekChar()) {\n                case \"^\":\n                case \"$\":\n                case \"\\\\\":\n                case \".\":\n                case \"*\":\n                case \"+\":\n                case \"?\":\n                case \"(\":\n                case \")\":\n                case \"[\":\n                case \"|\":\n                case \"/\":\n                case \"\\n\":\n                case \"\\r\":\n                case \"\\u2028\":\n                case \"\\u2029\":\n                    return false\n                default:\n                    return true\n            }\n        }\n\n        RegExpParser.prototype.parseHexDigits = function(howMany) {\n            var hexString = \"\"\n            for (var i = 0; i < howMany; i++) {\n                var hexChar = this.popChar()\n                if (hexDigitPattern.test(hexChar) === false) {\n                    throw Error(\"Expecting a HexDecimal digits\")\n                }\n                hexString += hexChar\n            }\n            var charCode = parseInt(hexString, 16)\n            return { type: \"Character\", value: charCode }\n        }\n\n        RegExpParser.prototype.peekChar = function(howMuch) {\n            if (howMuch === undefined) {\n                howMuch = 0\n            }\n            return this.input[this.idx + howMuch]\n        }\n\n        RegExpParser.prototype.popChar = function() {\n            var nextChar = this.peekChar(0)\n            this.consumeChar()\n            return nextChar\n        }\n\n        RegExpParser.prototype.consumeChar = function(char) {\n            if (char !== undefined && this.input[this.idx] !== char) {\n                throw Error(\n                    \"Expected: '\" +\n                        char +\n                        \"' but found: '\" +\n                        this.input[this.idx] +\n                        \"' at offset: \" +\n                        this.idx\n                )\n            }\n\n            if (this.idx >= this.input.length) {\n                throw Error(\"Unexpected end of input\")\n            }\n            this.idx++\n        }\n\n        RegExpParser.prototype.loc = function(begin) {\n            return { begin: begin, end: this.idx }\n        }\n\n        // consts and utilities\n        var hexDigitPattern = /[0-9a-fA-F]/\n        var decimalPattern = /[0-9]/\n        var decimalPatternNoZero = /[1-9]/\n\n        function cc(char) {\n            return char.charCodeAt(0)\n        }\n\n        function insertToSet(item, set) {\n            if (item.length !== undefined) {\n                item.forEach(function(subItem) {\n                    set.push(subItem)\n                })\n            } else {\n                set.push(item)\n            }\n        }\n\n        function addFlag(flagObj, flagKey) {\n            if (flagObj[flagKey] === true) {\n                throw \"duplicate flag \" + flagKey\n            }\n\n            flagObj[flagKey] = true\n        }\n\n        function ASSERT_EXISTS(obj) {\n            // istanbul ignore next\n            if (obj === undefined) {\n                throw Error(\"Internal Error - Should never get here!\")\n            }\n        }\n\n        // istanbul ignore next\n        function ASSERT_NEVER_REACH_HERE() {\n            throw Error(\"Internal Error - Should never get here!\")\n        }\n\n        var i\n        var digitsCharCodes = []\n        for (i = cc(\"0\"); i <= cc(\"9\"); i++) {\n            digitsCharCodes.push(i)\n        }\n\n        var wordCharCodes = [cc(\"_\")].concat(digitsCharCodes)\n        for (i = cc(\"a\"); i <= cc(\"z\"); i++) {\n            wordCharCodes.push(i)\n        }\n\n        for (i = cc(\"A\"); i <= cc(\"Z\"); i++) {\n            wordCharCodes.push(i)\n        }\n\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp#character-classes\n        var whitespaceCodes = [\n            cc(\" \"),\n            cc(\"\\f\"),\n            cc(\"\\n\"),\n            cc(\"\\r\"),\n            cc(\"\\t\"),\n            cc(\"\\v\"),\n            cc(\"\\t\"),\n            cc(\"\\u00a0\"),\n            cc(\"\\u1680\"),\n            cc(\"\\u2000\"),\n            cc(\"\\u2001\"),\n            cc(\"\\u2002\"),\n            cc(\"\\u2003\"),\n            cc(\"\\u2004\"),\n            cc(\"\\u2005\"),\n            cc(\"\\u2006\"),\n            cc(\"\\u2007\"),\n            cc(\"\\u2008\"),\n            cc(\"\\u2009\"),\n            cc(\"\\u200a\"),\n            cc(\"\\u2028\"),\n            cc(\"\\u2029\"),\n            cc(\"\\u202f\"),\n            cc(\"\\u205f\"),\n            cc(\"\\u3000\"),\n            cc(\"\\ufeff\")\n        ]\n\n        function BaseRegExpVisitor() {}\n\n        BaseRegExpVisitor.prototype.visitChildren = function(node) {\n            for (var key in node) {\n                var child = node[key]\n                /* istanbul ignore else */\n                if (node.hasOwnProperty(key)) {\n                    if (child.type !== undefined) {\n                        this.visit(child)\n                    } else if (Array.isArray(child)) {\n                        child.forEach(function(subChild) {\n                            this.visit(subChild)\n                        }, this)\n                    }\n                }\n            }\n        }\n\n        BaseRegExpVisitor.prototype.visit = function(node) {\n            switch (node.type) {\n                case \"Pattern\":\n                    this.visitPattern(node)\n                    break\n                case \"Flags\":\n                    this.visitFlags(node)\n                    break\n                case \"Disjunction\":\n                    this.visitDisjunction(node)\n                    break\n                case \"Alternative\":\n                    this.visitAlternative(node)\n                    break\n                case \"StartAnchor\":\n                    this.visitStartAnchor(node)\n                    break\n                case \"EndAnchor\":\n                    this.visitEndAnchor(node)\n                    break\n                case \"WordBoundary\":\n                    this.visitWordBoundary(node)\n                    break\n                case \"NonWordBoundary\":\n                    this.visitNonWordBoundary(node)\n                    break\n                case \"Lookahead\":\n                    this.visitLookahead(node)\n                    break\n                case \"NegativeLookahead\":\n                    this.visitNegativeLookahead(node)\n                    break\n                case \"Character\":\n                    this.visitCharacter(node)\n                    break\n                case \"Set\":\n                    this.visitSet(node)\n                    break\n                case \"Group\":\n                    this.visitGroup(node)\n                    break\n                case \"GroupBackReference\":\n                    this.visitGroupBackReference(node)\n                    break\n                case \"Quantifier\":\n                    this.visitQuantifier(node)\n                    break\n            }\n\n            this.visitChildren(node)\n        }\n\n        BaseRegExpVisitor.prototype.visitPattern = function(node) {}\n\n        BaseRegExpVisitor.prototype.visitFlags = function(node) {}\n\n        BaseRegExpVisitor.prototype.visitDisjunction = function(node) {}\n\n        BaseRegExpVisitor.prototype.visitAlternative = function(node) {}\n\n        // Assertion\n        BaseRegExpVisitor.prototype.visitStartAnchor = function(node) {}\n\n        BaseRegExpVisitor.prototype.visitEndAnchor = function(node) {}\n\n        BaseRegExpVisitor.prototype.visitWordBoundary = function(node) {}\n\n        BaseRegExpVisitor.prototype.visitNonWordBoundary = function(node) {}\n\n        BaseRegExpVisitor.prototype.visitLookahead = function(node) {}\n\n        BaseRegExpVisitor.prototype.visitNegativeLookahead = function(node) {}\n\n        // atoms\n        BaseRegExpVisitor.prototype.visitCharacter = function(node) {}\n\n        BaseRegExpVisitor.prototype.visitSet = function(node) {}\n\n        BaseRegExpVisitor.prototype.visitGroup = function(node) {}\n\n        BaseRegExpVisitor.prototype.visitGroupBackReference = function(node) {}\n\n        BaseRegExpVisitor.prototype.visitQuantifier = function(node) {}\n\n        return {\n            RegExpParser: RegExpParser,\n            BaseRegExpVisitor: BaseRegExpVisitor,\n            VERSION: \"0.5.0\"\n        }\n    }\n)\n", "/**\n * Gets the first element of `array`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @alias first\n * @category Array\n * @param {Array} array The array to query.\n * @returns {*} Returns the first element of `array`.\n * @example\n *\n * _.head([1, 2, 3]);\n * // => 1\n *\n * _.head([]);\n * // => undefined\n */\nfunction head(array) {\n  return (array && array.length) ? array[0] : undefined;\n}\n\nmodule.exports = head;\n", "module.exports = require('./head');\n", "/**\n * Creates an array with all falsey values removed. The values `false`, `null`,\n * `0`, `\"\"`, `undefined`, and `NaN` are falsey.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {Array} array The array to compact.\n * @returns {Array} Returns the new array of filtered values.\n * @example\n *\n * _.compact([0, 1, false, 2, '', 3]);\n * // => [1, 2, 3]\n */\nfunction compact(array) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      resIndex = 0,\n      result = [];\n\n  while (++index < length) {\n    var value = array[index];\n    if (value) {\n      result[resIndex++] = value;\n    }\n  }\n  return result;\n}\n\nmodule.exports = compact;\n", "var baseEach = require('./_baseEach');\n\n/**\n * The base implementation of `_.filter` without support for iteratee shorthands.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n */\nfunction baseFilter(collection, predicate) {\n  var result = [];\n  baseEach(collection, function(value, index, collection) {\n    if (predicate(value, index, collection)) {\n      result.push(value);\n    }\n  });\n  return result;\n}\n\nmodule.exports = baseFilter;\n", "/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/**\n * Creates a function that negates the result of the predicate `func`. The\n * `func` predicate is invoked with the `this` binding and arguments of the\n * created function.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Function\n * @param {Function} predicate The predicate to negate.\n * @returns {Function} Returns the new negated function.\n * @example\n *\n * function isEven(n) {\n *   return n % 2 == 0;\n * }\n *\n * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));\n * // => [1, 3, 5]\n */\nfunction negate(predicate) {\n  if (typeof predicate != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  return function() {\n    var args = arguments;\n    switch (args.length) {\n      case 0: return !predicate.call(this);\n      case 1: return !predicate.call(this, args[0]);\n      case 2: return !predicate.call(this, args[0], args[1]);\n      case 3: return !predicate.call(this, args[0], args[1], args[2]);\n    }\n    return !predicate.apply(this, args);\n  };\n}\n\nmodule.exports = negate;\n", "var arrayFilter = require('./_arrayFilter'),\n    baseFilter = require('./_baseFilter'),\n    baseIteratee = require('./_baseIteratee'),\n    isArray = require('./isArray'),\n    negate = require('./negate');\n\n/**\n * The opposite of `_.filter`; this method returns the elements of `collection`\n * that `predicate` does **not** return truthy for.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [predicate=_.identity] The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n * @see _.filter\n * @example\n *\n * var users = [\n *   { 'user': 'barney', 'age': 36, 'active': false },\n *   { 'user': 'fred',   'age': 40, 'active': true }\n * ];\n *\n * _.reject(users, function(o) { return !o.active; });\n * // => objects for ['fred']\n *\n * // The `_.matches` iteratee shorthand.\n * _.reject(users, { 'age': 40, 'active': true });\n * // => objects for ['barney']\n *\n * // The `_.matchesProperty` iteratee shorthand.\n * _.reject(users, ['active', false]);\n * // => objects for ['fred']\n *\n * // The `_.property` iteratee shorthand.\n * _.reject(users, 'active');\n * // => objects for ['barney']\n */\nfunction reject(collection, predicate) {\n  var func = isArray(collection) ? arrayFilter : baseFilter;\n  return func(collection, negate(baseIteratee(predicate, 3)));\n}\n\nmodule.exports = reject;\n", "var SetCache = require('./_SetCache'),\n    arrayIncludes = require('./_arrayIncludes'),\n    arrayIncludesWith = require('./_arrayIncludesWith'),\n    arrayMap = require('./_arrayMap'),\n    baseUnary = require('./_baseUnary'),\n    cacheHas = require('./_cacheHas');\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/**\n * The base implementation of methods like `_.difference` without support\n * for excluding multiple arrays or iteratee shorthands.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {Array} values The values to exclude.\n * @param {Function} [iteratee] The iteratee invoked per element.\n * @param {Function} [comparator] The comparator invoked per element.\n * @returns {Array} Returns the new array of filtered values.\n */\nfunction baseDifference(array, values, iteratee, comparator) {\n  var index = -1,\n      includes = arrayIncludes,\n      isCommon = true,\n      length = array.length,\n      result = [],\n      valuesLength = values.length;\n\n  if (!length) {\n    return result;\n  }\n  if (iteratee) {\n    values = arrayMap(values, baseUnary(iteratee));\n  }\n  if (comparator) {\n    includes = arrayIncludesWith;\n    isCommon = false;\n  }\n  else if (values.length >= LARGE_ARRAY_SIZE) {\n    includes = cacheHas;\n    isCommon = false;\n    values = new SetCache(values);\n  }\n  outer:\n  while (++index < length) {\n    var value = array[index],\n        computed = iteratee == null ? value : iteratee(value);\n\n    value = (comparator || value !== 0) ? value : 0;\n    if (isCommon && computed === computed) {\n      var valuesIndex = valuesLength;\n      while (valuesIndex--) {\n        if (values[valuesIndex] === computed) {\n          continue outer;\n        }\n      }\n      result.push(value);\n    }\n    else if (!includes(values, computed, comparator)) {\n      result.push(value);\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseDifference;\n", "var isArrayLike = require('./isArrayLike'),\n    isObjectLike = require('./isObjectLike');\n\n/**\n * This method is like `_.isArrayLike` except that it also checks if `value`\n * is an object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array-like object,\n *  else `false`.\n * @example\n *\n * _.isArrayLikeObject([1, 2, 3]);\n * // => true\n *\n * _.isArrayLikeObject(document.body.children);\n * // => true\n *\n * _.isArrayLikeObject('abc');\n * // => false\n *\n * _.isArrayLikeObject(_.noop);\n * // => false\n */\nfunction isArrayLikeObject(value) {\n  return isObjectLike(value) && isArrayLike(value);\n}\n\nmodule.exports = isArrayLikeObject;\n", "var baseDifference = require('./_baseDifference'),\n    baseFlatten = require('./_baseFlatten'),\n    baseRest = require('./_baseRest'),\n    isArrayLikeObject = require('./isArrayLikeObject');\n\n/**\n * Creates an array of `array` values not included in the other given arrays\n * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * for equality comparisons. The order and references of result values are\n * determined by the first array.\n *\n * **Note:** Unlike `_.pullAll`, this method returns a new array.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {Array} array The array to inspect.\n * @param {...Array} [values] The values to exclude.\n * @returns {Array} Returns the new array of filtered values.\n * @see _.without, _.xor\n * @example\n *\n * _.difference([2, 1], [2, 3]);\n * // => [1]\n */\nvar difference = baseRest(function(array, values) {\n  return isArrayLikeObject(array)\n    ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true))\n    : [];\n});\n\nmodule.exports = difference;\n", "var baseIndexOf = require('./_baseIndexOf'),\n    toInteger = require('./toInteger');\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max;\n\n/**\n * Gets the index at which the first occurrence of `value` is found in `array`\n * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * for equality comparisons. If `fromIndex` is negative, it's used as the\n * offset from the end of `array`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {Array} array The array to inspect.\n * @param {*} value The value to search for.\n * @param {number} [fromIndex=0] The index to search from.\n * @returns {number} Returns the index of the matched value, else `-1`.\n * @example\n *\n * _.indexOf([1, 2, 1, 2], 2);\n * // => 1\n *\n * // Search from the `fromIndex`.\n * _.indexOf([1, 2, 1, 2], 2, 2);\n * // => 3\n */\nfunction indexOf(array, value, fromIndex) {\n  var length = array == null ? 0 : array.length;\n  if (!length) {\n    return -1;\n  }\n  var index = fromIndex == null ? 0 : toInteger(fromIndex);\n  if (index < 0) {\n    index = nativeMax(length + index, 0);\n  }\n  return baseIndexOf(array, value, index);\n}\n\nmodule.exports = indexOf;\n", "var baseIteratee = require('./_baseIteratee'),\n    isArrayLike = require('./isArrayLike'),\n    keys = require('./keys');\n\n/**\n * Creates a `_.find` or `_.findLast` function.\n *\n * @private\n * @param {Function} findIndexFunc The function to find the collection index.\n * @returns {Function} Returns the new find function.\n */\nfunction createFind(findIndexFunc) {\n  return function(collection, predicate, fromIndex) {\n    var iterable = Object(collection);\n    if (!isArrayLike(collection)) {\n      var iteratee = baseIteratee(predicate, 3);\n      collection = keys(collection);\n      predicate = function(key) { return iteratee(iterable[key], key, iterable); };\n    }\n    var index = findIndexFunc(collection, predicate, fromIndex);\n    return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;\n  };\n}\n\nmodule.exports = createFind;\n", "var baseFindIndex = require('./_baseFindIndex'),\n    baseIteratee = require('./_baseIteratee'),\n    toInteger = require('./toInteger');\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max;\n\n/**\n * This method is like `_.find` except that it returns the index of the first\n * element `predicate` returns truthy for instead of the element itself.\n *\n * @static\n * @memberOf _\n * @since 1.1.0\n * @category Array\n * @param {Array} array The array to inspect.\n * @param {Function} [predicate=_.identity] The function invoked per iteration.\n * @param {number} [fromIndex=0] The index to search from.\n * @returns {number} Returns the index of the found element, else `-1`.\n * @example\n *\n * var users = [\n *   { 'user': 'barney',  'active': false },\n *   { 'user': 'fred',    'active': false },\n *   { 'user': 'pebbles', 'active': true }\n * ];\n *\n * _.findIndex(users, function(o) { return o.user == 'barney'; });\n * // => 0\n *\n * // The `_.matches` iteratee shorthand.\n * _.findIndex(users, { 'user': 'fred', 'active': false });\n * // => 1\n *\n * // The `_.matchesProperty` iteratee shorthand.\n * _.findIndex(users, ['active', false]);\n * // => 0\n *\n * // The `_.property` iteratee shorthand.\n * _.findIndex(users, 'active');\n * // => 2\n */\nfunction findIndex(array, predicate, fromIndex) {\n  var length = array == null ? 0 : array.length;\n  if (!length) {\n    return -1;\n  }\n  var index = fromIndex == null ? 0 : toInteger(fromIndex);\n  if (index < 0) {\n    index = nativeMax(length + index, 0);\n  }\n  return baseFindIndex(array, baseIteratee(predicate, 3), index);\n}\n\nmodule.exports = findIndex;\n", "var createFind = require('./_createFind'),\n    findIndex = require('./findIndex');\n\n/**\n * Iterates over elements of `collection`, returning the first element\n * `predicate` returns truthy for. The predicate is invoked with three\n * arguments: (value, index|key, collection).\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to inspect.\n * @param {Function} [predicate=_.identity] The function invoked per iteration.\n * @param {number} [fromIndex=0] The index to search from.\n * @returns {*} Returns the matched element, else `undefined`.\n * @example\n *\n * var users = [\n *   { 'user': 'barney',  'age': 36, 'active': true },\n *   { 'user': 'fred',    'age': 40, 'active': false },\n *   { 'user': 'pebbles', 'age': 1,  'active': true }\n * ];\n *\n * _.find(users, function(o) { return o.age < 40; });\n * // => object for 'barney'\n *\n * // The `_.matches` iteratee shorthand.\n * _.find(users, { 'age': 1, 'active': true });\n * // => object for 'pebbles'\n *\n * // The `_.matchesProperty` iteratee shorthand.\n * _.find(users, ['active', false]);\n * // => object for 'fred'\n *\n * // The `_.property` iteratee shorthand.\n * _.find(users, 'active');\n * // => object for 'barney'\n */\nvar find = createFind(findIndex);\n\nmodule.exports = find;\n", "var arrayFilter = require('./_arrayFilter'),\n    baseFilter = require('./_baseFilter'),\n    baseIteratee = require('./_baseIteratee'),\n    isArray = require('./isArray');\n\n/**\n * Iterates over elements of `collection`, returning an array of all elements\n * `predicate` returns truthy for. The predicate is invoked with three\n * arguments: (value, index|key, collection).\n *\n * **Note:** Unlike `_.remove`, this method returns a new array.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [predicate=_.identity] The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n * @see _.reject\n * @example\n *\n * var users = [\n *   { 'user': 'barney', 'age': 36, 'active': true },\n *   { 'user': 'fred',   'age': 40, 'active': false }\n * ];\n *\n * _.filter(users, function(o) { return !o.active; });\n * // => objects for ['fred']\n *\n * // The `_.matches` iteratee shorthand.\n * _.filter(users, { 'age': 36, 'active': true });\n * // => objects for ['barney']\n *\n * // The `_.matchesProperty` iteratee shorthand.\n * _.filter(users, ['active', false]);\n * // => objects for ['fred']\n *\n * // The `_.property` iteratee shorthand.\n * _.filter(users, 'active');\n * // => objects for ['barney']\n *\n * // Combining several predicates using `_.overEvery` or `_.overSome`.\n * _.filter(users, _.overSome([{ 'age': 36 }, ['age', 40]]));\n * // => objects for ['fred', 'barney']\n */\nfunction filter(collection, predicate) {\n  var func = isArray(collection) ? arrayFilter : baseFilter;\n  return func(collection, baseIteratee(predicate, 3));\n}\n\nmodule.exports = filter;\n", "var baseRest = require('./_baseRest'),\n    eq = require('./eq'),\n    isIterateeCall = require('./_isIterateeCall'),\n    keysIn = require('./keysIn');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Assigns own and inherited enumerable string keyed properties of source\n * objects to the destination object for all destination properties that\n * resolve to `undefined`. Source objects are applied from left to right.\n * Once a property is set, additional values of the same property are ignored.\n *\n * **Note:** This method mutates `object`.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The destination object.\n * @param {...Object} [sources] The source objects.\n * @returns {Object} Returns `object`.\n * @see _.defaultsDeep\n * @example\n *\n * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });\n * // => { 'a': 1, 'b': 2 }\n */\nvar defaults = baseRest(function(object, sources) {\n  object = Object(object);\n\n  var index = -1;\n  var length = sources.length;\n  var guard = length > 2 ? sources[2] : undefined;\n\n  if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n    length = 1;\n  }\n\n  while (++index < length) {\n    var source = sources[index];\n    var props = keysIn(source);\n    var propsIndex = -1;\n    var propsLength = props.length;\n\n    while (++propsIndex < propsLength) {\n      var key = props[propsIndex];\n      var value = object[key];\n\n      if (value === undefined ||\n          (eq(value, objectProto[key]) && !hasOwnProperty.call(object, key))) {\n        object[key] = source[key];\n      }\n    }\n  }\n\n  return object;\n});\n\nmodule.exports = defaults;\n", "/**\n * A specialized version of `_.reduce` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {*} [accumulator] The initial value.\n * @param {boolean} [initAccum] Specify using the first element of `array` as\n *  the initial value.\n * @returns {*} Returns the accumulated value.\n */\nfunction arrayReduce(array, iteratee, accumulator, initAccum) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  if (initAccum && length) {\n    accumulator = array[++index];\n  }\n  while (++index < length) {\n    accumulator = iteratee(accumulator, array[index], index, array);\n  }\n  return accumulator;\n}\n\nmodule.exports = arrayReduce;\n", "/**\n * The base implementation of `_.reduce` and `_.reduceRight`, without support\n * for iteratee shorthands, which iterates over `collection` using `eachFunc`.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {*} accumulator The initial value.\n * @param {boolean} initAccum Specify using the first or last element of\n *  `collection` as the initial value.\n * @param {Function} eachFunc The function to iterate over `collection`.\n * @returns {*} Returns the accumulated value.\n */\nfunction baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {\n  eachFunc(collection, function(value, index, collection) {\n    accumulator = initAccum\n      ? (initAccum = false, value)\n      : iteratee(accumulator, value, index, collection);\n  });\n  return accumulator;\n}\n\nmodule.exports = baseReduce;\n", "var arrayReduce = require('./_arrayReduce'),\n    baseEach = require('./_baseEach'),\n    baseIteratee = require('./_baseIteratee'),\n    baseReduce = require('./_baseReduce'),\n    isArray = require('./isArray');\n\n/**\n * Reduces `collection` to a value which is the accumulated result of running\n * each element in `collection` thru `iteratee`, where each successive\n * invocation is supplied the return value of the previous. If `accumulator`\n * is not given, the first element of `collection` is used as the initial\n * value. The iteratee is invoked with four arguments:\n * (accumulator, value, index|key, collection).\n *\n * Many lodash methods are guarded to work as iteratees for methods like\n * `_.reduce`, `_.reduceRight`, and `_.transform`.\n *\n * The guarded methods are:\n * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,\n * and `sortBy`\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n * @param {*} [accumulator] The initial value.\n * @returns {*} Returns the accumulated value.\n * @see _.reduceRight\n * @example\n *\n * _.reduce([1, 2], function(sum, n) {\n *   return sum + n;\n * }, 0);\n * // => 3\n *\n * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {\n *   (result[value] || (result[value] = [])).push(key);\n *   return result;\n * }, {});\n * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)\n */\nfunction reduce(collection, iteratee, accumulator) {\n  var func = isArray(collection) ? arrayReduce : baseReduce,\n      initAccum = arguments.length < 3;\n\n  return func(collection, baseIteratee(iteratee, 4), accumulator, initAccum, baseEach);\n}\n\nmodule.exports = reduce;\n", "import {\n  Alternative,\n  Assertion,\n  Atom,\n  Disjunction,\n  RegExpParser,\n  RegExpPattern\n} from \"regexp-to-ast\"\n\nlet regExpAstCache: { [regex: string]: RegExpPattern } = {}\nconst regExpParser = new RegExpParser()\n\n// this should be moved to regexp-to-ast\nexport type ASTNode =\n  | RegExpPattern\n  | Disjunction\n  | Alternative\n  | Assertion\n  | Atom\n\nexport function getRegExpAst(regExp: RegExp): RegExpPattern {\n  const regExpStr = regExp.toString()\n  if (regExpAstCache.hasOwnProperty(regExpStr)) {\n    return regExpAstCache[regExpStr]\n  } else {\n    const regExpAst = regExpParser.pattern(regExpStr)\n    regExpAstCache[regExpStr] = regExpAst\n    return regExpAst\n  }\n}\n\nexport function clearRegExpParserCache() {\n  regExpAstCache = {}\n}\n", "import {\n  Alternative,\n  Atom,\n  BaseRegExpVisitor,\n  Character,\n  Disjunction,\n  Group,\n  Set,\n  Term,\n  VERSION\n} from \"regexp-to-ast\"\nimport isArray from \"lodash/isArray\"\nimport every from \"lodash/every\"\nimport forEach from \"lodash/forEach\"\nimport find from \"lodash/find\"\nimport values from \"lodash/values\"\nimport includes from \"lodash/includes\"\nimport { PRINT_ERROR, PRINT_WARNING } from \"@chevrotain/utils\"\nimport { ASTNode, getRegExpAst } from \"./reg_exp_parser\"\nimport { charCodeToOptimizedIndex, minOptimizationVal } from \"./lexer\"\n\nconst complementErrorMessage =\n  \"Complement Sets are not supported for first char optimization\"\nexport const failedOptimizationPrefixMsg =\n  'Unable to use \"first char\" lexer optimizations:\\n'\n\nexport function getOptimizedStartCodesIndices(\n  regExp: RegExp,\n  ensureOptimizations = false\n): number[] {\n  try {\n    const ast = getRegExpAst(regExp)\n    const firstChars = firstCharOptimizedIndices(\n      ast.value,\n      {},\n      ast.flags.ignoreCase\n    )\n    return firstChars\n  } catch (e) {\n    /* istanbul ignore next */\n    // Testing this relies on the regexp-to-ast library having a bug... */\n    // TODO: only the else branch needs to be ignored, try to fix with newer prettier / tsc\n    if (e.message === complementErrorMessage) {\n      if (ensureOptimizations) {\n        PRINT_WARNING(\n          `${failedOptimizationPrefixMsg}` +\n            `\\tUnable to optimize: < ${regExp.toString()} >\\n` +\n            \"\\tComplement Sets cannot be automatically optimized.\\n\" +\n            \"\\tThis will disable the lexer's first char optimizations.\\n\" +\n            \"\\tSee: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#COMPLEMENT for details.\"\n        )\n      }\n    } else {\n      let msgSuffix = \"\"\n      if (ensureOptimizations) {\n        msgSuffix =\n          \"\\n\\tThis will disable the lexer's first char optimizations.\\n\" +\n          \"\\tSee: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#REGEXP_PARSING for details.\"\n      }\n      PRINT_ERROR(\n        `${failedOptimizationPrefixMsg}\\n` +\n          `\\tFailed parsing: < ${regExp.toString()} >\\n` +\n          `\\tUsing the regexp-to-ast library version: ${VERSION}\\n` +\n          \"\\tPlease open an issue at: https://github.com/bd82/regexp-to-ast/issues\" +\n          msgSuffix\n      )\n    }\n  }\n\n  return []\n}\n\nexport function firstCharOptimizedIndices(\n  ast: ASTNode,\n  result: { [charCode: number]: number },\n  ignoreCase: boolean\n): number[] {\n  switch (ast.type) {\n    case \"Disjunction\":\n      for (let i = 0; i < ast.value.length; i++) {\n        firstCharOptimizedIndices(ast.value[i], result, ignoreCase)\n      }\n      break\n    case \"Alternative\":\n      const terms = ast.value\n      for (let i = 0; i < terms.length; i++) {\n        const term = terms[i]\n\n        // skip terms that cannot effect the first char results\n        switch (term.type) {\n          case \"EndAnchor\":\n          // A group back reference cannot affect potential starting char.\n          // because if a back reference is the first production than automatically\n          // the group being referenced has had to come BEFORE so its codes have already been added\n          case \"GroupBackReference\":\n          // assertions do not affect potential starting codes\n          case \"Lookahead\":\n          case \"NegativeLookahead\":\n          case \"StartAnchor\":\n          case \"WordBoundary\":\n          case \"NonWordBoundary\":\n            continue\n        }\n\n        const atom = term\n        switch (atom.type) {\n          case \"Character\":\n            addOptimizedIdxToResult(atom.value, result, ignoreCase)\n            break\n          case \"Set\":\n            if (atom.complement === true) {\n              throw Error(complementErrorMessage)\n            }\n            forEach(atom.value, (code) => {\n              if (typeof code === \"number\") {\n                addOptimizedIdxToResult(code, result, ignoreCase)\n              } else {\n                // range\n                const range = code as any\n                // cannot optimize when ignoreCase is\n                if (ignoreCase === true) {\n                  for (\n                    let rangeCode = range.from;\n                    rangeCode <= range.to;\n                    rangeCode++\n                  ) {\n                    addOptimizedIdxToResult(rangeCode, result, ignoreCase)\n                  }\n                }\n                // Optimization (2 orders of magnitude less work for very large ranges)\n                else {\n                  // handle unoptimized values\n                  for (\n                    let rangeCode = range.from;\n                    rangeCode <= range.to && rangeCode < minOptimizationVal;\n                    rangeCode++\n                  ) {\n                    addOptimizedIdxToResult(rangeCode, result, ignoreCase)\n                  }\n\n                  // Less common charCode where we optimize for faster init time, by using larger \"buckets\"\n                  if (range.to >= minOptimizationVal) {\n                    const minUnOptVal =\n                      range.from >= minOptimizationVal\n                        ? range.from\n                        : minOptimizationVal\n                    const maxUnOptVal = range.to\n                    const minOptIdx = charCodeToOptimizedIndex(minUnOptVal)\n                    const maxOptIdx = charCodeToOptimizedIndex(maxUnOptVal)\n\n                    for (\n                      let currOptIdx = minOptIdx;\n                      currOptIdx <= maxOptIdx;\n                      currOptIdx++\n                    ) {\n                      result[currOptIdx] = currOptIdx\n                    }\n                  }\n                }\n              }\n            })\n            break\n          case \"Group\":\n            firstCharOptimizedIndices(atom.value, result, ignoreCase)\n            break\n          /* istanbul ignore next */\n          default:\n            throw Error(\"Non Exhaustive Match\")\n        }\n\n        // reached a mandatory production, no more **start** codes can be found on this alternative\n        const isOptionalQuantifier =\n          atom.quantifier !== undefined && atom.quantifier.atLeast === 0\n        if (\n          // A group may be optional due to empty contents /(?:)/\n          // or if everything inside it is optional /((a)?)/\n          (atom.type === \"Group\" && isWholeOptional(atom) === false) ||\n          // If this term is not a group it may only be optional if it has an optional quantifier\n          (atom.type !== \"Group\" && isOptionalQuantifier === false)\n        ) {\n          break\n        }\n      }\n      break\n    /* istanbul ignore next */\n    default:\n      throw Error(\"non exhaustive match!\")\n  }\n\n  // console.log(Object.keys(result).length)\n  return values(result)\n}\n\nfunction addOptimizedIdxToResult(\n  code: number,\n  result: { [charCode: number]: number },\n  ignoreCase: boolean\n) {\n  const optimizedCharIdx = charCodeToOptimizedIndex(code)\n  result[optimizedCharIdx] = optimizedCharIdx\n\n  if (ignoreCase === true) {\n    handleIgnoreCase(code, result)\n  }\n}\n\nfunction handleIgnoreCase(\n  code: number,\n  result: { [charCode: number]: number }\n) {\n  const char = String.fromCharCode(code)\n  const upperChar = char.toUpperCase()\n  /* istanbul ignore else */\n  if (upperChar !== char) {\n    const optimizedCharIdx = charCodeToOptimizedIndex(upperChar.charCodeAt(0))\n    result[optimizedCharIdx] = optimizedCharIdx\n  } else {\n    const lowerChar = char.toLowerCase()\n    if (lowerChar !== char) {\n      const optimizedCharIdx = charCodeToOptimizedIndex(lowerChar.charCodeAt(0))\n      result[optimizedCharIdx] = optimizedCharIdx\n    }\n  }\n}\n\nfunction findCode(setNode: Set, targetCharCodes: number[]) {\n  return find(setNode.value, (codeOrRange) => {\n    if (typeof codeOrRange === \"number\") {\n      return includes(targetCharCodes, codeOrRange)\n    } else {\n      // range\n      const range = <any>codeOrRange\n      return (\n        find(\n          targetCharCodes,\n          (targetCode) => range.from <= targetCode && targetCode <= range.to\n        ) !== undefined\n      )\n    }\n  })\n}\n\nfunction isWholeOptional(ast: any): boolean {\n  const quantifier = (ast as Atom).quantifier\n  if (quantifier && quantifier.atLeast === 0) {\n    return true\n  }\n\n  if (!ast.value) {\n    return false\n  }\n\n  return isArray(ast.value)\n    ? every(ast.value, isWholeOptional)\n    : isWholeOptional(ast.value)\n}\n\nclass CharCodeFinder extends BaseRegExpVisitor {\n  found: boolean = false\n\n  constructor(private targetCharCodes: number[]) {\n    super()\n  }\n\n  visitChildren(node: ASTNode) {\n    // No need to keep looking...\n    if (this.found === true) {\n      return\n    }\n\n    // switch lookaheads as they do not actually consume any characters thus\n    // finding a charCode at lookahead context does not mean that regexp can actually contain it in a match.\n    switch (node.type) {\n      case \"Lookahead\":\n        this.visitLookahead(node)\n        return\n      case \"NegativeLookahead\":\n        this.visitNegativeLookahead(node)\n        return\n    }\n\n    super.visitChildren(node)\n  }\n\n  visitCharacter(node: Character) {\n    if (includes(this.targetCharCodes, node.value)) {\n      this.found = true\n    }\n  }\n\n  visitSet(node: Set) {\n    if (node.complement) {\n      if (findCode(node, this.targetCharCodes) === undefined) {\n        this.found = true\n      }\n    } else {\n      if (findCode(node, this.targetCharCodes) !== undefined) {\n        this.found = true\n      }\n    }\n  }\n}\n\nexport function canMatchCharCode(\n  charCodes: number[],\n  pattern: RegExp | string\n) {\n  if (pattern instanceof RegExp) {\n    const ast = getRegExpAst(pattern)\n    const charCodeFinder = new CharCodeFinder(charCodes)\n    charCodeFinder.visit(ast)\n    return charCodeFinder.found\n  } else {\n    return (\n      find(<any>pattern, (char) => {\n        return includes(charCodes, (<string>char).charCodeAt(0))\n      }) !== undefined\n    )\n  }\n}\n", "import { BaseRegExpVisitor } from \"regexp-to-ast\"\nimport { IRegExpExec, Lexer, LexerDefinitionErrorType } from \"./lexer_public\"\nimport first from \"lodash/first\"\nimport isEmpty from \"lodash/isEmpty\"\nimport compact from \"lodash/compact\"\nimport isArray from \"lodash/isArray\"\nimport values from \"lodash/values\"\nimport flatten from \"lodash/flatten\"\nimport reject from \"lodash/reject\"\nimport difference from \"lodash/difference\"\nimport indexOf from \"lodash/indexOf\"\nimport map from \"lodash/map\"\nimport forEach from \"lodash/forEach\"\nimport isString from \"lodash/isString\"\nimport isFunction from \"lodash/isFunction\"\nimport isUndefined from \"lodash/isUndefined\"\nimport find from \"lodash/find\"\nimport has from \"lodash/has\"\nimport keys from \"lodash/keys\"\nimport isRegExp from \"lodash/isRegExp\"\nimport filter from \"lodash/filter\"\nimport defaults from \"lodash/defaults\"\nimport reduce from \"lodash/reduce\"\nimport includes from \"lodash/includes\"\nimport { PRINT_ERROR } from \"@chevrotain/utils\"\nimport {\n  canMatchCharCode,\n  failedOptimizationPrefixMsg,\n  getOptimizedStartCodesIndices\n} from \"./reg_exp\"\nimport {\n  ILexerDefinitionError,\n  ILineTerminatorsTester,\n  IMultiModeLexerDefinition,\n  IToken,\n  TokenType\n} from \"@chevrotain/types\"\nimport { getRegExpAst } from \"./reg_exp_parser\"\n\nconst PATTERN = \"PATTERN\"\nexport const DEFAULT_MODE = \"defaultMode\"\nexport const MODES = \"modes\"\n\nexport interface IPatternConfig {\n  pattern: IRegExpExec | string\n  longerAlt: number[] | undefined\n  canLineTerminator: boolean\n  isCustom: boolean\n  short: number | false\n  group: string | undefined | false\n  push: string | undefined\n  pop: boolean\n  tokenType: TokenType\n  tokenTypeIdx: number\n}\n\nexport interface IAnalyzeResult {\n  patternIdxToConfig: IPatternConfig[]\n  charCodeToPatternIdxToConfig: { [charCode: number]: IPatternConfig[] }\n  emptyGroups: { [groupName: string]: IToken[] }\n  hasCustom: boolean\n  canBeOptimized: boolean\n}\n\nexport let SUPPORT_STICKY =\n  typeof (<any>new RegExp(\"(?:)\")).sticky === \"boolean\"\n\nexport function disableSticky() {\n  SUPPORT_STICKY = false\n}\n\nexport function enableSticky() {\n  SUPPORT_STICKY = true\n}\n\nexport function analyzeTokenTypes(\n  tokenTypes: TokenType[],\n  options: {\n    positionTracking?: \"full\" | \"onlyStart\" | \"onlyOffset\"\n    ensureOptimizations?: boolean\n    lineTerminatorCharacters?: (number | string)[]\n    // TODO: should `useSticky` be an argument here?\n    useSticky?: boolean\n    safeMode?: boolean\n    tracer?: (msg: string, action: () => void) => void\n  }\n): IAnalyzeResult {\n  options = defaults(options, {\n    useSticky: SUPPORT_STICKY,\n    debug: false as boolean,\n    safeMode: false as boolean,\n    positionTracking: \"full\",\n    lineTerminatorCharacters: [\"\\r\", \"\\n\"],\n    tracer: (msg: string, action: Function) => action()\n  })\n\n  const tracer = options.tracer!\n\n  tracer(\"initCharCodeToOptimizedIndexMap\", () => {\n    initCharCodeToOptimizedIndexMap()\n  })\n\n  let onlyRelevantTypes: TokenType[]\n  tracer(\"Reject Lexer.NA\", () => {\n    onlyRelevantTypes = reject(tokenTypes, (currType) => {\n      return currType[PATTERN] === Lexer.NA\n    })\n  })\n\n  let hasCustom = false\n  let allTransformedPatterns: (IRegExpExec | string)[]\n  tracer(\"Transform Patterns\", () => {\n    hasCustom = false\n    allTransformedPatterns = map(\n      onlyRelevantTypes,\n      (currType): IRegExpExec | string => {\n        const currPattern = currType[PATTERN]\n\n        /* istanbul ignore else */\n        if (isRegExp(currPattern)) {\n          const regExpSource = currPattern.source\n          if (\n            regExpSource.length === 1 &&\n            // only these regExp meta characters which can appear in a length one regExp\n            regExpSource !== \"^\" &&\n            regExpSource !== \"$\" &&\n            regExpSource !== \".\" &&\n            !currPattern.ignoreCase\n          ) {\n            return regExpSource\n          } else if (\n            regExpSource.length === 2 &&\n            regExpSource[0] === \"\\\\\" &&\n            // not a meta character\n            !includes(\n              [\n                \"d\",\n                \"D\",\n                \"s\",\n                \"S\",\n                \"t\",\n                \"r\",\n                \"n\",\n                \"t\",\n                \"0\",\n                \"c\",\n                \"b\",\n                \"B\",\n                \"f\",\n                \"v\",\n                \"w\",\n                \"W\"\n              ],\n              regExpSource[1]\n            )\n          ) {\n            // escaped meta Characters: /\\+/ /\\[/\n            // or redundant escaping: /\\a/\n            // without the escaping \"\\\"\n            return regExpSource[1]\n          } else {\n            return options.useSticky\n              ? addStickyFlag(currPattern)\n              : addStartOfInput(currPattern)\n          }\n        } else if (isFunction(currPattern)) {\n          hasCustom = true\n          // CustomPatternMatcherFunc - custom patterns do not require any transformations, only wrapping in a RegExp Like object\n          return { exec: currPattern }\n        } else if (typeof currPattern === \"object\") {\n          hasCustom = true\n          // ICustomPattern\n          return currPattern\n        } else if (typeof currPattern === \"string\") {\n          if (currPattern.length === 1) {\n            return currPattern\n          } else {\n            const escapedRegExpString = currPattern.replace(\n              /[\\\\^$.*+?()[\\]{}|]/g,\n              \"\\\\$&\"\n            )\n            const wrappedRegExp = new RegExp(escapedRegExpString)\n            return options.useSticky\n              ? addStickyFlag(wrappedRegExp)\n              : addStartOfInput(wrappedRegExp)\n          }\n        } else {\n          throw Error(\"non exhaustive match\")\n        }\n      }\n    )\n  })\n\n  let patternIdxToType: number[]\n  let patternIdxToGroup: (string | undefined | false)[]\n  let patternIdxToLongerAltIdxArr: (number[] | undefined)[]\n  let patternIdxToPushMode: (string | undefined)[]\n  let patternIdxToPopMode: boolean[]\n  tracer(\"misc mapping\", () => {\n    patternIdxToType = map(\n      onlyRelevantTypes,\n      (currType) => currType.tokenTypeIdx!\n    )\n\n    patternIdxToGroup = map(onlyRelevantTypes, (clazz: any) => {\n      const groupName = clazz.GROUP\n      /* istanbul ignore next */\n      if (groupName === Lexer.SKIPPED) {\n        return undefined\n      } else if (isString(groupName)) {\n        return groupName\n      } else if (isUndefined(groupName)) {\n        return false\n      } else {\n        throw Error(\"non exhaustive match\")\n      }\n    })\n\n    patternIdxToLongerAltIdxArr = map(onlyRelevantTypes, (clazz: any) => {\n      const longerAltType = clazz.LONGER_ALT\n\n      if (longerAltType) {\n        const longerAltIdxArr = isArray(longerAltType)\n          ? map(longerAltType, (type: any) => indexOf(onlyRelevantTypes, type))\n          : [indexOf(onlyRelevantTypes, longerAltType)]\n        return longerAltIdxArr\n      }\n    })\n\n    patternIdxToPushMode = map(\n      onlyRelevantTypes,\n      (clazz: any) => clazz.PUSH_MODE\n    )\n\n    patternIdxToPopMode = map(onlyRelevantTypes, (clazz: any) =>\n      has(clazz, \"POP_MODE\")\n    )\n  })\n\n  let patternIdxToCanLineTerminator: boolean[]\n  tracer(\"Line Terminator Handling\", () => {\n    const lineTerminatorCharCodes = getCharCodes(\n      options.lineTerminatorCharacters!\n    )\n    patternIdxToCanLineTerminator = map(onlyRelevantTypes, (tokType) => false)\n    if (options.positionTracking !== \"onlyOffset\") {\n      patternIdxToCanLineTerminator = map(onlyRelevantTypes, (tokType) => {\n        if (has(tokType, \"LINE_BREAKS\")) {\n          return !!tokType.LINE_BREAKS\n        } else {\n          return (\n            checkLineBreaksIssues(tokType, lineTerminatorCharCodes) === false &&\n            canMatchCharCode(\n              lineTerminatorCharCodes,\n              tokType.PATTERN as RegExp | string\n            )\n          )\n        }\n      })\n    }\n  })\n\n  let patternIdxToIsCustom: boolean[]\n  let patternIdxToShort: (number | false)[]\n  let emptyGroups!: { [groupName: string]: IToken[] }\n  let patternIdxToConfig!: IPatternConfig[]\n  tracer(\"Misc Mapping #2\", () => {\n    patternIdxToIsCustom = map(onlyRelevantTypes, isCustomPattern)\n    patternIdxToShort = map(allTransformedPatterns, isShortPattern)\n\n    emptyGroups = reduce(\n      onlyRelevantTypes,\n      (acc, clazz: any) => {\n        const groupName = clazz.GROUP\n        if (isString(groupName) && !(groupName === Lexer.SKIPPED)) {\n          acc[groupName] = []\n        }\n        return acc\n      },\n      {} as { [groupName: string]: IToken[] }\n    )\n\n    patternIdxToConfig = map(\n      allTransformedPatterns,\n      (x, idx): IPatternConfig => {\n        return {\n          pattern: allTransformedPatterns[idx],\n          longerAlt: patternIdxToLongerAltIdxArr[idx],\n          canLineTerminator: patternIdxToCanLineTerminator[idx],\n          isCustom: patternIdxToIsCustom[idx],\n          short: patternIdxToShort[idx],\n          group: patternIdxToGroup[idx],\n          push: patternIdxToPushMode[idx],\n          pop: patternIdxToPopMode[idx],\n          tokenTypeIdx: patternIdxToType[idx],\n          tokenType: onlyRelevantTypes[idx]\n        }\n      }\n    )\n  })\n\n  let canBeOptimized = true\n  let charCodeToPatternIdxToConfig: { [charCode: number]: IPatternConfig[] } =\n    []\n\n  if (!options.safeMode) {\n    tracer(\"First Char Optimization\", () => {\n      charCodeToPatternIdxToConfig = reduce(\n        onlyRelevantTypes,\n        (result, currTokType, idx) => {\n          if (typeof currTokType.PATTERN === \"string\") {\n            const charCode = currTokType.PATTERN.charCodeAt(0)\n            const optimizedIdx = charCodeToOptimizedIndex(charCode)\n            addToMapOfArrays(result, optimizedIdx, patternIdxToConfig[idx])\n          } else if (isArray(currTokType.START_CHARS_HINT)) {\n            let lastOptimizedIdx: number\n            forEach(currTokType.START_CHARS_HINT, (charOrInt) => {\n              const charCode =\n                typeof charOrInt === \"string\"\n                  ? charOrInt.charCodeAt(0)\n                  : charOrInt\n              const currOptimizedIdx = charCodeToOptimizedIndex(charCode)\n              // Avoid adding the config multiple times\n              /* istanbul ignore else */\n              // - Difficult to check this scenario effects as it is only a performance\n              //   optimization that does not change correctness\n              if (lastOptimizedIdx !== currOptimizedIdx) {\n                lastOptimizedIdx = currOptimizedIdx\n                addToMapOfArrays(\n                  result,\n                  currOptimizedIdx,\n                  patternIdxToConfig[idx]\n                )\n              }\n            })\n          } else if (isRegExp(currTokType.PATTERN)) {\n            if (currTokType.PATTERN.unicode) {\n              canBeOptimized = false\n              if (options.ensureOptimizations) {\n                PRINT_ERROR(\n                  `${failedOptimizationPrefixMsg}` +\n                    `\\tUnable to analyze < ${currTokType.PATTERN.toString()} > pattern.\\n` +\n                    \"\\tThe regexp unicode flag is not currently supported by the regexp-to-ast library.\\n\" +\n                    \"\\tThis will disable the lexer's first char optimizations.\\n\" +\n                    \"\\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#UNICODE_OPTIMIZE\"\n                )\n              }\n            } else {\n              const optimizedCodes = getOptimizedStartCodesIndices(\n                currTokType.PATTERN,\n                options.ensureOptimizations\n              )\n              /* istanbul ignore if */\n              // start code will only be empty given an empty regExp or failure of regexp-to-ast library\n              // the first should be a different validation and the second cannot be tested.\n              if (isEmpty(optimizedCodes)) {\n                // we cannot understand what codes may start possible matches\n                // The optimization correctness requires knowing start codes for ALL patterns.\n                // Not actually sure this is an error, no debug message\n                canBeOptimized = false\n              }\n              forEach(optimizedCodes, (code) => {\n                addToMapOfArrays(result, code, patternIdxToConfig[idx])\n              })\n            }\n          } else {\n            if (options.ensureOptimizations) {\n              PRINT_ERROR(\n                `${failedOptimizationPrefixMsg}` +\n                  `\\tTokenType: <${currTokType.name}> is using a custom token pattern without providing <start_chars_hint> parameter.\\n` +\n                  \"\\tThis will disable the lexer's first char optimizations.\\n\" +\n                  \"\\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#CUSTOM_OPTIMIZE\"\n              )\n            }\n            canBeOptimized = false\n          }\n\n          return result\n        },\n        [] as { [charCode: number]: IPatternConfig[] }\n      )\n    })\n  }\n\n  return {\n    emptyGroups: emptyGroups,\n    patternIdxToConfig: patternIdxToConfig,\n    charCodeToPatternIdxToConfig: charCodeToPatternIdxToConfig,\n    hasCustom: hasCustom,\n    canBeOptimized: canBeOptimized\n  }\n}\n\nexport function validatePatterns(\n  tokenTypes: TokenType[],\n  validModesNames: string[]\n): ILexerDefinitionError[] {\n  let errors: ILexerDefinitionError[] = []\n\n  const missingResult = findMissingPatterns(tokenTypes)\n  errors = errors.concat(missingResult.errors)\n\n  const invalidResult = findInvalidPatterns(missingResult.valid)\n  const validTokenTypes = invalidResult.valid\n  errors = errors.concat(invalidResult.errors)\n\n  errors = errors.concat(validateRegExpPattern(validTokenTypes))\n\n  errors = errors.concat(findInvalidGroupType(validTokenTypes))\n\n  errors = errors.concat(\n    findModesThatDoNotExist(validTokenTypes, validModesNames)\n  )\n\n  errors = errors.concat(findUnreachablePatterns(validTokenTypes))\n\n  return errors\n}\n\nfunction validateRegExpPattern(\n  tokenTypes: TokenType[]\n): ILexerDefinitionError[] {\n  let errors: ILexerDefinitionError[] = []\n  const withRegExpPatterns = filter(tokenTypes, (currTokType) =>\n    isRegExp(currTokType[PATTERN])\n  )\n\n  errors = errors.concat(findEndOfInputAnchor(withRegExpPatterns))\n\n  errors = errors.concat(findStartOfInputAnchor(withRegExpPatterns))\n\n  errors = errors.concat(findUnsupportedFlags(withRegExpPatterns))\n\n  errors = errors.concat(findDuplicatePatterns(withRegExpPatterns))\n\n  errors = errors.concat(findEmptyMatchRegExps(withRegExpPatterns))\n\n  return errors\n}\n\nexport interface ILexerFilterResult {\n  errors: ILexerDefinitionError[]\n  valid: TokenType[]\n}\n\nexport function findMissingPatterns(\n  tokenTypes: TokenType[]\n): ILexerFilterResult {\n  const tokenTypesWithMissingPattern = filter(tokenTypes, (currType) => {\n    return !has(currType, PATTERN)\n  })\n\n  const errors = map(tokenTypesWithMissingPattern, (currType) => {\n    return {\n      message:\n        \"Token Type: ->\" +\n        currType.name +\n        \"<- missing static 'PATTERN' property\",\n      type: LexerDefinitionErrorType.MISSING_PATTERN,\n      tokenTypes: [currType]\n    }\n  })\n\n  const valid = difference(tokenTypes, tokenTypesWithMissingPattern)\n  return { errors, valid }\n}\n\nexport function findInvalidPatterns(\n  tokenTypes: TokenType[]\n): ILexerFilterResult {\n  const tokenTypesWithInvalidPattern = filter(tokenTypes, (currType) => {\n    const pattern = currType[PATTERN]\n    return (\n      !isRegExp(pattern) &&\n      !isFunction(pattern) &&\n      !has(pattern, \"exec\") &&\n      !isString(pattern)\n    )\n  })\n\n  const errors = map(tokenTypesWithInvalidPattern, (currType) => {\n    return {\n      message:\n        \"Token Type: ->\" +\n        currType.name +\n        \"<- static 'PATTERN' can only be a RegExp, a\" +\n        \" Function matching the {CustomPatternMatcherFunc} type or an Object matching the {ICustomPattern} interface.\",\n      type: LexerDefinitionErrorType.INVALID_PATTERN,\n      tokenTypes: [currType]\n    }\n  })\n\n  const valid = difference(tokenTypes, tokenTypesWithInvalidPattern)\n  return { errors, valid }\n}\n\nconst end_of_input = /[^\\\\][$]/\n\nexport function findEndOfInputAnchor(\n  tokenTypes: TokenType[]\n): ILexerDefinitionError[] {\n  class EndAnchorFinder extends BaseRegExpVisitor {\n    found = false\n\n    visitEndAnchor(node: unknown) {\n      this.found = true\n    }\n  }\n\n  const invalidRegex = filter(tokenTypes, (currType) => {\n    const pattern = currType.PATTERN\n\n    try {\n      const regexpAst = getRegExpAst(pattern as RegExp)\n      const endAnchorVisitor = new EndAnchorFinder()\n      endAnchorVisitor.visit(regexpAst)\n\n      return endAnchorVisitor.found\n    } catch (e) {\n      // old behavior in case of runtime exceptions with regexp-to-ast.\n      /* istanbul ignore next - cannot ensure an error in regexp-to-ast*/\n      return end_of_input.test((pattern as RegExp).source)\n    }\n  })\n\n  const errors = map(invalidRegex, (currType) => {\n    return {\n      message:\n        \"Unexpected RegExp Anchor Error:\\n\" +\n        \"\\tToken Type: ->\" +\n        currType.name +\n        \"<- static 'PATTERN' cannot contain end of input anchor '$'\\n\" +\n        \"\\tSee chevrotain.io/docs/guide/resolving_lexer_errors.html#ANCHORS\" +\n        \"\\tfor details.\",\n      type: LexerDefinitionErrorType.EOI_ANCHOR_FOUND,\n      tokenTypes: [currType]\n    }\n  })\n\n  return errors\n}\n\nexport function findEmptyMatchRegExps(\n  tokenTypes: TokenType[]\n): ILexerDefinitionError[] {\n  const matchesEmptyString = filter(tokenTypes, (currType) => {\n    const pattern = currType.PATTERN as RegExp\n    return pattern.test(\"\")\n  })\n\n  const errors = map(matchesEmptyString, (currType) => {\n    return {\n      message:\n        \"Token Type: ->\" +\n        currType.name +\n        \"<- static 'PATTERN' must not match an empty string\",\n      type: LexerDefinitionErrorType.EMPTY_MATCH_PATTERN,\n      tokenTypes: [currType]\n    }\n  })\n\n  return errors\n}\n\nconst start_of_input = /[^\\\\[][\\^]|^\\^/\n\nexport function findStartOfInputAnchor(\n  tokenTypes: TokenType[]\n): ILexerDefinitionError[] {\n  class StartAnchorFinder extends BaseRegExpVisitor {\n    found = false\n\n    visitStartAnchor(node: unknown) {\n      this.found = true\n    }\n  }\n\n  const invalidRegex = filter(tokenTypes, (currType) => {\n    const pattern = currType.PATTERN as RegExp\n    try {\n      const regexpAst = getRegExpAst(pattern)\n      const startAnchorVisitor = new StartAnchorFinder()\n      startAnchorVisitor.visit(regexpAst)\n\n      return startAnchorVisitor.found\n    } catch (e) {\n      // old behavior in case of runtime exceptions with regexp-to-ast.\n      /* istanbul ignore next - cannot ensure an error in regexp-to-ast*/\n      return start_of_input.test(pattern.source)\n    }\n  })\n\n  const errors = map(invalidRegex, (currType) => {\n    return {\n      message:\n        \"Unexpected RegExp Anchor Error:\\n\" +\n        \"\\tToken Type: ->\" +\n        currType.name +\n        \"<- static 'PATTERN' cannot contain start of input anchor '^'\\n\" +\n        \"\\tSee https://chevrotain.io/docs/guide/resolving_lexer_errors.html#ANCHORS\" +\n        \"\\tfor details.\",\n      type: LexerDefinitionErrorType.SOI_ANCHOR_FOUND,\n      tokenTypes: [currType]\n    }\n  })\n\n  return errors\n}\n\nexport function findUnsupportedFlags(\n  tokenTypes: TokenType[]\n): ILexerDefinitionError[] {\n  const invalidFlags = filter(tokenTypes, (currType) => {\n    const pattern = currType[PATTERN]\n    return pattern instanceof RegExp && (pattern.multiline || pattern.global)\n  })\n\n  const errors = map(invalidFlags, (currType) => {\n    return {\n      message:\n        \"Token Type: ->\" +\n        currType.name +\n        \"<- static 'PATTERN' may NOT contain global('g') or multiline('m')\",\n      type: LexerDefinitionErrorType.UNSUPPORTED_FLAGS_FOUND,\n      tokenTypes: [currType]\n    }\n  })\n\n  return errors\n}\n\n// This can only test for identical duplicate RegExps, not semantically equivalent ones.\nexport function findDuplicatePatterns(\n  tokenTypes: TokenType[]\n): ILexerDefinitionError[] {\n  const found: TokenType[] = []\n  let identicalPatterns = map(tokenTypes, (outerType: any) => {\n    return reduce(\n      tokenTypes,\n      (result, innerType) => {\n        if (\n          outerType.PATTERN.source === (innerType.PATTERN as RegExp).source &&\n          !includes(found, innerType) &&\n          innerType.PATTERN !== Lexer.NA\n        ) {\n          // this avoids duplicates in the result, each Token Type may only appear in one \"set\"\n          // in essence we are creating Equivalence classes on equality relation.\n          found.push(innerType)\n          result.push(innerType)\n          return result\n        }\n        return result\n      },\n      [] as TokenType[]\n    )\n  })\n\n  identicalPatterns = compact(identicalPatterns)\n\n  const duplicatePatterns = filter(identicalPatterns, (currIdenticalSet) => {\n    return currIdenticalSet.length > 1\n  })\n\n  const errors = map(duplicatePatterns, (setOfIdentical: any) => {\n    const tokenTypeNames = map(setOfIdentical, (currType: any) => {\n      return currType.name\n    })\n\n    const dupPatternSrc = (<any>first(setOfIdentical)).PATTERN\n    return {\n      message:\n        `The same RegExp pattern ->${dupPatternSrc}<-` +\n        `has been used in all of the following Token Types: ${tokenTypeNames.join(\n          \", \"\n        )} <-`,\n      type: LexerDefinitionErrorType.DUPLICATE_PATTERNS_FOUND,\n      tokenTypes: setOfIdentical\n    }\n  })\n\n  return errors\n}\n\nexport function findInvalidGroupType(\n  tokenTypes: TokenType[]\n): ILexerDefinitionError[] {\n  const invalidTypes = filter(tokenTypes, (clazz: any) => {\n    if (!has(clazz, \"GROUP\")) {\n      return false\n    }\n    const group = clazz.GROUP\n\n    return group !== Lexer.SKIPPED && group !== Lexer.NA && !isString(group)\n  })\n\n  const errors = map(invalidTypes, (currType) => {\n    return {\n      message:\n        \"Token Type: ->\" +\n        currType.name +\n        \"<- static 'GROUP' can only be Lexer.SKIPPED/Lexer.NA/A String\",\n      type: LexerDefinitionErrorType.INVALID_GROUP_TYPE_FOUND,\n      tokenTypes: [currType]\n    }\n  })\n\n  return errors\n}\n\nexport function findModesThatDoNotExist(\n  tokenTypes: TokenType[],\n  validModes: string[]\n): ILexerDefinitionError[] {\n  const invalidModes = filter(tokenTypes, (clazz: any) => {\n    return (\n      clazz.PUSH_MODE !== undefined && !includes(validModes, clazz.PUSH_MODE)\n    )\n  })\n\n  const errors = map(invalidModes, (tokType) => {\n    const msg =\n      `Token Type: ->${tokType.name}<- static 'PUSH_MODE' value cannot refer to a Lexer Mode ->${tokType.PUSH_MODE}<-` +\n      `which does not exist`\n    return {\n      message: msg,\n      type: LexerDefinitionErrorType.PUSH_MODE_DOES_NOT_EXIST,\n      tokenTypes: [tokType]\n    }\n  })\n\n  return errors\n}\n\nexport function findUnreachablePatterns(\n  tokenTypes: TokenType[]\n): ILexerDefinitionError[] {\n  const errors: ILexerDefinitionError[] = []\n\n  const canBeTested = reduce(\n    tokenTypes,\n    (result, tokType, idx) => {\n      const pattern = tokType.PATTERN\n\n      if (pattern === Lexer.NA) {\n        return result\n      }\n\n      // a more comprehensive validation for all forms of regExps would require\n      // deeper regExp analysis capabilities\n      if (isString(pattern)) {\n        result.push({ str: pattern, idx, tokenType: tokType })\n      } else if (isRegExp(pattern) && noMetaChar(pattern)) {\n        result.push({ str: pattern.source, idx, tokenType: tokType })\n      }\n      return result\n    },\n    [] as { str: string; idx: number; tokenType: TokenType }[]\n  )\n\n  forEach(tokenTypes, (tokType, testIdx) => {\n    forEach(canBeTested, ({ str, idx, tokenType }) => {\n      if (testIdx < idx && testTokenType(str, tokType.PATTERN)) {\n        const msg =\n          `Token: ->${tokenType.name}<- can never be matched.\\n` +\n          `Because it appears AFTER the Token Type ->${tokType.name}<-` +\n          `in the lexer's definition.\\n` +\n          `See https://chevrotain.io/docs/guide/resolving_lexer_errors.html#UNREACHABLE`\n        errors.push({\n          message: msg,\n          type: LexerDefinitionErrorType.UNREACHABLE_PATTERN,\n          tokenTypes: [tokType, tokenType]\n        })\n      }\n    })\n  })\n\n  return errors\n}\n\nfunction testTokenType(str: string, pattern: any): boolean {\n  /* istanbul ignore else */\n  if (isRegExp(pattern)) {\n    const regExpArray = pattern.exec(str)\n    return regExpArray !== null && regExpArray.index === 0\n  } else if (isFunction(pattern)) {\n    // maintain the API of custom patterns\n    return pattern(str, 0, [], {})\n  } else if (has(pattern, \"exec\")) {\n    // maintain the API of custom patterns\n    return pattern.exec(str, 0, [], {})\n  } else if (typeof pattern === \"string\") {\n    return pattern === str\n  } else {\n    throw Error(\"non exhaustive match\")\n  }\n}\n\nfunction noMetaChar(regExp: RegExp): boolean {\n  //https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp\n  const metaChars = [\n    \".\",\n    \"\\\\\",\n    \"[\",\n    \"]\",\n    \"|\",\n    \"^\",\n    \"$\",\n    \"(\",\n    \")\",\n    \"?\",\n    \"*\",\n    \"+\",\n    \"{\"\n  ]\n  return (\n    find(metaChars, (char) => regExp.source.indexOf(char) !== -1) === undefined\n  )\n}\n\nexport function addStartOfInput(pattern: RegExp): RegExp {\n  const flags = pattern.ignoreCase ? \"i\" : \"\"\n  // always wrapping in a none capturing group preceded by '^' to make sure matching can only work on start of input.\n  // duplicate/redundant start of input markers have no meaning (/^^^^A/ === /^A/)\n  return new RegExp(`^(?:${pattern.source})`, flags)\n}\n\nexport function addStickyFlag(pattern: RegExp): RegExp {\n  const flags = pattern.ignoreCase ? \"iy\" : \"y\"\n  // always wrapping in a none capturing group preceded by '^' to make sure matching can only work on start of input.\n  // duplicate/redundant start of input markers have no meaning (/^^^^A/ === /^A/)\n  return new RegExp(`${pattern.source}`, flags)\n}\n\nexport function performRuntimeChecks(\n  lexerDefinition: IMultiModeLexerDefinition,\n  trackLines: boolean,\n  lineTerminatorCharacters: (number | string)[]\n): ILexerDefinitionError[] {\n  const errors: ILexerDefinitionError[] = []\n\n  // some run time checks to help the end users.\n  if (!has(lexerDefinition, DEFAULT_MODE)) {\n    errors.push({\n      message:\n        \"A MultiMode Lexer cannot be initialized without a <\" +\n        DEFAULT_MODE +\n        \"> property in its definition\\n\",\n      type: LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE\n    })\n  }\n  if (!has(lexerDefinition, MODES)) {\n    errors.push({\n      message:\n        \"A MultiMode Lexer cannot be initialized without a <\" +\n        MODES +\n        \"> property in its definition\\n\",\n      type: LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY\n    })\n  }\n\n  if (\n    has(lexerDefinition, MODES) &&\n    has(lexerDefinition, DEFAULT_MODE) &&\n    !has(lexerDefinition.modes, lexerDefinition.defaultMode)\n  ) {\n    errors.push({\n      message:\n        `A MultiMode Lexer cannot be initialized with a ${DEFAULT_MODE}: <${lexerDefinition.defaultMode}>` +\n        `which does not exist\\n`,\n      type: LexerDefinitionErrorType.MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST\n    })\n  }\n\n  if (has(lexerDefinition, MODES)) {\n    forEach(lexerDefinition.modes, (currModeValue, currModeName) => {\n      forEach(currModeValue, (currTokType, currIdx) => {\n        if (isUndefined(currTokType)) {\n          errors.push({\n            message:\n              `A Lexer cannot be initialized using an undefined Token Type. Mode:` +\n              `<${currModeName}> at index: <${currIdx}>\\n`,\n            type: LexerDefinitionErrorType.LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED\n          })\n        } else if (has(currTokType, \"LONGER_ALT\")) {\n          const longerAlt = isArray(currTokType.LONGER_ALT)\n            ? currTokType.LONGER_ALT\n            : [currTokType.LONGER_ALT]\n          forEach(longerAlt, (currLongerAlt) => {\n            if (\n              !isUndefined(currLongerAlt) &&\n              !includes(currModeValue, currLongerAlt)\n            ) {\n              errors.push({\n                message: `A MultiMode Lexer cannot be initialized with a longer_alt <${currLongerAlt.name}> on token <${currTokType.name}> outside of mode <${currModeName}>\\n`,\n                type: LexerDefinitionErrorType.MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE\n              })\n            }\n          })\n        }\n      })\n    })\n  }\n\n  return errors\n}\n\nexport function performWarningRuntimeChecks(\n  lexerDefinition: IMultiModeLexerDefinition,\n  trackLines: boolean,\n  lineTerminatorCharacters: (number | string)[]\n): ILexerDefinitionError[] {\n  const warnings = []\n  let hasAnyLineBreak = false\n  const allTokenTypes = compact(flatten(values(lexerDefinition.modes)))\n\n  const concreteTokenTypes = reject(\n    allTokenTypes,\n    (currType) => currType[PATTERN] === Lexer.NA\n  )\n  const terminatorCharCodes = getCharCodes(lineTerminatorCharacters)\n  if (trackLines) {\n    forEach(concreteTokenTypes, (tokType) => {\n      const currIssue = checkLineBreaksIssues(tokType, terminatorCharCodes)\n      if (currIssue !== false) {\n        const message = buildLineBreakIssueMessage(tokType, currIssue)\n        const warningDescriptor = {\n          message,\n          type: currIssue.issue,\n          tokenType: tokType\n        }\n        warnings.push(warningDescriptor)\n      } else {\n        // we don't want to attempt to scan if the user explicitly specified the line_breaks option.\n        if (has(tokType, \"LINE_BREAKS\")) {\n          if (tokType.LINE_BREAKS === true) {\n            hasAnyLineBreak = true\n          }\n        } else {\n          if (\n            canMatchCharCode(terminatorCharCodes, tokType.PATTERN as RegExp)\n          ) {\n            hasAnyLineBreak = true\n          }\n        }\n      }\n    })\n  }\n\n  if (trackLines && !hasAnyLineBreak) {\n    warnings.push({\n      message:\n        \"Warning: No LINE_BREAKS Found.\\n\" +\n        \"\\tThis Lexer has been defined to track line and column information,\\n\" +\n        \"\\tBut none of the Token Types can be identified as matching a line terminator.\\n\" +\n        \"\\tSee https://chevrotain.io/docs/guide/resolving_lexer_errors.html#LINE_BREAKS \\n\" +\n        \"\\tfor details.\",\n      type: LexerDefinitionErrorType.NO_LINE_BREAKS_FLAGS\n    })\n  }\n  return warnings\n}\n\nexport function cloneEmptyGroups(emptyGroups: {\n  [groupName: string]: IToken\n}): { [groupName: string]: IToken } {\n  const clonedResult: any = {}\n  const groupKeys = keys(emptyGroups)\n\n  forEach(groupKeys, (currKey) => {\n    const currGroupValue = emptyGroups[currKey]\n\n    /* istanbul ignore else */\n    if (isArray(currGroupValue)) {\n      clonedResult[currKey] = []\n    } else {\n      throw Error(\"non exhaustive match\")\n    }\n  })\n\n  return clonedResult\n}\n\n// TODO: refactor to avoid duplication\nexport function isCustomPattern(tokenType: TokenType): boolean {\n  const pattern = tokenType.PATTERN\n  /* istanbul ignore else */\n  if (isRegExp(pattern)) {\n    return false\n  } else if (isFunction(pattern)) {\n    // CustomPatternMatcherFunc - custom patterns do not require any transformations, only wrapping in a RegExp Like object\n    return true\n  } else if (has(pattern, \"exec\")) {\n    // ICustomPattern\n    return true\n  } else if (isString(pattern)) {\n    return false\n  } else {\n    throw Error(\"non exhaustive match\")\n  }\n}\n\nexport function isShortPattern(pattern: any): number | false {\n  if (isString(pattern) && pattern.length === 1) {\n    return pattern.charCodeAt(0)\n  } else {\n    return false\n  }\n}\n\n/**\n * Faster than using a RegExp for default newline detection during lexing.\n */\nexport const LineTerminatorOptimizedTester: ILineTerminatorsTester = {\n  // implements /\\n|\\r\\n?/g.test\n  test: function (text) {\n    const len = text.length\n    for (let i = this.lastIndex; i < len; i++) {\n      const c = text.charCodeAt(i)\n      if (c === 10) {\n        this.lastIndex = i + 1\n        return true\n      } else if (c === 13) {\n        if (text.charCodeAt(i + 1) === 10) {\n          this.lastIndex = i + 2\n        } else {\n          this.lastIndex = i + 1\n        }\n        return true\n      }\n    }\n    return false\n  },\n\n  lastIndex: 0\n}\n\nfunction checkLineBreaksIssues(\n  tokType: TokenType,\n  lineTerminatorCharCodes: number[]\n):\n  | {\n      issue:\n        | LexerDefinitionErrorType.IDENTIFY_TERMINATOR\n        | LexerDefinitionErrorType.CUSTOM_LINE_BREAK\n      errMsg?: string\n    }\n  | false {\n  if (has(tokType, \"LINE_BREAKS\")) {\n    // if the user explicitly declared the line_breaks option we will respect their choice\n    // and assume it is correct.\n    return false\n  } else {\n    /* istanbul ignore else */\n    if (isRegExp(tokType.PATTERN)) {\n      try {\n        // TODO: why is the casting suddenly needed?\n        canMatchCharCode(lineTerminatorCharCodes, tokType.PATTERN as RegExp)\n      } catch (e) {\n        /* istanbul ignore next - to test this we would have to mock <canMatchCharCode> to throw an error */\n        return {\n          issue: LexerDefinitionErrorType.IDENTIFY_TERMINATOR,\n          errMsg: (e as Error).message\n        }\n      }\n      return false\n    } else if (isString(tokType.PATTERN)) {\n      // string literal patterns can always be analyzed to detect line terminator usage\n      return false\n    } else if (isCustomPattern(tokType)) {\n      // custom token types\n      return { issue: LexerDefinitionErrorType.CUSTOM_LINE_BREAK }\n    } else {\n      throw Error(\"non exhaustive match\")\n    }\n  }\n}\n\nexport function buildLineBreakIssueMessage(\n  tokType: TokenType,\n  details: {\n    issue:\n      | LexerDefinitionErrorType.IDENTIFY_TERMINATOR\n      | LexerDefinitionErrorType.CUSTOM_LINE_BREAK\n    errMsg?: string\n  }\n): string {\n  /* istanbul ignore else */\n  if (details.issue === LexerDefinitionErrorType.IDENTIFY_TERMINATOR) {\n    return (\n      \"Warning: unable to identify line terminator usage in pattern.\\n\" +\n      `\\tThe problem is in the <${tokType.name}> Token Type\\n` +\n      `\\t Root cause: ${details.errMsg}.\\n` +\n      \"\\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#IDENTIFY_TERMINATOR\"\n    )\n  } else if (details.issue === LexerDefinitionErrorType.CUSTOM_LINE_BREAK) {\n    return (\n      \"Warning: A Custom Token Pattern should specify the <line_breaks> option.\\n\" +\n      `\\tThe problem is in the <${tokType.name}> Token Type\\n` +\n      \"\\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#CUSTOM_LINE_BREAK\"\n    )\n  } else {\n    throw Error(\"non exhaustive match\")\n  }\n}\n\nfunction getCharCodes(charsOrCodes: (number | string)[]): number[] {\n  const charCodes = map(charsOrCodes, (numOrString) => {\n    if (isString(numOrString)) {\n      return numOrString.charCodeAt(0)\n    } else {\n      return numOrString\n    }\n  })\n\n  return charCodes\n}\n\nfunction addToMapOfArrays<T>(\n  map: Record<number, T[]>,\n  key: number,\n  value: T\n): void {\n  if (map[key] === undefined) {\n    map[key] = [value]\n  } else {\n    map[key].push(value)\n  }\n}\n\nexport const minOptimizationVal = 256\n\n/**\n * We are mapping charCode above ASCI (256) into buckets each in the size of 256.\n * This is because ASCI are the most common start chars so each one of those will get its own\n * possible token configs vector.\n *\n * Tokens starting with charCodes \"above\" ASCI are uncommon, so we can \"afford\"\n * to place these into buckets of possible token configs, What we gain from\n * this is avoiding the case of creating an optimization 'charCodeToPatternIdxToConfig'\n * which would contain 10,000+ arrays of small size (e.g unicode Identifiers scenario).\n * Our 'charCodeToPatternIdxToConfig' max size will now be:\n * 256 + (2^16 / 2^8) - 1 === 511\n *\n * note the hack for fast division integer part extraction\n * See: https://stackoverflow.com/a/4228528\n */\nlet charCodeToOptimizedIdxMap: number[] = []\nexport function charCodeToOptimizedIndex(charCode: number): number {\n  return charCode < minOptimizationVal\n    ? charCode\n    : charCodeToOptimizedIdxMap[charCode]\n}\n\n/**\n * This is a compromise between cold start / hot running performance\n * Creating this array takes ~3ms on a modern machine,\n * But if we perform the computation at runtime as needed the CSS Lexer benchmark\n * performance degrades by ~10%\n *\n * TODO: Perhaps it should be lazy initialized only if a charCode > 255 is used.\n */\nfunction initCharCodeToOptimizedIndexMap() {\n  if (isEmpty(charCodeToOptimizedIdxMap)) {\n    charCodeToOptimizedIdxMap = new Array(65536)\n    for (let i = 0; i < 65536; i++) {\n      charCodeToOptimizedIdxMap[i] = i > 255 ? 255 + ~~(i / 255) : i\n    }\n  }\n}\n", "/**\n * Gets the last element of `array`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {Array} array The array to query.\n * @returns {*} Returns the last element of `array`.\n * @example\n *\n * _.last([1, 2, 3]);\n * // => 3\n */\nfunction last(array) {\n  var length = array == null ? 0 : array.length;\n  return length ? array[length - 1] : undefined;\n}\n\nmodule.exports = last;\n", "import isEmpty from \"lodash/isEmpty\"\nimport compact from \"lodash/compact\"\nimport isArray from \"lodash/isArray\"\nimport flatten from \"lodash/flatten\"\nimport difference from \"lodash/difference\"\nimport map from \"lodash/map\"\nimport forEach from \"lodash/forEach\"\nimport has from \"lodash/has\"\nimport includes from \"lodash/includes\"\nimport clone from \"lodash/clone\"\nimport { IToken, TokenType } from \"@chevrotain/types\"\n\nexport function tokenStructuredMatcher(\n  tokInstance: IToken,\n  tokConstructor: TokenType\n) {\n  const instanceType = tokInstance.tokenTypeIdx\n  if (instanceType === tokConstructor.tokenTypeIdx) {\n    return true\n  } else {\n    return (\n      tokConstructor.isParent === true &&\n      tokConstructor.categoryMatchesMap![instanceType] === true\n    )\n  }\n}\n\n// Optimized tokenMatcher in case our grammar does not use token categories\n// Being so tiny it is much more likely to be in-lined and this avoid the function call overhead\nexport function tokenStructuredMatcherNoCategories(\n  token: IToken,\n  tokType: TokenType\n) {\n  return token.tokenTypeIdx === tokType.tokenTypeIdx\n}\n\nexport let tokenShortNameIdx = 1\nexport const tokenIdxToClass: { [tokenIdx: number]: TokenType } = {}\n\nexport function augmentTokenTypes(tokenTypes: TokenType[]): void {\n  // collect the parent Token Types as well.\n  const tokenTypesAndParents = expandCategories(tokenTypes)\n\n  // add required tokenType and categoryMatches properties\n  assignTokenDefaultProps(tokenTypesAndParents)\n\n  // fill up the categoryMatches\n  assignCategoriesMapProp(tokenTypesAndParents)\n  assignCategoriesTokensProp(tokenTypesAndParents)\n\n  forEach(tokenTypesAndParents, (tokType) => {\n    tokType.isParent = tokType.categoryMatches!.length > 0\n  })\n}\n\nexport function expandCategories(tokenTypes: TokenType[]): TokenType[] {\n  let result = clone(tokenTypes)\n\n  let categories = tokenTypes\n  let searching = true\n  while (searching) {\n    categories = compact(\n      flatten(map(categories, (currTokType) => currTokType.CATEGORIES))\n    )\n\n    const newCategories = difference(categories, result)\n\n    result = result.concat(newCategories)\n\n    if (isEmpty(newCategories)) {\n      searching = false\n    } else {\n      categories = newCategories\n    }\n  }\n  return result\n}\n\nexport function assignTokenDefaultProps(tokenTypes: TokenType[]): void {\n  forEach(tokenTypes, (currTokType) => {\n    if (!hasShortKeyProperty(currTokType)) {\n      tokenIdxToClass[tokenShortNameIdx] = currTokType\n      ;(<any>currTokType).tokenTypeIdx = tokenShortNameIdx++\n    }\n\n    // CATEGORIES? : TokenType | TokenType[]\n    if (\n      hasCategoriesProperty(currTokType) &&\n      !isArray(currTokType.CATEGORIES)\n      // &&\n      // !isUndefined(currTokType.CATEGORIES.PATTERN)\n    ) {\n      currTokType.CATEGORIES = [currTokType.CATEGORIES as unknown as TokenType]\n    }\n\n    if (!hasCategoriesProperty(currTokType)) {\n      currTokType.CATEGORIES = []\n    }\n\n    if (!hasExtendingTokensTypesProperty(currTokType)) {\n      currTokType.categoryMatches = []\n    }\n\n    if (!hasExtendingTokensTypesMapProperty(currTokType)) {\n      currTokType.categoryMatchesMap = {}\n    }\n  })\n}\n\nexport function assignCategoriesTokensProp(tokenTypes: TokenType[]): void {\n  forEach(tokenTypes, (currTokType) => {\n    // avoid duplications\n    currTokType.categoryMatches = []\n    forEach(currTokType.categoryMatchesMap!, (val, key) => {\n      currTokType.categoryMatches!.push(\n        tokenIdxToClass[key as unknown as number].tokenTypeIdx!\n      )\n    })\n  })\n}\n\nexport function assignCategoriesMapProp(tokenTypes: TokenType[]): void {\n  forEach(tokenTypes, (currTokType) => {\n    singleAssignCategoriesToksMap([], currTokType)\n  })\n}\n\nexport function singleAssignCategoriesToksMap(\n  path: TokenType[],\n  nextNode: TokenType\n): void {\n  forEach(path, (pathNode) => {\n    nextNode.categoryMatchesMap![pathNode.tokenTypeIdx!] = true\n  })\n\n  forEach(nextNode.CATEGORIES, (nextCategory) => {\n    const newPath = path.concat(nextNode)\n    // avoids infinite loops due to cyclic categories.\n    if (!includes(newPath, nextCategory)) {\n      singleAssignCategoriesToksMap(newPath, nextCategory)\n    }\n  })\n}\n\nexport function hasShortKeyProperty(tokType: TokenType): boolean {\n  return has(tokType, \"tokenTypeIdx\")\n}\n\nexport function hasCategoriesProperty(tokType: TokenType): boolean {\n  return has(tokType, \"CATEGORIES\")\n}\n\nexport function hasExtendingTokensTypesProperty(tokType: TokenType): boolean {\n  return has(tokType, \"categoryMatches\")\n}\n\nexport function hasExtendingTokensTypesMapProperty(\n  tokType: TokenType\n): boolean {\n  return has(tokType, \"categoryMatchesMap\")\n}\n\nexport function isTokenType(tokType: TokenType): boolean {\n  return has(tokType, \"tokenTypeIdx\")\n}\n", "import { ILexerErrorMessageProvider, IToken } from \"@chevrotain/types\"\n\nexport const defaultLexerErrorProvider: ILexerErrorMessageProvider = {\n  buildUnableToPopLexerModeMessage(token: IToken): string {\n    return `Unable to pop Lexer Mode after encountering Token ->${token.image}<- The Mode Stack is empty`\n  },\n\n  buildUnexpectedCharactersMessage(\n    fullText: string,\n    startOffset: number,\n    length: number,\n    line?: number,\n    column?: number\n  ): string {\n    return (\n      `unexpected character: ->${fullText.charAt(\n        startOffset\n      )}<- at offset: ${startOffset},` + ` skipped ${length} characters.`\n    )\n  }\n}\n", "import {\n  analyzeTokenTypes,\n  charCodeToOptimizedIndex,\n  cloneEmptyGroups,\n  DEFAULT_MODE,\n  IAnalyzeResult,\n  IPatternConfig,\n  LineTerminatorOptimizedTester,\n  performRuntimeChecks,\n  performWarningRuntimeChecks,\n  SUPPORT_STICKY,\n  validatePatterns\n} from \"./lexer\"\nimport noop from \"lodash/noop\"\nimport isEmpty from \"lodash/isEmpty\"\nimport isArray from \"lodash/isArray\"\nimport last from \"lodash/last\"\nimport reject from \"lodash/reject\"\nimport map from \"lodash/map\"\nimport forEach from \"lodash/forEach\"\nimport keys from \"lodash/keys\"\nimport isUndefined from \"lodash/isUndefined\"\nimport identity from \"lodash/identity\"\nimport assign from \"lodash/assign\"\nimport reduce from \"lodash/reduce\"\nimport clone from \"lodash/clone\"\nimport { PRINT_WARNING, timer, toFastProperties } from \"@chevrotain/utils\"\nimport { augmentTokenTypes } from \"./tokens\"\nimport {\n  CustomPatternMatcherFunc,\n  CustomPatternMatcherReturn,\n  ILexerConfig,\n  ILexerDefinitionError,\n  ILexingError,\n  IMultiModeLexerDefinition,\n  IToken,\n  TokenType\n} from \"@chevrotain/types\"\nimport { defaultLexerErrorProvider } from \"./lexer_errors_public\"\nimport { clearRegExpParserCache } from \"./reg_exp_parser\"\n\nexport interface ILexingResult {\n  tokens: IToken[]\n  groups: { [groupName: string]: IToken[] }\n  errors: ILexingError[]\n}\n\nexport enum LexerDefinitionErrorType {\n  MISSING_PATTERN,\n  INVALID_PATTERN,\n  EOI_ANCHOR_FOUND,\n  UNSUPPORTED_FLAGS_FOUND,\n  DUPLICATE_PATTERNS_FOUND,\n  INVALID_GROUP_TYPE_FOUND,\n  PUSH_MODE_DOES_NOT_EXIST,\n  MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE,\n  MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY,\n  MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST,\n  LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED,\n  SOI_ANCHOR_FOUND,\n  EMPTY_MATCH_PATTERN,\n  NO_LINE_BREAKS_FLAGS,\n  UNREACHABLE_PATTERN,\n  IDENTIFY_TERMINATOR,\n  CUSTOM_LINE_BREAK,\n  MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE\n}\n\nexport interface IRegExpExec {\n  exec: CustomPatternMatcherFunc\n}\n\nconst DEFAULT_LEXER_CONFIG: Required<ILexerConfig> = {\n  deferDefinitionErrorsHandling: false,\n  positionTracking: \"full\",\n  lineTerminatorsPattern: /\\n|\\r\\n?/g,\n  lineTerminatorCharacters: [\"\\n\", \"\\r\"],\n  ensureOptimizations: false,\n  safeMode: false,\n  errorMessageProvider: defaultLexerErrorProvider,\n  traceInitPerf: false,\n  skipValidations: false,\n  recoveryEnabled: true\n}\n\nObject.freeze(DEFAULT_LEXER_CONFIG)\n\nexport class Lexer {\n  public static SKIPPED =\n    \"This marks a skipped Token pattern, this means each token identified by it will\" +\n    \"be consumed and then thrown into oblivion, this can be used to for example to completely ignore whitespace.\"\n\n  public static NA = /NOT_APPLICABLE/\n  public lexerDefinitionErrors: ILexerDefinitionError[] = []\n  public lexerDefinitionWarning: ILexerDefinitionError[] = []\n\n  protected patternIdxToConfig: Record<string, IPatternConfig[]> = {}\n  protected charCodeToPatternIdxToConfig: {\n    [modeName: string]: { [charCode: number]: IPatternConfig[] }\n  } = {}\n\n  protected modes: string[] = []\n  protected defaultMode!: string\n  protected emptyGroups: { [groupName: string]: IToken } = {}\n\n  private config: Required<ILexerConfig>\n  private trackStartLines: boolean = true\n  private trackEndLines: boolean = true\n  private hasCustom: boolean = false\n  private canModeBeOptimized: Record<string, boolean> = {}\n\n  private traceInitPerf!: boolean | number\n  private traceInitMaxIdent!: number\n  private traceInitIndent: number\n\n  constructor(\n    protected lexerDefinition: TokenType[] | IMultiModeLexerDefinition,\n    config: ILexerConfig = DEFAULT_LEXER_CONFIG\n  ) {\n    if (typeof config === \"boolean\") {\n      throw Error(\n        \"The second argument to the Lexer constructor is now an ILexerConfig Object.\\n\" +\n          \"a boolean 2nd argument is no longer supported\"\n      )\n    }\n\n    // todo: defaults func?\n    this.config = assign({}, DEFAULT_LEXER_CONFIG, config) as any\n\n    const traceInitVal = this.config.traceInitPerf\n    if (traceInitVal === true) {\n      this.traceInitMaxIdent = Infinity\n      this.traceInitPerf = true\n    } else if (typeof traceInitVal === \"number\") {\n      this.traceInitMaxIdent = traceInitVal\n      this.traceInitPerf = true\n    }\n    this.traceInitIndent = -1\n\n    this.TRACE_INIT(\"Lexer Constructor\", () => {\n      let actualDefinition!: IMultiModeLexerDefinition\n      let hasOnlySingleMode = true\n      this.TRACE_INIT(\"Lexer Config handling\", () => {\n        if (\n          this.config.lineTerminatorsPattern ===\n          DEFAULT_LEXER_CONFIG.lineTerminatorsPattern\n        ) {\n          // optimized built-in implementation for the defaults definition of lineTerminators\n          this.config.lineTerminatorsPattern = LineTerminatorOptimizedTester\n        } else {\n          if (\n            this.config.lineTerminatorCharacters ===\n            DEFAULT_LEXER_CONFIG.lineTerminatorCharacters\n          ) {\n            throw Error(\n              \"Error: Missing <lineTerminatorCharacters> property on the Lexer config.\\n\" +\n                \"\\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#MISSING_LINE_TERM_CHARS\"\n            )\n          }\n        }\n\n        if (config.safeMode && config.ensureOptimizations) {\n          throw Error(\n            '\"safeMode\" and \"ensureOptimizations\" flags are mutually exclusive.'\n          )\n        }\n\n        this.trackStartLines = /full|onlyStart/i.test(\n          this.config.positionTracking\n        )\n        this.trackEndLines = /full/i.test(this.config.positionTracking)\n\n        // Convert SingleModeLexerDefinition into a IMultiModeLexerDefinition.\n        if (isArray(lexerDefinition)) {\n          actualDefinition = {\n            modes: { defaultMode: clone(lexerDefinition) },\n            defaultMode: DEFAULT_MODE\n          }\n        } else {\n          // no conversion needed, input should already be a IMultiModeLexerDefinition\n          hasOnlySingleMode = false\n          actualDefinition = clone(<IMultiModeLexerDefinition>lexerDefinition)\n        }\n      })\n\n      if (this.config.skipValidations === false) {\n        this.TRACE_INIT(\"performRuntimeChecks\", () => {\n          this.lexerDefinitionErrors = this.lexerDefinitionErrors.concat(\n            performRuntimeChecks(\n              actualDefinition,\n              this.trackStartLines,\n              this.config.lineTerminatorCharacters\n            )\n          )\n        })\n\n        this.TRACE_INIT(\"performWarningRuntimeChecks\", () => {\n          this.lexerDefinitionWarning = this.lexerDefinitionWarning.concat(\n            performWarningRuntimeChecks(\n              actualDefinition,\n              this.trackStartLines,\n              this.config.lineTerminatorCharacters\n            )\n          )\n        })\n      }\n\n      // for extra robustness to avoid throwing an none informative error message\n      actualDefinition.modes = actualDefinition.modes\n        ? actualDefinition.modes\n        : {}\n\n      // an error of undefined TokenTypes will be detected in \"performRuntimeChecks\" above.\n      // this transformation is to increase robustness in the case of partially invalid lexer definition.\n      forEach(actualDefinition.modes, (currModeValue, currModeName) => {\n        actualDefinition.modes[currModeName] = reject<TokenType>(\n          currModeValue,\n          (currTokType) => isUndefined(currTokType)\n        )\n      })\n\n      const allModeNames = keys(actualDefinition.modes)\n\n      forEach(\n        actualDefinition.modes,\n        (currModDef: TokenType[], currModName) => {\n          this.TRACE_INIT(`Mode: <${currModName}> processing`, () => {\n            this.modes.push(currModName)\n\n            if (this.config.skipValidations === false) {\n              this.TRACE_INIT(`validatePatterns`, () => {\n                this.lexerDefinitionErrors = this.lexerDefinitionErrors.concat(\n                  validatePatterns(currModDef, allModeNames)\n                )\n              })\n            }\n\n            // If definition errors were encountered, the analysis phase may fail unexpectedly/\n            // Considering a lexer with definition errors may never be used, there is no point\n            // to performing the analysis anyhow...\n            if (isEmpty(this.lexerDefinitionErrors)) {\n              augmentTokenTypes(currModDef)\n\n              let currAnalyzeResult!: IAnalyzeResult\n              this.TRACE_INIT(`analyzeTokenTypes`, () => {\n                currAnalyzeResult = analyzeTokenTypes(currModDef, {\n                  lineTerminatorCharacters:\n                    this.config.lineTerminatorCharacters,\n                  positionTracking: config.positionTracking,\n                  ensureOptimizations: config.ensureOptimizations,\n                  safeMode: config.safeMode,\n                  tracer: this.TRACE_INIT\n                })\n              })\n\n              this.patternIdxToConfig[currModName] =\n                currAnalyzeResult.patternIdxToConfig\n\n              this.charCodeToPatternIdxToConfig[currModName] =\n                currAnalyzeResult.charCodeToPatternIdxToConfig\n\n              this.emptyGroups = assign(\n                {},\n                this.emptyGroups,\n                currAnalyzeResult.emptyGroups\n              ) as any\n\n              this.hasCustom = currAnalyzeResult.hasCustom || this.hasCustom\n\n              this.canModeBeOptimized[currModName] =\n                currAnalyzeResult.canBeOptimized\n            }\n          })\n        }\n      )\n\n      this.defaultMode = actualDefinition.defaultMode\n\n      if (\n        !isEmpty(this.lexerDefinitionErrors) &&\n        !this.config.deferDefinitionErrorsHandling\n      ) {\n        const allErrMessages = map(this.lexerDefinitionErrors, (error) => {\n          return error.message\n        })\n        const allErrMessagesString = allErrMessages.join(\n          \"-----------------------\\n\"\n        )\n        throw new Error(\n          \"Errors detected in definition of Lexer:\\n\" + allErrMessagesString\n        )\n      }\n\n      // Only print warning if there are no errors, This will avoid pl\n      forEach(this.lexerDefinitionWarning, (warningDescriptor) => {\n        PRINT_WARNING(warningDescriptor.message)\n      })\n\n      this.TRACE_INIT(\"Choosing sub-methods implementations\", () => {\n        // Choose the relevant internal implementations for this specific parser.\n        // These implementations should be in-lined by the JavaScript engine\n        // to provide optimal performance in each scenario.\n        if (SUPPORT_STICKY) {\n          this.chopInput = <any>identity\n          this.match = this.matchWithTest\n        } else {\n          this.updateLastIndex = noop\n          this.match = this.matchWithExec\n        }\n\n        if (hasOnlySingleMode) {\n          this.handleModes = noop\n        }\n\n        if (this.trackStartLines === false) {\n          this.computeNewColumn = identity\n        }\n\n        if (this.trackEndLines === false) {\n          this.updateTokenEndLineColumnLocation = noop\n        }\n\n        if (/full/i.test(this.config.positionTracking)) {\n          this.createTokenInstance = this.createFullToken\n        } else if (/onlyStart/i.test(this.config.positionTracking)) {\n          this.createTokenInstance = this.createStartOnlyToken\n        } else if (/onlyOffset/i.test(this.config.positionTracking)) {\n          this.createTokenInstance = this.createOffsetOnlyToken\n        } else {\n          throw Error(\n            `Invalid <positionTracking> config option: \"${this.config.positionTracking}\"`\n          )\n        }\n\n        if (this.hasCustom) {\n          this.addToken = this.addTokenUsingPush\n          this.handlePayload = this.handlePayloadWithCustom\n        } else {\n          this.addToken = this.addTokenUsingMemberAccess\n          this.handlePayload = this.handlePayloadNoCustom\n        }\n      })\n\n      this.TRACE_INIT(\"Failed Optimization Warnings\", () => {\n        const unOptimizedModes = reduce(\n          this.canModeBeOptimized,\n          (cannotBeOptimized, canBeOptimized, modeName) => {\n            if (canBeOptimized === false) {\n              cannotBeOptimized.push(modeName)\n            }\n            return cannotBeOptimized\n          },\n          [] as string[]\n        )\n\n        if (config.ensureOptimizations && !isEmpty(unOptimizedModes)) {\n          throw Error(\n            `Lexer Modes: < ${unOptimizedModes.join(\n              \", \"\n            )} > cannot be optimized.\\n` +\n              '\\t Disable the \"ensureOptimizations\" lexer config flag to silently ignore this and run the lexer in an un-optimized mode.\\n' +\n              \"\\t Or inspect the console log for details on how to resolve these issues.\"\n          )\n        }\n      })\n\n      this.TRACE_INIT(\"clearRegExpParserCache\", () => {\n        clearRegExpParserCache()\n      })\n\n      this.TRACE_INIT(\"toFastProperties\", () => {\n        toFastProperties(this)\n      })\n    })\n  }\n\n  public tokenize(\n    text: string,\n    initialMode: string = this.defaultMode\n  ): ILexingResult {\n    if (!isEmpty(this.lexerDefinitionErrors)) {\n      const allErrMessages = map(this.lexerDefinitionErrors, (error) => {\n        return error.message\n      })\n      const allErrMessagesString = allErrMessages.join(\n        \"-----------------------\\n\"\n      )\n      throw new Error(\n        \"Unable to Tokenize because Errors detected in definition of Lexer:\\n\" +\n          allErrMessagesString\n      )\n    }\n\n    return this.tokenizeInternal(text, initialMode)\n  }\n\n  // There is quite a bit of duplication between this and \"tokenizeInternalLazy\"\n  // This is intentional due to performance considerations.\n  // this method also used quite a bit of `!` none null assertions because it is too optimized\n  // for `tsc` to always understand it is \"safe\"\n  private tokenizeInternal(text: string, initialMode: string): ILexingResult {\n    let i,\n      j,\n      k,\n      matchAltImage,\n      longerAlt,\n      matchedImage: string | null,\n      payload,\n      altPayload,\n      imageLength,\n      group,\n      tokType,\n      newToken: IToken,\n      errLength,\n      droppedChar,\n      msg,\n      match\n    const orgText = text\n    const orgLength = orgText.length\n    let offset = 0\n    let matchedTokensIndex = 0\n    // initializing the tokensArray to the \"guessed\" size.\n    // guessing too little will still reduce the number of array re-sizes on pushes.\n    // guessing too large (Tested by guessing x4 too large) may cost a bit more of memory\n    // but would still have a faster runtime by avoiding (All but one) array resizing.\n    const guessedNumberOfTokens = this.hasCustom\n      ? 0 // will break custom token pattern APIs the matchedTokens array will contain undefined elements.\n      : Math.floor(text.length / 10)\n    const matchedTokens = new Array(guessedNumberOfTokens)\n    const errors: ILexingError[] = []\n    let line = this.trackStartLines ? 1 : undefined\n    let column = this.trackStartLines ? 1 : undefined\n    const groups: any = cloneEmptyGroups(this.emptyGroups)\n    const trackLines = this.trackStartLines\n    const lineTerminatorPattern = this.config.lineTerminatorsPattern\n\n    let currModePatternsLength = 0\n    let patternIdxToConfig: IPatternConfig[] = []\n    let currCharCodeToPatternIdxToConfig: {\n      [charCode: number]: IPatternConfig[]\n    } = []\n\n    const modeStack: string[] = []\n\n    const emptyArray: IPatternConfig[] = []\n    Object.freeze(emptyArray)\n    let getPossiblePatterns!: (charCode: number) => IPatternConfig[]\n\n    function getPossiblePatternsSlow() {\n      return patternIdxToConfig\n    }\n\n    function getPossiblePatternsOptimized(charCode: number): IPatternConfig[] {\n      const optimizedCharIdx = charCodeToOptimizedIndex(charCode)\n      const possiblePatterns =\n        currCharCodeToPatternIdxToConfig[optimizedCharIdx]\n      if (possiblePatterns === undefined) {\n        return emptyArray\n      } else {\n        return possiblePatterns\n      }\n    }\n\n    const pop_mode = (popToken: IToken) => {\n      // TODO: perhaps avoid this error in the edge case there is no more input?\n      if (\n        modeStack.length === 1 &&\n        // if we have both a POP_MODE and a PUSH_MODE this is in-fact a \"transition\"\n        // So no error should occur.\n        popToken.tokenType.PUSH_MODE === undefined\n      ) {\n        // if we try to pop the last mode there lexer will no longer have ANY mode.\n        // thus the pop is ignored, an error will be created and the lexer will continue parsing in the previous mode.\n        const msg =\n          this.config.errorMessageProvider.buildUnableToPopLexerModeMessage(\n            popToken\n          )\n\n        errors.push({\n          offset: popToken.startOffset,\n          line: popToken.startLine,\n          column: popToken.startColumn,\n          length: popToken.image.length,\n          message: msg\n        })\n      } else {\n        modeStack.pop()\n        const newMode = last(modeStack)!\n        patternIdxToConfig = this.patternIdxToConfig[newMode]\n        currCharCodeToPatternIdxToConfig =\n          this.charCodeToPatternIdxToConfig[newMode]\n        currModePatternsLength = patternIdxToConfig.length\n        const modeCanBeOptimized =\n          this.canModeBeOptimized[newMode] && this.config.safeMode === false\n\n        if (currCharCodeToPatternIdxToConfig && modeCanBeOptimized) {\n          getPossiblePatterns = getPossiblePatternsOptimized\n        } else {\n          getPossiblePatterns = getPossiblePatternsSlow\n        }\n      }\n    }\n\n    function push_mode(this: Lexer, newMode: string) {\n      modeStack.push(newMode)\n      currCharCodeToPatternIdxToConfig =\n        this.charCodeToPatternIdxToConfig[newMode]\n\n      patternIdxToConfig = this.patternIdxToConfig[newMode]\n      currModePatternsLength = patternIdxToConfig.length\n\n      currModePatternsLength = patternIdxToConfig.length\n      const modeCanBeOptimized =\n        this.canModeBeOptimized[newMode] && this.config.safeMode === false\n\n      if (currCharCodeToPatternIdxToConfig && modeCanBeOptimized) {\n        getPossiblePatterns = getPossiblePatternsOptimized\n      } else {\n        getPossiblePatterns = getPossiblePatternsSlow\n      }\n    }\n\n    // this pattern seems to avoid a V8 de-optimization, although that de-optimization does not\n    // seem to matter performance wise.\n    push_mode.call(this, initialMode)\n\n    let currConfig!: IPatternConfig\n\n    const recoveryEnabled = this.config.recoveryEnabled\n\n    while (offset < orgLength) {\n      matchedImage = null\n\n      const nextCharCode = orgText.charCodeAt(offset)\n      const chosenPatternIdxToConfig = getPossiblePatterns(nextCharCode)\n      const chosenPatternsLength = chosenPatternIdxToConfig.length\n\n      for (i = 0; i < chosenPatternsLength; i++) {\n        currConfig = chosenPatternIdxToConfig[i]\n        const currPattern = currConfig.pattern\n        payload = null\n\n        // manually in-lined because > 600 chars won't be in-lined in V8\n        const singleCharCode = currConfig.short\n        if (singleCharCode !== false) {\n          if (nextCharCode === singleCharCode) {\n            // single character string\n            matchedImage = currPattern as string\n          }\n        } else if (currConfig.isCustom === true) {\n          match = (currPattern as IRegExpExec).exec(\n            orgText,\n            offset,\n            matchedTokens,\n            groups\n          )\n          if (match !== null) {\n            matchedImage = match[0]\n            if ((match as CustomPatternMatcherReturn).payload !== undefined) {\n              payload = (match as CustomPatternMatcherReturn).payload\n            }\n          } else {\n            matchedImage = null\n          }\n        } else {\n          this.updateLastIndex(currPattern as RegExp, offset)\n          matchedImage = this.match(currPattern as RegExp, text, offset)\n        }\n\n        if (matchedImage !== null) {\n          // even though this pattern matched we must try a another longer alternative.\n          // this can be used to prioritize keywords over identifiers\n          longerAlt = currConfig.longerAlt\n          if (longerAlt !== undefined) {\n            // TODO: micro optimize, avoid extra prop access\n            // by saving/linking longerAlt on the original config?\n            const longerAltLength = longerAlt.length\n            for (k = 0; k < longerAltLength; k++) {\n              const longerAltConfig = patternIdxToConfig[longerAlt[k]]\n              const longerAltPattern = longerAltConfig.pattern\n              altPayload = null\n\n              // single Char can never be a longer alt so no need to test it.\n              // manually in-lined because > 600 chars won't be in-lined in V8\n              if (longerAltConfig.isCustom === true) {\n                match = (longerAltPattern as IRegExpExec).exec(\n                  orgText,\n                  offset,\n                  matchedTokens,\n                  groups\n                )\n                if (match !== null) {\n                  matchAltImage = match[0]\n                  if (\n                    (match as CustomPatternMatcherReturn).payload !== undefined\n                  ) {\n                    altPayload = (match as CustomPatternMatcherReturn).payload\n                  }\n                } else {\n                  matchAltImage = null\n                }\n              } else {\n                this.updateLastIndex(longerAltPattern as RegExp, offset)\n                matchAltImage = this.match(\n                  longerAltPattern as RegExp,\n                  text,\n                  offset\n                )\n              }\n\n              if (matchAltImage && matchAltImage.length > matchedImage.length) {\n                matchedImage = matchAltImage\n                payload = altPayload\n                currConfig = longerAltConfig\n                // Exit the loop early after matching one of the longer alternatives\n                // The first matched alternative takes precedence\n                break\n              }\n            }\n          }\n          break\n        }\n      }\n\n      // successful match\n      if (matchedImage !== null) {\n        imageLength = matchedImage.length\n        group = currConfig.group\n        if (group !== undefined) {\n          tokType = currConfig.tokenTypeIdx\n          // TODO: \"offset + imageLength\" and the new column may be computed twice in case of \"full\" location information inside\n          // createFullToken method\n          newToken = this.createTokenInstance(\n            matchedImage,\n            offset,\n            tokType,\n            currConfig.tokenType,\n            line,\n            column,\n            imageLength\n          )\n\n          this.handlePayload(newToken, payload)\n\n          // TODO: optimize NOOP in case there are no special groups?\n          if (group === false) {\n            matchedTokensIndex = this.addToken(\n              matchedTokens,\n              matchedTokensIndex,\n              newToken\n            )\n          } else {\n            groups[group].push(newToken)\n          }\n        }\n        text = this.chopInput(text, imageLength)\n        offset = offset + imageLength\n\n        // TODO: with newlines the column may be assigned twice\n        column = this.computeNewColumn(column!, imageLength)\n\n        if (trackLines === true && currConfig.canLineTerminator === true) {\n          let numOfLTsInMatch = 0\n          let foundTerminator\n          let lastLTEndOffset: number\n          lineTerminatorPattern.lastIndex = 0\n          do {\n            foundTerminator = lineTerminatorPattern.test(matchedImage)\n            if (foundTerminator === true) {\n              lastLTEndOffset = lineTerminatorPattern.lastIndex - 1\n              numOfLTsInMatch++\n            }\n          } while (foundTerminator === true)\n\n          if (numOfLTsInMatch !== 0) {\n            line = line! + numOfLTsInMatch\n            column = imageLength - lastLTEndOffset!\n            this.updateTokenEndLineColumnLocation(\n              newToken!,\n              group!,\n              lastLTEndOffset!,\n              numOfLTsInMatch,\n              line,\n              column,\n              imageLength\n            )\n          }\n        }\n        // will be NOOP if no modes present\n        this.handleModes(currConfig, pop_mode, push_mode, newToken!)\n      } else {\n        // error recovery, drop characters until we identify a valid token's start point\n        const errorStartOffset = offset\n        const errorLine = line\n        const errorColumn = column\n        let foundResyncPoint = recoveryEnabled === false\n\n        while (foundResyncPoint === false && offset < orgLength) {\n          // Identity Func (when sticky flag is enabled)\n          text = this.chopInput(text, 1)\n          offset++\n          for (j = 0; j < currModePatternsLength; j++) {\n            const currConfig = patternIdxToConfig[j]\n            const currPattern = currConfig.pattern\n\n            // manually in-lined because > 600 chars won't be in-lined in V8\n            const singleCharCode = currConfig.short\n            if (singleCharCode !== false) {\n              if (orgText.charCodeAt(offset) === singleCharCode) {\n                // single character string\n                foundResyncPoint = true\n              }\n            } else if (currConfig.isCustom === true) {\n              foundResyncPoint =\n                (currPattern as IRegExpExec).exec(\n                  orgText,\n                  offset,\n                  matchedTokens,\n                  groups\n                ) !== null\n            } else {\n              this.updateLastIndex(currPattern as RegExp, offset)\n              foundResyncPoint = (currPattern as RegExp).exec(text) !== null\n            }\n\n            if (foundResyncPoint === true) {\n              break\n            }\n          }\n        }\n\n        errLength = offset - errorStartOffset\n        // at this point we either re-synced or reached the end of the input text\n        msg = this.config.errorMessageProvider.buildUnexpectedCharactersMessage(\n          orgText,\n          errorStartOffset,\n          errLength,\n          errorLine,\n          errorColumn\n        )\n        errors.push({\n          offset: errorStartOffset,\n          line: errorLine,\n          column: errorColumn,\n          length: errLength,\n          message: msg\n        })\n\n        if (recoveryEnabled === false) {\n          break\n        }\n      }\n    }\n\n    // if we do have custom patterns which push directly into the\n    // TODO: custom tokens should not push directly??\n    if (!this.hasCustom) {\n      // if we guessed a too large size for the tokens array this will shrink it to the right size.\n      matchedTokens.length = matchedTokensIndex\n    }\n\n    return {\n      tokens: matchedTokens,\n      groups: groups,\n      errors: errors\n    }\n  }\n\n  private handleModes(\n    config: IPatternConfig,\n    pop_mode: (tok: IToken) => void,\n    push_mode: (this: Lexer, pushMode: string) => void,\n    newToken: IToken\n  ) {\n    if (config.pop === true) {\n      // need to save the PUSH_MODE property as if the mode is popped\n      // patternIdxToPopMode is updated to reflect the new mode after popping the stack\n      const pushMode = config.push\n      pop_mode(newToken)\n      if (pushMode !== undefined) {\n        push_mode.call(this, pushMode)\n      }\n    } else if (config.push !== undefined) {\n      push_mode.call(this, config.push)\n    }\n  }\n\n  private chopInput(text: string, length: number): string {\n    return text.substring(length)\n  }\n\n  private updateLastIndex(regExp: RegExp, newLastIndex: number): void {\n    regExp.lastIndex = newLastIndex\n  }\n\n  // TODO: decrease this under 600 characters? inspect stripping comments option in TSC compiler\n  private updateTokenEndLineColumnLocation(\n    newToken: IToken,\n    group: string | false,\n    lastLTIdx: number,\n    numOfLTsInMatch: number,\n    line: number,\n    column: number,\n    imageLength: number\n  ): void {\n    let lastCharIsLT, fixForEndingInLT\n    if (group !== undefined) {\n      // a none skipped multi line Token, need to update endLine/endColumn\n      lastCharIsLT = lastLTIdx === imageLength - 1\n      fixForEndingInLT = lastCharIsLT ? -1 : 0\n      if (!(numOfLTsInMatch === 1 && lastCharIsLT === true)) {\n        // if a token ends in a LT that last LT only affects the line numbering of following Tokens\n        newToken.endLine = line + fixForEndingInLT\n        // the last LT in a token does not affect the endColumn either as the [columnStart ... columnEnd)\n        // inclusive to exclusive range.\n        newToken.endColumn = column - 1 + -fixForEndingInLT\n      }\n      // else single LT in the last character of a token, no need to modify the endLine/EndColumn\n    }\n  }\n\n  private computeNewColumn(oldColumn: number, imageLength: number) {\n    return oldColumn + imageLength\n  }\n\n  // Place holder, will be replaced by the correct variant according to the locationTracking option at runtime.\n  /* istanbul ignore next - place holder */\n  private createTokenInstance!: (...args: any[]) => IToken\n\n  private createOffsetOnlyToken(\n    image: string,\n    startOffset: number,\n    tokenTypeIdx: number,\n    tokenType: TokenType\n  ) {\n    return {\n      image,\n      startOffset,\n      tokenTypeIdx,\n      tokenType\n    }\n  }\n\n  private createStartOnlyToken(\n    image: string,\n    startOffset: number,\n    tokenTypeIdx: number,\n    tokenType: TokenType,\n    startLine: number,\n    startColumn: number\n  ) {\n    return {\n      image,\n      startOffset,\n      startLine,\n      startColumn,\n      tokenTypeIdx,\n      tokenType\n    }\n  }\n\n  private createFullToken(\n    image: string,\n    startOffset: number,\n    tokenTypeIdx: number,\n    tokenType: TokenType,\n    startLine: number,\n    startColumn: number,\n    imageLength: number\n  ): IToken {\n    return {\n      image,\n      startOffset,\n      endOffset: startOffset + imageLength - 1,\n      startLine,\n      endLine: startLine,\n      startColumn,\n      endColumn: startColumn + imageLength - 1,\n      tokenTypeIdx,\n      tokenType\n    }\n  }\n\n  // Place holder, will be replaced by the correct variant according to the locationTracking option at runtime.\n  /* istanbul ignore next - place holder */\n  private addToken!: (\n    tokenVector: IToken[],\n    index: number,\n    tokenToAdd: IToken\n  ) => number\n\n  private addTokenUsingPush(\n    tokenVector: IToken[],\n    index: number,\n    tokenToAdd: IToken\n  ): number {\n    tokenVector.push(tokenToAdd)\n    return index\n  }\n\n  private addTokenUsingMemberAccess(\n    tokenVector: IToken[],\n    index: number,\n    tokenToAdd: IToken\n  ): number {\n    tokenVector[index] = tokenToAdd\n    index++\n    return index\n  }\n\n  // Place holder, will be replaced by the correct variant according to the hasCustom flag option at runtime.\n  private handlePayload: (token: IToken, payload: any) => void\n\n  private handlePayloadNoCustom(token: IToken, payload: any): void {}\n\n  private handlePayloadWithCustom(token: IToken, payload: any): void {\n    if (payload !== null) {\n      token.payload = payload\n    }\n  }\n\n  // place holder to be replaced with chosen alternative at runtime\n  private match!: (\n    pattern: RegExp,\n    text: string,\n    offset: number\n  ) => string | null\n\n  private matchWithTest(\n    pattern: RegExp,\n    text: string,\n    offset: number\n  ): string | null {\n    const found = pattern.test(text)\n    if (found === true) {\n      return text.substring(offset, pattern.lastIndex)\n    }\n    return null\n  }\n\n  private matchWithExec(pattern: RegExp, text: string): string | null {\n    const regExpArray = pattern.exec(text)\n    return regExpArray !== null ? regExpArray[0] : null\n  }\n\n  // Duplicated from the parser's perf trace trait to allow future extraction\n  // of the lexer to a separate package.\n  TRACE_INIT = <T>(phaseDesc: string, phaseImpl: () => T): T => {\n    // No need to optimize this using NOOP pattern because\n    // It is not called in a hot spot...\n    if (this.traceInitPerf === true) {\n      this.traceInitIndent++\n      const indent = new Array(this.traceInitIndent + 1).join(\"\\t\")\n      if (this.traceInitIndent < this.traceInitMaxIdent) {\n        console.log(`${indent}--> <${phaseDesc}>`)\n      }\n      const { time, value } = timer(phaseImpl)\n      /* istanbul ignore next - Difficult to reproduce specific performance behavior (>10ms) in tests */\n      const traceMethod = time > 10 ? console.warn : console.log\n      if (this.traceInitIndent < this.traceInitMaxIdent) {\n        traceMethod(`${indent}<-- <${phaseDesc}> time: ${time}ms`)\n      }\n      this.traceInitIndent--\n      return value\n    } else {\n      return phaseImpl()\n    }\n  }\n}\n", "import isString from \"lodash/isString\"\nimport has from \"lodash/has\"\nimport isUndefined from \"lodash/isUndefined\"\nimport { Lexer } from \"./lexer_public\"\nimport { augmentTokenTypes, tokenStructuredMatcher } from \"./tokens\"\nimport { IToken, ITokenConfig, TokenType } from \"@chevrotain/types\"\n\nexport function tokenLabel(tokType: TokenType): string {\n  if (hasTokenLabel(tokType)) {\n    return tokType.LABEL\n  } else {\n    return tokType.name\n  }\n}\n\nexport function tokenName(tokType: TokenType): string {\n  return tokType.name\n}\n\nexport function hasTokenLabel(\n  obj: TokenType\n): obj is TokenType & Pick<Required<TokenType>, \"LABEL\"> {\n  return isString(obj.LABEL) && obj.LABEL !== \"\"\n}\n\nconst PARENT = \"parent\"\nconst CATEGORIES = \"categories\"\nconst LABEL = \"label\"\nconst GROUP = \"group\"\nconst PUSH_MODE = \"push_mode\"\nconst POP_MODE = \"pop_mode\"\nconst LONGER_ALT = \"longer_alt\"\nconst LINE_BREAKS = \"line_breaks\"\nconst START_CHARS_HINT = \"start_chars_hint\"\n\nexport function createToken(config: ITokenConfig): TokenType {\n  return createTokenInternal(config)\n}\n\nfunction createTokenInternal(config: ITokenConfig): TokenType {\n  const pattern = config.pattern\n\n  const tokenType: TokenType = <any>{}\n  tokenType.name = config.name\n\n  if (!isUndefined(pattern)) {\n    tokenType.PATTERN = pattern\n  }\n\n  if (has(config, PARENT)) {\n    throw (\n      \"The parent property is no longer supported.\\n\" +\n      \"See: https://github.com/chevrotain/chevrotain/issues/564#issuecomment-349062346 for details.\"\n    )\n  }\n\n  if (has(config, CATEGORIES)) {\n    // casting to ANY as this will be fixed inside `augmentTokenTypes``\n    tokenType.CATEGORIES = <any>config[CATEGORIES]\n  }\n\n  augmentTokenTypes([tokenType])\n\n  if (has(config, LABEL)) {\n    tokenType.LABEL = config[LABEL]\n  }\n\n  if (has(config, GROUP)) {\n    tokenType.GROUP = config[GROUP]\n  }\n\n  if (has(config, POP_MODE)) {\n    tokenType.POP_MODE = config[POP_MODE]\n  }\n\n  if (has(config, PUSH_MODE)) {\n    tokenType.PUSH_MODE = config[PUSH_MODE]\n  }\n\n  if (has(config, LONGER_ALT)) {\n    tokenType.LONGER_ALT = config[LONGER_ALT]\n  }\n\n  if (has(config, LINE_BREAKS)) {\n    tokenType.LINE_BREAKS = config[LINE_BREAKS]\n  }\n\n  if (has(config, START_CHARS_HINT)) {\n    tokenType.START_CHARS_HINT = config[START_CHARS_HINT]\n  }\n\n  return tokenType\n}\n\nexport const EOF = createToken({ name: \"EOF\", pattern: Lexer.NA })\naugmentTokenTypes([EOF])\n\nexport function createTokenInstance(\n  tokType: TokenType,\n  image: string,\n  startOffset: number,\n  endOffset: number,\n  startLine: number,\n  endLine: number,\n  startColumn: number,\n  endColumn: number\n): IToken {\n  return {\n    image,\n    startOffset,\n    endOffset,\n    startLine,\n    endLine,\n    startColumn,\n    endColumn,\n    tokenTypeIdx: (<any>tokType).tokenTypeIdx,\n    tokenType: tokType\n  }\n}\n\nexport function tokenMatcher(token: IToken, tokType: TokenType): boolean {\n  return tokenStructuredMatcher(token, tokType)\n}\n", "import { hasTokenLabel, tokenLabel } from \"../scan/tokens_public\"\nimport first from \"lodash/first\"\nimport map from \"lodash/map\"\nimport reduce from \"lodash/reduce\"\nimport { Alternation, NonTerminal, Rule, Terminal } from \"@chevrotain/gast\"\nimport { getProductionDslName } from \"@chevrotain/gast\"\nimport {\n  IParserErrorMessageProvider,\n  IProductionWithOccurrence,\n  TokenType\n} from \"@chevrotain/types\"\nimport {\n  IGrammarResolverErrorMessageProvider,\n  IGrammarValidatorErrorMessageProvider\n} from \"./grammar/types\"\n\nexport const defaultParserErrorProvider: IParserErrorMessageProvider = {\n  buildMismatchTokenMessage({ expected, actual, previous, ruleName }): string {\n    const hasLabel = hasTokenLabel(expected)\n    const expectedMsg = hasLabel\n      ? `--> ${tokenLabel(expected)} <--`\n      : `token of type --> ${expected.name} <--`\n\n    const msg = `Expecting ${expectedMsg} but found --> '${actual.image}' <--`\n\n    return msg\n  },\n\n  buildNotAllInputParsedMessage({ firstRedundant, ruleName }): string {\n    return \"Redundant input, expecting EOF but found: \" + firstRedundant.image\n  },\n\n  buildNoViableAltMessage({\n    expectedPathsPerAlt,\n    actual,\n    previous,\n    customUserDescription,\n    ruleName\n  }): string {\n    const errPrefix = \"Expecting: \"\n    // TODO: issue: No Viable Alternative Error may have incomplete details. #502\n    const actualText = first(actual)!.image\n    const errSuffix = \"\\nbut found: '\" + actualText + \"'\"\n\n    if (customUserDescription) {\n      return errPrefix + customUserDescription + errSuffix\n    } else {\n      const allLookAheadPaths = reduce(\n        expectedPathsPerAlt,\n        (result, currAltPaths) => result.concat(currAltPaths),\n        [] as TokenType[][]\n      )\n      const nextValidTokenSequences = map(\n        allLookAheadPaths,\n        (currPath) =>\n          `[${map(currPath, (currTokenType) => tokenLabel(currTokenType)).join(\n            \", \"\n          )}]`\n      )\n      const nextValidSequenceItems = map(\n        nextValidTokenSequences,\n        (itemMsg, idx) => `  ${idx + 1}. ${itemMsg}`\n      )\n      const calculatedDescription = `one of these possible Token sequences:\\n${nextValidSequenceItems.join(\n        \"\\n\"\n      )}`\n\n      return errPrefix + calculatedDescription + errSuffix\n    }\n  },\n\n  buildEarlyExitMessage({\n    expectedIterationPaths,\n    actual,\n    customUserDescription,\n    ruleName\n  }): string {\n    const errPrefix = \"Expecting: \"\n    // TODO: issue: No Viable Alternative Error may have incomplete details. #502\n    const actualText = first(actual)!.image\n    const errSuffix = \"\\nbut found: '\" + actualText + \"'\"\n\n    if (customUserDescription) {\n      return errPrefix + customUserDescription + errSuffix\n    } else {\n      const nextValidTokenSequences = map(\n        expectedIterationPaths,\n        (currPath) =>\n          `[${map(currPath, (currTokenType) => tokenLabel(currTokenType)).join(\n            \",\"\n          )}]`\n      )\n      const calculatedDescription =\n        `expecting at least one iteration which starts with one of these possible Token sequences::\\n  ` +\n        `<${nextValidTokenSequences.join(\" ,\")}>`\n\n      return errPrefix + calculatedDescription + errSuffix\n    }\n  }\n}\n\nObject.freeze(defaultParserErrorProvider)\n\nexport const defaultGrammarResolverErrorProvider: IGrammarResolverErrorMessageProvider =\n  {\n    buildRuleNotFoundError(\n      topLevelRule: Rule,\n      undefinedRule: NonTerminal\n    ): string {\n      const msg =\n        \"Invalid grammar, reference to a rule which is not defined: ->\" +\n        undefinedRule.nonTerminalName +\n        \"<-\\n\" +\n        \"inside top level rule: ->\" +\n        topLevelRule.name +\n        \"<-\"\n      return msg\n    }\n  }\n\nexport const defaultGrammarValidatorErrorProvider: IGrammarValidatorErrorMessageProvider =\n  {\n    buildDuplicateFoundError(\n      topLevelRule: Rule,\n      duplicateProds: IProductionWithOccurrence[]\n    ): string {\n      function getExtraProductionArgument(\n        prod: IProductionWithOccurrence\n      ): string {\n        if (prod instanceof Terminal) {\n          return prod.terminalType.name\n        } else if (prod instanceof NonTerminal) {\n          return prod.nonTerminalName\n        } else {\n          return \"\"\n        }\n      }\n\n      const topLevelName = topLevelRule.name\n      const duplicateProd = first(duplicateProds)!\n      const index = duplicateProd.idx\n      const dslName = getProductionDslName(duplicateProd)\n      const extraArgument = getExtraProductionArgument(duplicateProd)\n\n      const hasExplicitIndex = index > 0\n      let msg = `->${dslName}${hasExplicitIndex ? index : \"\"}<- ${\n        extraArgument ? `with argument: ->${extraArgument}<-` : \"\"\n      }\n                  appears more than once (${\n                    duplicateProds.length\n                  } times) in the top level rule: ->${topLevelName}<-.                  \n                  For further details see: https://chevrotain.io/docs/FAQ.html#NUMERICAL_SUFFIXES \n                  `\n\n      // white space trimming time! better to trim afterwards as it allows to use WELL formatted multi line template strings...\n      msg = msg.replace(/[ \\t]+/g, \" \")\n      msg = msg.replace(/\\s\\s+/g, \"\\n\")\n\n      return msg\n    },\n\n    buildNamespaceConflictError(rule: Rule): string {\n      const errMsg =\n        `Namespace conflict found in grammar.\\n` +\n        `The grammar has both a Terminal(Token) and a Non-Terminal(Rule) named: <${rule.name}>.\\n` +\n        `To resolve this make sure each Terminal and Non-Terminal names are unique\\n` +\n        `This is easy to accomplish by using the convention that Terminal names start with an uppercase letter\\n` +\n        `and Non-Terminal names start with a lower case letter.`\n\n      return errMsg\n    },\n\n    buildAlternationPrefixAmbiguityError(options: {\n      topLevelRule: Rule\n      prefixPath: TokenType[]\n      ambiguityIndices: number[]\n      alternation: Alternation\n    }): string {\n      const pathMsg = map(options.prefixPath, (currTok) =>\n        tokenLabel(currTok)\n      ).join(\", \")\n      const occurrence =\n        options.alternation.idx === 0 ? \"\" : options.alternation.idx\n      const errMsg =\n        `Ambiguous alternatives: <${options.ambiguityIndices.join(\n          \" ,\"\n        )}> due to common lookahead prefix\\n` +\n        `in <OR${occurrence}> inside <${options.topLevelRule.name}> Rule,\\n` +\n        `<${pathMsg}> may appears as a prefix path in all these alternatives.\\n` +\n        `See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#COMMON_PREFIX\\n` +\n        `For Further details.`\n\n      return errMsg\n    },\n\n    buildAlternationAmbiguityError(options: {\n      topLevelRule: Rule\n      prefixPath: TokenType[]\n      ambiguityIndices: number[]\n      alternation: Alternation\n    }): string {\n      const pathMsg = map(options.prefixPath, (currtok) =>\n        tokenLabel(currtok)\n      ).join(\", \")\n      const occurrence =\n        options.alternation.idx === 0 ? \"\" : options.alternation.idx\n      let currMessage =\n        `Ambiguous Alternatives Detected: <${options.ambiguityIndices.join(\n          \" ,\"\n        )}> in <OR${occurrence}>` +\n        ` inside <${options.topLevelRule.name}> Rule,\\n` +\n        `<${pathMsg}> may appears as a prefix path in all these alternatives.\\n`\n\n      currMessage =\n        currMessage +\n        `See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#AMBIGUOUS_ALTERNATIVES\\n` +\n        `For Further details.`\n      return currMessage\n    },\n\n    buildEmptyRepetitionError(options: {\n      topLevelRule: Rule\n      repetition: IProductionWithOccurrence\n    }): string {\n      let dslName = getProductionDslName(options.repetition)\n      if (options.repetition.idx !== 0) {\n        dslName += options.repetition.idx\n      }\n\n      const errMsg =\n        `The repetition <${dslName}> within Rule <${options.topLevelRule.name}> can never consume any tokens.\\n` +\n        `This could lead to an infinite loop.`\n\n      return errMsg\n    },\n\n    // TODO: remove - `errors_public` from nyc.config.js exclude\n    //       once this method is fully removed from this file\n    buildTokenNameError(options: {\n      tokenType: TokenType\n      expectedPattern: RegExp\n    }): string {\n      /* istanbul ignore next */\n      return \"deprecated\"\n    },\n\n    buildEmptyAlternationError(options: {\n      topLevelRule: Rule\n      alternation: Alternation\n      emptyChoiceIdx: number\n    }): string {\n      const errMsg =\n        `Ambiguous empty alternative: <${options.emptyChoiceIdx + 1}>` +\n        ` in <OR${options.alternation.idx}> inside <${options.topLevelRule.name}> Rule.\\n` +\n        `Only the last alternative may be an empty alternative.`\n\n      return errMsg\n    },\n\n    buildTooManyAlternativesError(options: {\n      topLevelRule: Rule\n      alternation: Alternation\n    }): string {\n      const errMsg =\n        `An Alternation cannot have more than 256 alternatives:\\n` +\n        `<OR${options.alternation.idx}> inside <${\n          options.topLevelRule.name\n        }> Rule.\\n has ${\n          options.alternation.definition.length + 1\n        } alternatives.`\n\n      return errMsg\n    },\n\n    buildLeftRecursionError(options: {\n      topLevelRule: Rule\n      leftRecursionPath: Rule[]\n    }): string {\n      const ruleName = options.topLevelRule.name\n      const pathNames = map(\n        options.leftRecursionPath,\n        (currRule) => currRule.name\n      )\n      const leftRecursivePath = `${ruleName} --> ${pathNames\n        .concat([ruleName])\n        .join(\" --> \")}`\n      const errMsg =\n        `Left Recursion found in grammar.\\n` +\n        `rule: <${ruleName}> can be invoked from itself (directly or indirectly)\\n` +\n        `without consuming any Tokens. The grammar path that causes this is: \\n ${leftRecursivePath}\\n` +\n        ` To fix this refactor your grammar to remove the left recursion.\\n` +\n        `see: https://en.wikipedia.org/wiki/LL_parser#Left_factoring.`\n\n      return errMsg\n    },\n\n    // TODO: remove - `errors_public` from nyc.config.js exclude\n    //       once this method is fully removed from this file\n    buildInvalidRuleNameError(options: {\n      topLevelRule: Rule\n      expectedPattern: RegExp\n    }): string {\n      /* istanbul ignore next */\n      return \"deprecated\"\n    },\n\n    buildDuplicateRuleNameError(options: {\n      topLevelRule: Rule | string\n      grammarName: string\n    }): string {\n      let ruleName\n      if (options.topLevelRule instanceof Rule) {\n        ruleName = options.topLevelRule.name\n      } else {\n        ruleName = options.topLevelRule\n      }\n\n      const errMsg = `Duplicate definition, rule: ->${ruleName}<- is already defined in the grammar: ->${options.grammarName}<-`\n\n      return errMsg\n    }\n  }\n", "import {\n  IParserUnresolvedRefDefinitionError,\n  ParserDefinitionErrorType\n} from \"../parser/parser\"\nimport forEach from \"lodash/forEach\"\nimport values from \"lodash/values\"\nimport { NonTerminal, Rule } from \"@chevrotain/gast\"\nimport { GAstVisitor } from \"@chevrotain/gast\"\nimport {\n  IGrammarResolverErrorMessageProvider,\n  IParserDefinitionError\n} from \"./types\"\n\nexport function resolveGrammar(\n  topLevels: Record<string, Rule>,\n  errMsgProvider: IGrammarResolverErrorMessageProvider\n): IParserDefinitionError[] {\n  const refResolver = new GastRefResolverVisitor(topLevels, errMsgProvider)\n  refResolver.resolveRefs()\n  return refResolver.errors\n}\n\nexport class GastRefResolverVisitor extends GAstVisitor {\n  public errors: IParserUnresolvedRefDefinitionError[] = []\n  private currTopLevel: Rule\n\n  constructor(\n    private nameToTopRule: Record<string, Rule>,\n    private errMsgProvider: IGrammarResolverErrorMessageProvider\n  ) {\n    super()\n  }\n\n  public resolveRefs(): void {\n    forEach(values(this.nameToTopRule), (prod) => {\n      this.currTopLevel = prod\n      prod.accept(this)\n    })\n  }\n\n  public visitNonTerminal(node: NonTerminal): void {\n    const ref = this.nameToTopRule[node.nonTerminalName]\n\n    if (!ref) {\n      const msg = this.errMsgProvider.buildRuleNotFoundError(\n        this.currTopLevel,\n        node\n      )\n      this.errors.push({\n        message: msg,\n        type: ParserDefinitionErrorType.UNRESOLVED_SUBRULE_REF,\n        ruleName: this.currTopLevel.name,\n        unresolvedRefName: node.nonTerminalName\n      })\n    } else {\n      node.referencedRule = ref\n    }\n  }\n}\n", "/**\n * A specialized version of `baseAggregator` for arrays.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} setter The function to set `accumulator` values.\n * @param {Function} iteratee The iteratee to transform keys.\n * @param {Object} accumulator The initial aggregated object.\n * @returns {Function} Returns `accumulator`.\n */\nfunction arrayAggregator(array, setter, iteratee, accumulator) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    var value = array[index];\n    setter(accumulator, value, iteratee(value), array);\n  }\n  return accumulator;\n}\n\nmodule.exports = arrayAggregator;\n", "var baseEach = require('./_baseEach');\n\n/**\n * Aggregates elements of `collection` on `accumulator` with keys transformed\n * by `iteratee` and values set by `setter`.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} setter The function to set `accumulator` values.\n * @param {Function} iteratee The iteratee to transform keys.\n * @param {Object} accumulator The initial aggregated object.\n * @returns {Function} Returns `accumulator`.\n */\nfunction baseAggregator(collection, setter, iteratee, accumulator) {\n  baseEach(collection, function(value, key, collection) {\n    setter(accumulator, value, iteratee(value), collection);\n  });\n  return accumulator;\n}\n\nmodule.exports = baseAggregator;\n", "var arrayAggregator = require('./_arrayAggregator'),\n    baseAggregator = require('./_baseAggregator'),\n    baseIteratee = require('./_baseIteratee'),\n    isArray = require('./isArray');\n\n/**\n * Creates a function like `_.groupBy`.\n *\n * @private\n * @param {Function} setter The function to set accumulator values.\n * @param {Function} [initializer] The accumulator object initializer.\n * @returns {Function} Returns the new aggregator function.\n */\nfunction createAggregator(setter, initializer) {\n  return function(collection, iteratee) {\n    var func = isArray(collection) ? arrayAggregator : baseAggregator,\n        accumulator = initializer ? initializer() : {};\n\n    return func(collection, setter, baseIteratee(iteratee, 2), accumulator);\n  };\n}\n\nmodule.exports = createAggregator;\n", "var baseAssignValue = require('./_baseAssignValue'),\n    createAggregator = require('./_createAggregator');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Creates an object composed of keys generated from the results of running\n * each element of `collection` thru `iteratee`. The order of grouped values\n * is determined by the order they occur in `collection`. The corresponding\n * value of each key is an array of elements responsible for generating the\n * key. The iteratee is invoked with one argument: (value).\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [iteratee=_.identity] The iteratee to transform keys.\n * @returns {Object} Returns the composed aggregate object.\n * @example\n *\n * _.groupBy([6.1, 4.2, 6.3], Math.floor);\n * // => { '4': [4.2], '6': [6.1, 6.3] }\n *\n * // The `_.property` iteratee shorthand.\n * _.groupBy(['one', 'two', 'three'], 'length');\n * // => { '3': ['one', 'two'], '5': ['three'] }\n */\nvar groupBy = createAggregator(function(result, value, key) {\n  if (hasOwnProperty.call(result, key)) {\n    result[key].push(value);\n  } else {\n    baseAssignValue(result, key, [value]);\n  }\n});\n\nmodule.exports = groupBy;\n", "var baseFlatten = require('./_baseFlatten'),\n    map = require('./map');\n\n/**\n * Creates a flattened array of values by running each element in `collection`\n * thru `iteratee` and flattening the mapped results. The iteratee is invoked\n * with three arguments: (value, index|key, collection).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n * @returns {Array} Returns the new flattened array.\n * @example\n *\n * function duplicate(n) {\n *   return [n, n];\n * }\n *\n * _.flatMap([1, 2], duplicate);\n * // => [1, 1, 2, 2]\n */\nfunction flatMap(collection, iteratee) {\n  return baseFlatten(map(collection, iteratee), 1);\n}\n\nmodule.exports = flatMap;\n", "var baseSlice = require('./_baseSlice'),\n    toInteger = require('./toInteger');\n\n/**\n * Creates a slice of `array` with `n` elements dropped from the end.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Array\n * @param {Array} array The array to query.\n * @param {number} [n=1] The number of elements to drop.\n * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n * @returns {Array} Returns the slice of `array`.\n * @example\n *\n * _.dropRight([1, 2, 3]);\n * // => [1, 2]\n *\n * _.dropRight([1, 2, 3], 2);\n * // => [1]\n *\n * _.dropRight([1, 2, 3], 5);\n * // => []\n *\n * _.dropRight([1, 2, 3], 0);\n * // => [1, 2, 3]\n */\nfunction dropRight(array, n, guard) {\n  var length = array == null ? 0 : array.length;\n  if (!length) {\n    return [];\n  }\n  n = (guard || n === undefined) ? 1 : toInteger(n);\n  n = length - n;\n  return baseSlice(array, 0, n < 0 ? 0 : n);\n}\n\nmodule.exports = dropRight;\n", "import { RestWalker } from \"./rest\"\nimport _first from \"lodash/first\"\nimport isEmpty from \"lodash/isEmpty\"\nimport dropRight from \"lodash/dropRight\"\nimport drop from \"lodash/drop\"\nimport last from \"lodash/last\"\nimport forEach from \"lodash/forEach\"\nimport clone from \"lodash/clone\"\nimport { first } from \"./first\"\nimport { TokenMatcher } from \"../parser/parser\"\nimport {\n  Alternation,\n  Alternative,\n  NonTerminal,\n  Option,\n  Repetition,\n  RepetitionMandatory,\n  RepetitionMandatoryWithSeparator,\n  RepetitionWithSeparator,\n  Rule,\n  Terminal\n} from \"@chevrotain/gast\"\nimport {\n  IGrammarPath,\n  IProduction,\n  ISyntacticContentAssistPath,\n  IToken,\n  ITokenGrammarPath,\n  TokenType\n} from \"@chevrotain/types\"\n\nexport abstract class AbstractNextPossibleTokensWalker extends RestWalker {\n  protected possibleTokTypes: TokenType[] = []\n  protected ruleStack: string[]\n  protected occurrenceStack: number[]\n\n  protected nextProductionName = \"\"\n  protected nextProductionOccurrence = 0\n  protected found = false\n  protected isAtEndOfPath = false\n\n  constructor(protected topProd: Rule, protected path: IGrammarPath) {\n    super()\n  }\n\n  startWalking(): TokenType[] {\n    this.found = false\n\n    if (this.path.ruleStack[0] !== this.topProd.name) {\n      throw Error(\"The path does not start with the walker's top Rule!\")\n    }\n\n    // immutable for the win\n    this.ruleStack = clone(this.path.ruleStack).reverse() // intelij bug requires assertion\n    this.occurrenceStack = clone(this.path.occurrenceStack).reverse() // intelij bug requires assertion\n\n    // already verified that the first production is valid, we now seek the 2nd production\n    this.ruleStack.pop()\n    this.occurrenceStack.pop()\n\n    this.updateExpectedNext()\n    this.walk(this.topProd)\n\n    return this.possibleTokTypes\n  }\n\n  walk(\n    prod: { definition: IProduction[] },\n    prevRest: IProduction[] = []\n  ): void {\n    // stop scanning once we found the path\n    if (!this.found) {\n      super.walk(prod, prevRest)\n    }\n  }\n\n  walkProdRef(\n    refProd: NonTerminal,\n    currRest: IProduction[],\n    prevRest: IProduction[]\n  ): void {\n    // found the next production, need to keep walking in it\n    if (\n      refProd.referencedRule.name === this.nextProductionName &&\n      refProd.idx === this.nextProductionOccurrence\n    ) {\n      const fullRest = currRest.concat(prevRest)\n      this.updateExpectedNext()\n      this.walk(refProd.referencedRule, <any>fullRest)\n    }\n  }\n\n  updateExpectedNext(): void {\n    // need to consume the Terminal\n    if (isEmpty(this.ruleStack)) {\n      // must reset nextProductionXXX to avoid walking down another Top Level production while what we are\n      // really seeking is the last Terminal...\n      this.nextProductionName = \"\"\n      this.nextProductionOccurrence = 0\n      this.isAtEndOfPath = true\n    } else {\n      this.nextProductionName = this.ruleStack.pop()!\n      this.nextProductionOccurrence = this.occurrenceStack.pop()!\n    }\n  }\n}\n\nexport class NextAfterTokenWalker extends AbstractNextPossibleTokensWalker {\n  private nextTerminalName = \"\"\n  private nextTerminalOccurrence = 0\n\n  constructor(topProd: Rule, protected path: ITokenGrammarPath) {\n    super(topProd, path)\n    this.nextTerminalName = this.path.lastTok.name\n    this.nextTerminalOccurrence = this.path.lastTokOccurrence\n  }\n\n  walkTerminal(\n    terminal: Terminal,\n    currRest: IProduction[],\n    prevRest: IProduction[]\n  ): void {\n    if (\n      this.isAtEndOfPath &&\n      terminal.terminalType.name === this.nextTerminalName &&\n      terminal.idx === this.nextTerminalOccurrence &&\n      !this.found\n    ) {\n      const fullRest = currRest.concat(prevRest)\n      const restProd = new Alternative({ definition: fullRest })\n      this.possibleTokTypes = first(restProd)\n      this.found = true\n    }\n  }\n}\n\nexport type AlternativesFirstTokens = TokenType[][]\n\nexport interface IFirstAfterRepetition {\n  token: TokenType | undefined\n  occurrence: number | undefined\n  isEndOfRule: boolean | undefined\n}\n\n/**\n * This walker only \"walks\" a single \"TOP\" level in the Grammar Ast, this means\n * it never \"follows\" production refs\n */\nexport class AbstractNextTerminalAfterProductionWalker extends RestWalker {\n  protected result: IFirstAfterRepetition = {\n    token: undefined,\n    occurrence: undefined,\n    isEndOfRule: undefined\n  }\n\n  constructor(protected topRule: Rule, protected occurrence: number) {\n    super()\n  }\n\n  startWalking(): IFirstAfterRepetition {\n    this.walk(this.topRule)\n    return this.result\n  }\n}\n\nexport class NextTerminalAfterManyWalker extends AbstractNextTerminalAfterProductionWalker {\n  walkMany(\n    manyProd: Repetition,\n    currRest: IProduction[],\n    prevRest: IProduction[]\n  ): void {\n    if (manyProd.idx === this.occurrence) {\n      const firstAfterMany = _first(currRest.concat(prevRest))\n      this.result.isEndOfRule = firstAfterMany === undefined\n      if (firstAfterMany instanceof Terminal) {\n        this.result.token = firstAfterMany.terminalType\n        this.result.occurrence = firstAfterMany.idx\n      }\n    } else {\n      super.walkMany(manyProd, currRest, prevRest)\n    }\n  }\n}\n\nexport class NextTerminalAfterManySepWalker extends AbstractNextTerminalAfterProductionWalker {\n  walkManySep(\n    manySepProd: RepetitionWithSeparator,\n    currRest: IProduction[],\n    prevRest: IProduction[]\n  ): void {\n    if (manySepProd.idx === this.occurrence) {\n      const firstAfterManySep = _first(currRest.concat(prevRest))\n      this.result.isEndOfRule = firstAfterManySep === undefined\n      if (firstAfterManySep instanceof Terminal) {\n        this.result.token = firstAfterManySep.terminalType\n        this.result.occurrence = firstAfterManySep.idx\n      }\n    } else {\n      super.walkManySep(manySepProd, currRest, prevRest)\n    }\n  }\n}\n\nexport class NextTerminalAfterAtLeastOneWalker extends AbstractNextTerminalAfterProductionWalker {\n  walkAtLeastOne(\n    atLeastOneProd: RepetitionMandatory,\n    currRest: IProduction[],\n    prevRest: IProduction[]\n  ): void {\n    if (atLeastOneProd.idx === this.occurrence) {\n      const firstAfterAtLeastOne = _first(currRest.concat(prevRest))\n      this.result.isEndOfRule = firstAfterAtLeastOne === undefined\n      if (firstAfterAtLeastOne instanceof Terminal) {\n        this.result.token = firstAfterAtLeastOne.terminalType\n        this.result.occurrence = firstAfterAtLeastOne.idx\n      }\n    } else {\n      super.walkAtLeastOne(atLeastOneProd, currRest, prevRest)\n    }\n  }\n}\n\n// TODO: reduce code duplication in the AfterWalkers\nexport class NextTerminalAfterAtLeastOneSepWalker extends AbstractNextTerminalAfterProductionWalker {\n  walkAtLeastOneSep(\n    atleastOneSepProd: RepetitionMandatoryWithSeparator,\n    currRest: IProduction[],\n    prevRest: IProduction[]\n  ): void {\n    if (atleastOneSepProd.idx === this.occurrence) {\n      const firstAfterfirstAfterAtLeastOneSep = _first(\n        currRest.concat(prevRest)\n      )\n      this.result.isEndOfRule = firstAfterfirstAfterAtLeastOneSep === undefined\n      if (firstAfterfirstAfterAtLeastOneSep instanceof Terminal) {\n        this.result.token = firstAfterfirstAfterAtLeastOneSep.terminalType\n        this.result.occurrence = firstAfterfirstAfterAtLeastOneSep.idx\n      }\n    } else {\n      super.walkAtLeastOneSep(atleastOneSepProd, currRest, prevRest)\n    }\n  }\n}\n\nexport interface PartialPathAndSuffixes {\n  partialPath: TokenType[]\n  suffixDef: IProduction[]\n}\n\nexport function possiblePathsFrom(\n  targetDef: IProduction[],\n  maxLength: number,\n  currPath: TokenType[] = []\n): PartialPathAndSuffixes[] {\n  // avoid side effects\n  currPath = clone(currPath)\n  let result: PartialPathAndSuffixes[] = []\n  let i = 0\n\n  // TODO: avoid inner funcs\n  function remainingPathWith(nextDef: IProduction[]) {\n    return nextDef.concat(drop(targetDef, i + 1))\n  }\n\n  // TODO: avoid inner funcs\n  function getAlternativesForProd(definition: IProduction[]) {\n    const alternatives = possiblePathsFrom(\n      remainingPathWith(definition),\n      maxLength,\n      currPath\n    )\n    return result.concat(alternatives)\n  }\n\n  /**\n   * Mandatory productions will halt the loop as the paths computed from their recursive calls will already contain the\n   * following (rest) of the targetDef.\n   *\n   * For optional productions (Option/Repetition/...) the loop will continue to represent the paths that do not include the\n   * the optional production.\n   */\n  while (currPath.length < maxLength && i < targetDef.length) {\n    const prod = targetDef[i]\n\n    /* istanbul ignore else */\n    if (prod instanceof Alternative) {\n      return getAlternativesForProd(prod.definition)\n    } else if (prod instanceof NonTerminal) {\n      return getAlternativesForProd(prod.definition)\n    } else if (prod instanceof Option) {\n      result = getAlternativesForProd(prod.definition)\n    } else if (prod instanceof RepetitionMandatory) {\n      const newDef = prod.definition.concat([\n        new Repetition({\n          definition: prod.definition\n        })\n      ])\n      return getAlternativesForProd(newDef)\n    } else if (prod instanceof RepetitionMandatoryWithSeparator) {\n      const newDef = [\n        new Alternative({ definition: prod.definition }),\n        new Repetition({\n          definition: [new Terminal({ terminalType: prod.separator })].concat(\n            <any>prod.definition\n          )\n        })\n      ]\n      return getAlternativesForProd(newDef)\n    } else if (prod instanceof RepetitionWithSeparator) {\n      const newDef = prod.definition.concat([\n        new Repetition({\n          definition: [new Terminal({ terminalType: prod.separator })].concat(\n            <any>prod.definition\n          )\n        })\n      ])\n      result = getAlternativesForProd(newDef)\n    } else if (prod instanceof Repetition) {\n      const newDef = prod.definition.concat([\n        new Repetition({\n          definition: prod.definition\n        })\n      ])\n      result = getAlternativesForProd(newDef)\n    } else if (prod instanceof Alternation) {\n      forEach(prod.definition, (currAlt) => {\n        // TODO: this is a limited check for empty alternatives\n        //   It would prevent a common case of infinite loops during parser initialization.\n        //   However **in-directly** empty alternatives may still cause issues.\n        if (isEmpty(currAlt.definition) === false) {\n          result = getAlternativesForProd(currAlt.definition)\n        }\n      })\n      return result\n    } else if (prod instanceof Terminal) {\n      currPath.push(prod.terminalType)\n    } else {\n      throw Error(\"non exhaustive match\")\n    }\n\n    i++\n  }\n  result.push({\n    partialPath: currPath,\n    suffixDef: drop(targetDef, i)\n  })\n\n  return result\n}\n\ninterface IPathToExamine {\n  idx: number\n  def: IProduction[]\n  ruleStack: string[]\n  occurrenceStack: number[]\n}\n\nexport function nextPossibleTokensAfter(\n  initialDef: IProduction[],\n  tokenVector: IToken[],\n  tokMatcher: TokenMatcher,\n  maxLookAhead: number\n): ISyntacticContentAssistPath[] {\n  const EXIT_NON_TERMINAL: any = \"EXIT_NONE_TERMINAL\"\n  // to avoid creating a new Array each time.\n  const EXIT_NON_TERMINAL_ARR = [EXIT_NON_TERMINAL]\n  const EXIT_ALTERNATIVE: any = \"EXIT_ALTERNATIVE\"\n  let foundCompletePath = false\n\n  const tokenVectorLength = tokenVector.length\n  const minimalAlternativesIndex = tokenVectorLength - maxLookAhead - 1\n\n  const result: ISyntacticContentAssistPath[] = []\n\n  const possiblePaths: IPathToExamine[] = []\n  possiblePaths.push({\n    idx: -1,\n    def: initialDef,\n    ruleStack: [],\n    occurrenceStack: []\n  })\n\n  while (!isEmpty(possiblePaths)) {\n    const currPath = possiblePaths.pop()!\n\n    // skip alternatives if no more results can be found (assuming deterministic grammar with fixed lookahead)\n    if (currPath === EXIT_ALTERNATIVE) {\n      if (\n        foundCompletePath &&\n        last(possiblePaths)!.idx <= minimalAlternativesIndex\n      ) {\n        // remove irrelevant alternative\n        possiblePaths.pop()\n      }\n      continue\n    }\n\n    const currDef = currPath.def\n    const currIdx = currPath.idx\n    const currRuleStack = currPath.ruleStack\n    const currOccurrenceStack = currPath.occurrenceStack\n\n    // For Example: an empty path could exist in a valid grammar in the case of an EMPTY_ALT\n    if (isEmpty(currDef)) {\n      continue\n    }\n\n    const prod = currDef[0]\n    /* istanbul ignore else */\n    if (prod === EXIT_NON_TERMINAL) {\n      const nextPath = {\n        idx: currIdx,\n        def: drop(currDef),\n        ruleStack: dropRight(currRuleStack),\n        occurrenceStack: dropRight(currOccurrenceStack)\n      }\n      possiblePaths.push(nextPath)\n    } else if (prod instanceof Terminal) {\n      /* istanbul ignore else */\n      if (currIdx < tokenVectorLength - 1) {\n        const nextIdx = currIdx + 1\n        const actualToken = tokenVector[nextIdx]\n        if (tokMatcher!(actualToken, prod.terminalType)) {\n          const nextPath = {\n            idx: nextIdx,\n            def: drop(currDef),\n            ruleStack: currRuleStack,\n            occurrenceStack: currOccurrenceStack\n          }\n          possiblePaths.push(nextPath)\n        }\n        // end of the line\n      } else if (currIdx === tokenVectorLength - 1) {\n        // IGNORE ABOVE ELSE\n        result.push({\n          nextTokenType: prod.terminalType,\n          nextTokenOccurrence: prod.idx,\n          ruleStack: currRuleStack,\n          occurrenceStack: currOccurrenceStack\n        })\n        foundCompletePath = true\n      } else {\n        throw Error(\"non exhaustive match\")\n      }\n    } else if (prod instanceof NonTerminal) {\n      const newRuleStack = clone(currRuleStack)\n      newRuleStack.push(prod.nonTerminalName)\n\n      const newOccurrenceStack = clone(currOccurrenceStack)\n      newOccurrenceStack.push(prod.idx)\n\n      const nextPath = {\n        idx: currIdx,\n        def: prod.definition.concat(EXIT_NON_TERMINAL_ARR, drop(currDef)),\n        ruleStack: newRuleStack,\n        occurrenceStack: newOccurrenceStack\n      }\n      possiblePaths.push(nextPath)\n    } else if (prod instanceof Option) {\n      // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n      const nextPathWithout = {\n        idx: currIdx,\n        def: drop(currDef),\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      }\n      possiblePaths.push(nextPathWithout)\n      // required marker to avoid backtracking paths whose higher priority alternatives already matched\n      possiblePaths.push(EXIT_ALTERNATIVE)\n\n      const nextPathWith = {\n        idx: currIdx,\n        def: prod.definition.concat(drop(currDef)),\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      }\n      possiblePaths.push(nextPathWith)\n    } else if (prod instanceof RepetitionMandatory) {\n      // TODO:(THE NEW operators here take a while...) (convert once?)\n      const secondIteration = new Repetition({\n        definition: prod.definition,\n        idx: prod.idx\n      })\n      const nextDef = prod.definition.concat([secondIteration], drop(currDef))\n      const nextPath = {\n        idx: currIdx,\n        def: nextDef,\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      }\n      possiblePaths.push(nextPath)\n    } else if (prod instanceof RepetitionMandatoryWithSeparator) {\n      // TODO:(THE NEW operators here take a while...) (convert once?)\n      const separatorGast = new Terminal({\n        terminalType: prod.separator\n      })\n      const secondIteration = new Repetition({\n        definition: [<any>separatorGast].concat(prod.definition),\n        idx: prod.idx\n      })\n      const nextDef = prod.definition.concat([secondIteration], drop(currDef))\n      const nextPath = {\n        idx: currIdx,\n        def: nextDef,\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      }\n      possiblePaths.push(nextPath)\n    } else if (prod instanceof RepetitionWithSeparator) {\n      // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n      const nextPathWithout = {\n        idx: currIdx,\n        def: drop(currDef),\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      }\n      possiblePaths.push(nextPathWithout)\n      // required marker to avoid backtracking paths whose higher priority alternatives already matched\n      possiblePaths.push(EXIT_ALTERNATIVE)\n\n      const separatorGast = new Terminal({\n        terminalType: prod.separator\n      })\n      const nthRepetition = new Repetition({\n        definition: [<any>separatorGast].concat(prod.definition),\n        idx: prod.idx\n      })\n      const nextDef = prod.definition.concat([nthRepetition], drop(currDef))\n      const nextPathWith = {\n        idx: currIdx,\n        def: nextDef,\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      }\n      possiblePaths.push(nextPathWith)\n    } else if (prod instanceof Repetition) {\n      // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n      const nextPathWithout = {\n        idx: currIdx,\n        def: drop(currDef),\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      }\n      possiblePaths.push(nextPathWithout)\n      // required marker to avoid backtracking paths whose higher priority alternatives already matched\n      possiblePaths.push(EXIT_ALTERNATIVE)\n\n      // TODO: an empty repetition will cause infinite loops here, will the parser detect this in selfAnalysis?\n      const nthRepetition = new Repetition({\n        definition: prod.definition,\n        idx: prod.idx\n      })\n      const nextDef = prod.definition.concat([nthRepetition], drop(currDef))\n      const nextPathWith = {\n        idx: currIdx,\n        def: nextDef,\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      }\n      possiblePaths.push(nextPathWith)\n    } else if (prod instanceof Alternation) {\n      // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n      for (let i = prod.definition.length - 1; i >= 0; i--) {\n        const currAlt: any = prod.definition[i]\n        const currAltPath = {\n          idx: currIdx,\n          def: currAlt.definition.concat(drop(currDef)),\n          ruleStack: currRuleStack,\n          occurrenceStack: currOccurrenceStack\n        }\n        possiblePaths.push(currAltPath)\n        possiblePaths.push(EXIT_ALTERNATIVE)\n      }\n    } else if (prod instanceof Alternative) {\n      possiblePaths.push({\n        idx: currIdx,\n        def: prod.definition.concat(drop(currDef)),\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      })\n    } else if (prod instanceof Rule) {\n      // last because we should only encounter at most a single one of these per invocation.\n      possiblePaths.push(\n        expandTopLevelRule(prod, currIdx, currRuleStack, currOccurrenceStack)\n      )\n    } else {\n      throw Error(\"non exhaustive match\")\n    }\n  }\n  return result\n}\n\nfunction expandTopLevelRule(\n  topRule: Rule,\n  currIdx: number,\n  currRuleStack: string[],\n  currOccurrenceStack: number[]\n): IPathToExamine {\n  const newRuleStack = clone(currRuleStack)\n  newRuleStack.push(topRule.name)\n\n  const newCurrOccurrenceStack = clone(currOccurrenceStack)\n  // top rule is always assumed to have been called with occurrence index 1\n  newCurrOccurrenceStack.push(1)\n\n  return {\n    idx: currIdx,\n    def: topRule.definition,\n    ruleStack: newRuleStack,\n    occurrenceStack: newCurrOccurrenceStack\n  }\n}\n", "import isEmpty from \"lodash/isEmpty\"\nimport flatten from \"lodash/flatten\"\nimport every from \"lodash/every\"\nimport map from \"lodash/map\"\nimport forEach from \"lodash/forEach\"\nimport has from \"lodash/has\"\nimport reduce from \"lodash/reduce\"\nimport { possiblePathsFrom } from \"./interpreter\"\nimport { RestWalker } from \"./rest\"\nimport { Predicate, TokenMatcher } from \"../parser/parser\"\nimport {\n  tokenStructuredMatcher,\n  tokenStructuredMatcherNoCategories\n} from \"../../scan/tokens\"\nimport {\n  Alternation,\n  Alternative as AlternativeGAST,\n  Option,\n  Repetition,\n  RepetitionMandatory,\n  RepetitionMandatoryWithSeparator,\n  RepetitionWithSeparator\n} from \"@chevrotain/gast\"\nimport { GAstVisitor } from \"@chevrotain/gast\"\nimport {\n  IOrAlt,\n  IProduction,\n  IProductionWithOccurrence,\n  LookaheadSequence,\n  LookaheadProductionType,\n  Rule,\n  TokenType,\n  BaseParser\n} from \"@chevrotain/types\"\n\nexport enum PROD_TYPE {\n  OPTION,\n  REPETITION,\n  REPETITION_MANDATORY,\n  REPETITION_MANDATORY_WITH_SEPARATOR,\n  REPETITION_WITH_SEPARATOR,\n  ALTERNATION\n}\n\nexport function getProdType(\n  prod: IProduction | LookaheadProductionType\n): PROD_TYPE {\n  /* istanbul ignore else */\n  if (prod instanceof Option || prod === \"Option\") {\n    return PROD_TYPE.OPTION\n  } else if (prod instanceof Repetition || prod === \"Repetition\") {\n    return PROD_TYPE.REPETITION\n  } else if (\n    prod instanceof RepetitionMandatory ||\n    prod === \"RepetitionMandatory\"\n  ) {\n    return PROD_TYPE.REPETITION_MANDATORY\n  } else if (\n    prod instanceof RepetitionMandatoryWithSeparator ||\n    prod === \"RepetitionMandatoryWithSeparator\"\n  ) {\n    return PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR\n  } else if (\n    prod instanceof RepetitionWithSeparator ||\n    prod === \"RepetitionWithSeparator\"\n  ) {\n    return PROD_TYPE.REPETITION_WITH_SEPARATOR\n  } else if (prod instanceof Alternation || prod === \"Alternation\") {\n    return PROD_TYPE.ALTERNATION\n  } else {\n    throw Error(\"non exhaustive match\")\n  }\n}\n\nexport function getLookaheadPaths(options: {\n  occurrence: number\n  rule: Rule\n  prodType: LookaheadProductionType\n  maxLookahead: number\n}): LookaheadSequence[] {\n  const { occurrence, rule, prodType, maxLookahead } = options\n  const type = getProdType(prodType)\n  if (type === PROD_TYPE.ALTERNATION) {\n    return getLookaheadPathsForOr(occurrence, rule, maxLookahead)\n  } else {\n    return getLookaheadPathsForOptionalProd(\n      occurrence,\n      rule,\n      type,\n      maxLookahead\n    )\n  }\n}\n\nexport function buildLookaheadFuncForOr(\n  occurrence: number,\n  ruleGrammar: Rule,\n  maxLookahead: number,\n  hasPredicates: boolean,\n  dynamicTokensEnabled: boolean,\n  laFuncBuilder: Function\n): (orAlts?: IOrAlt<any>[]) => number | undefined {\n  const lookAheadPaths = getLookaheadPathsForOr(\n    occurrence,\n    ruleGrammar,\n    maxLookahead\n  )\n\n  const tokenMatcher = areTokenCategoriesNotUsed(lookAheadPaths)\n    ? tokenStructuredMatcherNoCategories\n    : tokenStructuredMatcher\n\n  return laFuncBuilder(\n    lookAheadPaths,\n    hasPredicates,\n    tokenMatcher,\n    dynamicTokensEnabled\n  )\n}\n\n/**\n *  When dealing with an Optional production (OPTION/MANY/2nd iteration of AT_LEAST_ONE/...) we need to compare\n *  the lookahead \"inside\" the production and the lookahead immediately \"after\" it in the same top level rule (context free).\n *\n *  Example: given a production:\n *  ABC(DE)?DF\n *\n *  The optional '(DE)?' should only be entered if we see 'DE'. a single Token 'D' is not sufficient to distinguish between the two\n *  alternatives.\n *\n *  @returns A Lookahead function which will return true IFF the parser should parse the Optional production.\n */\nexport function buildLookaheadFuncForOptionalProd(\n  occurrence: number,\n  ruleGrammar: Rule,\n  k: number,\n  dynamicTokensEnabled: boolean,\n  prodType: PROD_TYPE,\n  lookaheadBuilder: (\n    lookAheadSequence: LookaheadSequence,\n    tokenMatcher: TokenMatcher,\n    dynamicTokensEnabled: boolean\n  ) => () => boolean\n): () => boolean {\n  const lookAheadPaths = getLookaheadPathsForOptionalProd(\n    occurrence,\n    ruleGrammar,\n    prodType,\n    k\n  )\n\n  const tokenMatcher = areTokenCategoriesNotUsed(lookAheadPaths)\n    ? tokenStructuredMatcherNoCategories\n    : tokenStructuredMatcher\n\n  return lookaheadBuilder(lookAheadPaths[0], tokenMatcher, dynamicTokensEnabled)\n}\n\nexport type Alternative = TokenType[][]\n\nexport function buildAlternativesLookAheadFunc(\n  alts: LookaheadSequence[],\n  hasPredicates: boolean,\n  tokenMatcher: TokenMatcher,\n  dynamicTokensEnabled: boolean\n): (orAlts: IOrAlt<any>[]) => number | undefined {\n  const numOfAlts = alts.length\n  const areAllOneTokenLookahead = every(alts, (currAlt) => {\n    return every(currAlt, (currPath) => {\n      return currPath.length === 1\n    })\n  })\n\n  // This version takes into account the predicates as well.\n  if (hasPredicates) {\n    /**\n     * @returns {number} - The chosen alternative index\n     */\n    return function (\n      this: BaseParser,\n      orAlts: IOrAlt<any>[]\n    ): number | undefined {\n      // unfortunately the predicates must be extracted every single time\n      // as they cannot be cached due to references to parameters(vars) which are no longer valid.\n      // note that in the common case of no predicates, no cpu time will be wasted on this (see else block)\n      const predicates: (Predicate | undefined)[] = map(\n        orAlts,\n        (currAlt) => currAlt.GATE\n      )\n\n      for (let t = 0; t < numOfAlts; t++) {\n        const currAlt = alts[t]\n        const currNumOfPaths = currAlt.length\n\n        const currPredicate = predicates[t]\n        if (currPredicate !== undefined && currPredicate.call(this) === false) {\n          // if the predicate does not match there is no point in checking the paths\n          continue\n        }\n        nextPath: for (let j = 0; j < currNumOfPaths; j++) {\n          const currPath = currAlt[j]\n          const currPathLength = currPath.length\n          for (let i = 0; i < currPathLength; i++) {\n            const nextToken = this.LA(i + 1)\n            if (tokenMatcher(nextToken, currPath[i]) === false) {\n              // mismatch in current path\n              // try the next pth\n              continue nextPath\n            }\n          }\n          // found a full path that matches.\n          // this will also work for an empty ALT as the loop will be skipped\n          return t\n        }\n        // none of the paths for the current alternative matched\n        // try the next alternative\n      }\n      // none of the alternatives could be matched\n      return undefined\n    }\n  } else if (areAllOneTokenLookahead && !dynamicTokensEnabled) {\n    // optimized (common) case of all the lookaheads paths requiring only\n    // a single token lookahead. These Optimizations cannot work if dynamically defined Tokens are used.\n    const singleTokenAlts = map(alts, (currAlt) => {\n      return flatten(currAlt)\n    })\n\n    const choiceToAlt = reduce(\n      singleTokenAlts,\n      (result, currAlt, idx) => {\n        forEach(currAlt, (currTokType) => {\n          if (!has(result, currTokType.tokenTypeIdx!)) {\n            result[currTokType.tokenTypeIdx!] = idx\n          }\n          forEach(currTokType.categoryMatches!, (currExtendingType) => {\n            if (!has(result, currExtendingType)) {\n              result[currExtendingType] = idx\n            }\n          })\n        })\n        return result\n      },\n      {} as Record<number, number>\n    )\n\n    /**\n     * @returns {number} - The chosen alternative index\n     */\n    return function (this: BaseParser): number {\n      const nextToken = this.LA(1)\n      return choiceToAlt[nextToken.tokenTypeIdx]\n    }\n  } else {\n    // optimized lookahead without needing to check the predicates at all.\n    // this causes code duplication which is intentional to improve performance.\n    /**\n     * @returns {number} - The chosen alternative index\n     */\n    return function (this: BaseParser): number | undefined {\n      for (let t = 0; t < numOfAlts; t++) {\n        const currAlt = alts[t]\n        const currNumOfPaths = currAlt.length\n        nextPath: for (let j = 0; j < currNumOfPaths; j++) {\n          const currPath = currAlt[j]\n          const currPathLength = currPath.length\n          for (let i = 0; i < currPathLength; i++) {\n            const nextToken = this.LA(i + 1)\n            if (tokenMatcher(nextToken, currPath[i]) === false) {\n              // mismatch in current path\n              // try the next pth\n              continue nextPath\n            }\n          }\n          // found a full path that matches.\n          // this will also work for an empty ALT as the loop will be skipped\n          return t\n        }\n        // none of the paths for the current alternative matched\n        // try the next alternative\n      }\n      // none of the alternatives could be matched\n      return undefined\n    }\n  }\n}\n\nexport function buildSingleAlternativeLookaheadFunction(\n  alt: LookaheadSequence,\n  tokenMatcher: TokenMatcher,\n  dynamicTokensEnabled: boolean\n): () => boolean {\n  const areAllOneTokenLookahead = every(alt, (currPath) => {\n    return currPath.length === 1\n  })\n\n  const numOfPaths = alt.length\n\n  // optimized (common) case of all the lookaheads paths requiring only\n  // a single token lookahead.\n  if (areAllOneTokenLookahead && !dynamicTokensEnabled) {\n    const singleTokensTypes = flatten(alt)\n\n    if (\n      singleTokensTypes.length === 1 &&\n      isEmpty((<any>singleTokensTypes[0]).categoryMatches)\n    ) {\n      const expectedTokenType = singleTokensTypes[0]\n      const expectedTokenUniqueKey = (<any>expectedTokenType).tokenTypeIdx\n\n      return function (this: BaseParser): boolean {\n        return this.LA(1).tokenTypeIdx === expectedTokenUniqueKey\n      }\n    } else {\n      const choiceToAlt = reduce(\n        singleTokensTypes,\n        (result, currTokType, idx) => {\n          result[currTokType.tokenTypeIdx!] = true\n          forEach(currTokType.categoryMatches!, (currExtendingType) => {\n            result[currExtendingType] = true\n          })\n          return result\n        },\n        [] as boolean[]\n      )\n\n      return function (this: BaseParser): boolean {\n        const nextToken = this.LA(1)\n        return choiceToAlt[nextToken.tokenTypeIdx] === true\n      }\n    }\n  } else {\n    return function (this: BaseParser): boolean {\n      nextPath: for (let j = 0; j < numOfPaths; j++) {\n        const currPath = alt[j]\n        const currPathLength = currPath.length\n        for (let i = 0; i < currPathLength; i++) {\n          const nextToken = this.LA(i + 1)\n          if (tokenMatcher(nextToken, currPath[i]) === false) {\n            // mismatch in current path\n            // try the next pth\n            continue nextPath\n          }\n        }\n        // found a full path that matches.\n        return true\n      }\n\n      // none of the paths matched\n      return false\n    }\n  }\n}\n\nclass RestDefinitionFinderWalker extends RestWalker {\n  private restDef: IProduction[]\n\n  constructor(\n    private topProd: Rule,\n    private targetOccurrence: number,\n    private targetProdType: PROD_TYPE\n  ) {\n    super()\n  }\n\n  startWalking(): IProduction[] {\n    this.walk(this.topProd)\n    return this.restDef\n  }\n\n  private checkIsTarget(\n    node: IProductionWithOccurrence,\n    expectedProdType: PROD_TYPE,\n    currRest: IProduction[],\n    prevRest: IProduction[]\n  ): boolean {\n    if (\n      node.idx === this.targetOccurrence &&\n      this.targetProdType === expectedProdType\n    ) {\n      this.restDef = currRest.concat(prevRest)\n      return true\n    }\n    // performance optimization, do not iterate over the entire Grammar ast after we have found the target\n    return false\n  }\n\n  walkOption(\n    optionProd: Option,\n    currRest: IProduction[],\n    prevRest: IProduction[]\n  ): void {\n    if (!this.checkIsTarget(optionProd, PROD_TYPE.OPTION, currRest, prevRest)) {\n      super.walkOption(optionProd, currRest, prevRest)\n    }\n  }\n\n  walkAtLeastOne(\n    atLeastOneProd: RepetitionMandatory,\n    currRest: IProduction[],\n    prevRest: IProduction[]\n  ): void {\n    if (\n      !this.checkIsTarget(\n        atLeastOneProd,\n        PROD_TYPE.REPETITION_MANDATORY,\n        currRest,\n        prevRest\n      )\n    ) {\n      super.walkOption(atLeastOneProd, currRest, prevRest)\n    }\n  }\n\n  walkAtLeastOneSep(\n    atLeastOneSepProd: RepetitionMandatoryWithSeparator,\n    currRest: IProduction[],\n    prevRest: IProduction[]\n  ): void {\n    if (\n      !this.checkIsTarget(\n        atLeastOneSepProd,\n        PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR,\n        currRest,\n        prevRest\n      )\n    ) {\n      super.walkOption(atLeastOneSepProd, currRest, prevRest)\n    }\n  }\n\n  walkMany(\n    manyProd: Repetition,\n    currRest: IProduction[],\n    prevRest: IProduction[]\n  ): void {\n    if (\n      !this.checkIsTarget(manyProd, PROD_TYPE.REPETITION, currRest, prevRest)\n    ) {\n      super.walkOption(manyProd, currRest, prevRest)\n    }\n  }\n\n  walkManySep(\n    manySepProd: RepetitionWithSeparator,\n    currRest: IProduction[],\n    prevRest: IProduction[]\n  ): void {\n    if (\n      !this.checkIsTarget(\n        manySepProd,\n        PROD_TYPE.REPETITION_WITH_SEPARATOR,\n        currRest,\n        prevRest\n      )\n    ) {\n      super.walkOption(manySepProd, currRest, prevRest)\n    }\n  }\n}\n\n/**\n * Returns the definition of a target production in a top level level rule.\n */\nclass InsideDefinitionFinderVisitor extends GAstVisitor {\n  public result: IProduction[] = []\n\n  constructor(\n    private targetOccurrence: number,\n    private targetProdType: PROD_TYPE,\n    private targetRef?: any\n  ) {\n    super()\n  }\n\n  private checkIsTarget(\n    node: { definition: IProduction[] } & IProductionWithOccurrence,\n    expectedProdName: PROD_TYPE\n  ): void {\n    if (\n      node.idx === this.targetOccurrence &&\n      this.targetProdType === expectedProdName &&\n      (this.targetRef === undefined || node === this.targetRef)\n    ) {\n      this.result = node.definition\n    }\n  }\n\n  public visitOption(node: Option): void {\n    this.checkIsTarget(node, PROD_TYPE.OPTION)\n  }\n\n  public visitRepetition(node: Repetition): void {\n    this.checkIsTarget(node, PROD_TYPE.REPETITION)\n  }\n\n  public visitRepetitionMandatory(node: RepetitionMandatory): void {\n    this.checkIsTarget(node, PROD_TYPE.REPETITION_MANDATORY)\n  }\n\n  public visitRepetitionMandatoryWithSeparator(\n    node: RepetitionMandatoryWithSeparator\n  ): void {\n    this.checkIsTarget(node, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR)\n  }\n\n  public visitRepetitionWithSeparator(node: RepetitionWithSeparator): void {\n    this.checkIsTarget(node, PROD_TYPE.REPETITION_WITH_SEPARATOR)\n  }\n\n  public visitAlternation(node: Alternation): void {\n    this.checkIsTarget(node, PROD_TYPE.ALTERNATION)\n  }\n}\n\nfunction initializeArrayOfArrays(size: number): any[][] {\n  const result = new Array(size)\n  for (let i = 0; i < size; i++) {\n    result[i] = []\n  }\n  return result\n}\n\n/**\n * A sort of hash function between a Path in the grammar and a string.\n * Note that this returns multiple \"hashes\" to support the scenario of token categories.\n * -  A single path with categories may match multiple **actual** paths.\n */\nfunction pathToHashKeys(path: TokenType[]): string[] {\n  let keys = [\"\"]\n  for (let i = 0; i < path.length; i++) {\n    const tokType = path[i]\n    const longerKeys = []\n    for (let j = 0; j < keys.length; j++) {\n      const currShorterKey = keys[j]\n      longerKeys.push(currShorterKey + \"_\" + tokType.tokenTypeIdx)\n      for (let t = 0; t < tokType.categoryMatches!.length; t++) {\n        const categoriesKeySuffix = \"_\" + tokType.categoryMatches![t]\n        longerKeys.push(currShorterKey + categoriesKeySuffix)\n      }\n    }\n    keys = longerKeys\n  }\n  return keys\n}\n\n/**\n * Imperative style due to being called from a hot spot\n */\nfunction isUniquePrefixHash(\n  altKnownPathsKeys: Record<string, boolean>[],\n  searchPathKeys: string[],\n  idx: number\n): boolean {\n  for (\n    let currAltIdx = 0;\n    currAltIdx < altKnownPathsKeys.length;\n    currAltIdx++\n  ) {\n    // We only want to test vs the other alternatives\n    if (currAltIdx === idx) {\n      continue\n    }\n    const otherAltKnownPathsKeys = altKnownPathsKeys[currAltIdx]\n    for (let searchIdx = 0; searchIdx < searchPathKeys.length; searchIdx++) {\n      const searchKey = searchPathKeys[searchIdx]\n      if (otherAltKnownPathsKeys[searchKey] === true) {\n        return false\n      }\n    }\n  }\n  // None of the SearchPathKeys were found in any of the other alternatives\n  return true\n}\n\nexport function lookAheadSequenceFromAlternatives(\n  altsDefs: IProduction[],\n  k: number\n): LookaheadSequence[] {\n  const partialAlts = map(altsDefs, (currAlt) =>\n    possiblePathsFrom([currAlt], 1)\n  )\n  const finalResult = initializeArrayOfArrays(partialAlts.length)\n  const altsHashes = map(partialAlts, (currAltPaths) => {\n    const dict: { [key: string]: boolean } = {}\n    forEach(currAltPaths, (item) => {\n      const keys = pathToHashKeys(item.partialPath)\n      forEach(keys, (currKey) => {\n        dict[currKey] = true\n      })\n    })\n    return dict\n  })\n  let newData = partialAlts\n\n  // maxLookahead loop\n  for (let pathLength = 1; pathLength <= k; pathLength++) {\n    const currDataset = newData\n    newData = initializeArrayOfArrays(currDataset.length)\n\n    // alternatives loop\n    for (let altIdx = 0; altIdx < currDataset.length; altIdx++) {\n      const currAltPathsAndSuffixes = currDataset[altIdx]\n      // paths in current alternative loop\n      for (\n        let currPathIdx = 0;\n        currPathIdx < currAltPathsAndSuffixes.length;\n        currPathIdx++\n      ) {\n        const currPathPrefix = currAltPathsAndSuffixes[currPathIdx].partialPath\n        const suffixDef = currAltPathsAndSuffixes[currPathIdx].suffixDef\n        const prefixKeys = pathToHashKeys(currPathPrefix)\n        const isUnique = isUniquePrefixHash(altsHashes, prefixKeys, altIdx)\n        // End of the line for this path.\n        if (isUnique || isEmpty(suffixDef) || currPathPrefix.length === k) {\n          const currAltResult = finalResult[altIdx]\n          // TODO: Can we implement a containsPath using Maps/Dictionaries?\n          if (containsPath(currAltResult, currPathPrefix) === false) {\n            currAltResult.push(currPathPrefix)\n            // Update all new  keys for the current path.\n            for (let j = 0; j < prefixKeys.length; j++) {\n              const currKey = prefixKeys[j]\n              altsHashes[altIdx][currKey] = true\n            }\n          }\n        }\n        // Expand longer paths\n        else {\n          const newPartialPathsAndSuffixes = possiblePathsFrom(\n            suffixDef,\n            pathLength + 1,\n            currPathPrefix\n          )\n          newData[altIdx] = newData[altIdx].concat(newPartialPathsAndSuffixes)\n\n          // Update keys for new known paths\n          forEach(newPartialPathsAndSuffixes, (item) => {\n            const prefixKeys = pathToHashKeys(item.partialPath)\n            forEach(prefixKeys, (key) => {\n              altsHashes[altIdx][key] = true\n            })\n          })\n        }\n      }\n    }\n  }\n\n  return finalResult\n}\n\nexport function getLookaheadPathsForOr(\n  occurrence: number,\n  ruleGrammar: Rule,\n  k: number,\n  orProd?: Alternation\n): LookaheadSequence[] {\n  const visitor = new InsideDefinitionFinderVisitor(\n    occurrence,\n    PROD_TYPE.ALTERNATION,\n    orProd\n  )\n  ruleGrammar.accept(visitor)\n  return lookAheadSequenceFromAlternatives(visitor.result, k)\n}\n\nexport function getLookaheadPathsForOptionalProd(\n  occurrence: number,\n  ruleGrammar: Rule,\n  prodType: PROD_TYPE,\n  k: number\n): LookaheadSequence[] {\n  const insideDefVisitor = new InsideDefinitionFinderVisitor(\n    occurrence,\n    prodType\n  )\n  ruleGrammar.accept(insideDefVisitor)\n  const insideDef = insideDefVisitor.result\n\n  const afterDefWalker = new RestDefinitionFinderWalker(\n    ruleGrammar,\n    occurrence,\n    prodType\n  )\n  const afterDef = afterDefWalker.startWalking()\n\n  const insideFlat = new AlternativeGAST({ definition: insideDef })\n  const afterFlat = new AlternativeGAST({ definition: afterDef })\n\n  return lookAheadSequenceFromAlternatives([insideFlat, afterFlat], k)\n}\n\nexport function containsPath(\n  alternative: Alternative,\n  searchPath: TokenType[]\n): boolean {\n  compareOtherPath: for (let i = 0; i < alternative.length; i++) {\n    const otherPath = alternative[i]\n    if (otherPath.length !== searchPath.length) {\n      continue\n    }\n    for (let j = 0; j < otherPath.length; j++) {\n      const searchTok = searchPath[j]\n      const otherTok = otherPath[j]\n\n      const matchingTokens =\n        searchTok === otherTok ||\n        otherTok.categoryMatchesMap![searchTok.tokenTypeIdx!] !== undefined\n      if (matchingTokens === false) {\n        continue compareOtherPath\n      }\n    }\n    return true\n  }\n\n  return false\n}\n\nexport function isStrictPrefixOfPath(\n  prefix: TokenType[],\n  other: TokenType[]\n): boolean {\n  return (\n    prefix.length < other.length &&\n    every(prefix, (tokType, idx) => {\n      const otherTokType = other[idx]\n      return (\n        tokType === otherTokType ||\n        otherTokType.categoryMatchesMap![tokType.tokenTypeIdx!]\n      )\n    })\n  )\n}\n\nexport function areTokenCategoriesNotUsed(\n  lookAheadPaths: LookaheadSequence[]\n): boolean {\n  return every(lookAheadPaths, (singleAltPaths) =>\n    every(singleAltPaths, (singlePath) =>\n      every(singlePath, (token) => isEmpty(token.categoryMatches!))\n    )\n  )\n}\n", "import first from \"lodash/first\"\nimport isEmpty from \"lodash/isEmpty\"\nimport drop from \"lodash/drop\"\nimport flatten from \"lodash/flatten\"\nimport filter from \"lodash/filter\"\nimport reject from \"lodash/reject\"\nimport difference from \"lodash/difference\"\nimport map from \"lodash/map\"\nimport forEach from \"lodash/forEach\"\nimport groupBy from \"lodash/groupBy\"\nimport reduce from \"lodash/reduce\"\nimport pickBy from \"lodash/pickBy\"\nimport values from \"lodash/values\"\nimport includes from \"lodash/includes\"\nimport flatMap from \"lodash/flatMap\"\nimport clone from \"lodash/clone\"\nimport {\n  IParserAmbiguousAlternativesDefinitionError,\n  IParserDuplicatesDefinitionError,\n  IParserEmptyAlternativeDefinitionError,\n  ParserDefinitionErrorType\n} from \"../parser/parser\"\nimport { getProductionDslName, isOptionalProd } from \"@chevrotain/gast\"\nimport {\n  Alternative,\n  containsPath,\n  getLookaheadPathsForOptionalProd,\n  getLookaheadPathsForOr,\n  getProdType,\n  isStrictPrefixOfPath\n} from \"./lookahead\"\nimport { nextPossibleTokensAfter } from \"./interpreter\"\nimport {\n  Alternation,\n  Alternative as AlternativeGAST,\n  NonTerminal,\n  Option,\n  Repetition,\n  RepetitionMandatory,\n  RepetitionMandatoryWithSeparator,\n  RepetitionWithSeparator,\n  Terminal\n} from \"@chevrotain/gast\"\nimport { GAstVisitor } from \"@chevrotain/gast\"\nimport {\n  ILookaheadStrategy,\n  IProduction,\n  IProductionWithOccurrence,\n  TokenType,\n  Rule\n} from \"@chevrotain/types\"\nimport {\n  IGrammarValidatorErrorMessageProvider,\n  IParserDefinitionError\n} from \"./types\"\nimport dropRight from \"lodash/dropRight\"\nimport compact from \"lodash/compact\"\nimport { tokenStructuredMatcher } from \"../../scan/tokens\"\n\nexport function validateLookahead(options: {\n  lookaheadStrategy: ILookaheadStrategy\n  rules: Rule[]\n  tokenTypes: TokenType[]\n  grammarName: string\n}): IParserDefinitionError[] {\n  const lookaheadValidationErrorMessages = options.lookaheadStrategy.validate({\n    rules: options.rules,\n    tokenTypes: options.tokenTypes,\n    grammarName: options.grammarName\n  })\n  return map(lookaheadValidationErrorMessages, (errorMessage) => ({\n    type: ParserDefinitionErrorType.CUSTOM_LOOKAHEAD_VALIDATION,\n    ...errorMessage\n  }))\n}\n\nexport function validateGrammar(\n  topLevels: Rule[],\n  tokenTypes: TokenType[],\n  errMsgProvider: IGrammarValidatorErrorMessageProvider,\n  grammarName: string\n): IParserDefinitionError[] {\n  const duplicateErrors: IParserDefinitionError[] = flatMap(\n    topLevels,\n    (currTopLevel) => validateDuplicateProductions(currTopLevel, errMsgProvider)\n  )\n\n  const termsNamespaceConflictErrors = checkTerminalAndNoneTerminalsNameSpace(\n    topLevels,\n    tokenTypes,\n    errMsgProvider\n  )\n\n  const tooManyAltsErrors = flatMap(topLevels, (curRule) =>\n    validateTooManyAlts(curRule, errMsgProvider)\n  )\n\n  const duplicateRulesError = flatMap(topLevels, (curRule) =>\n    validateRuleDoesNotAlreadyExist(\n      curRule,\n      topLevels,\n      grammarName,\n      errMsgProvider\n    )\n  )\n\n  return duplicateErrors.concat(\n    termsNamespaceConflictErrors,\n    tooManyAltsErrors,\n    duplicateRulesError\n  )\n}\n\nfunction validateDuplicateProductions(\n  topLevelRule: Rule,\n  errMsgProvider: IGrammarValidatorErrorMessageProvider\n): IParserDuplicatesDefinitionError[] {\n  const collectorVisitor = new OccurrenceValidationCollector()\n  topLevelRule.accept(collectorVisitor)\n  const allRuleProductions = collectorVisitor.allProductions\n\n  const productionGroups = groupBy(\n    allRuleProductions,\n    identifyProductionForDuplicates\n  )\n\n  const duplicates: any = pickBy(productionGroups, (currGroup) => {\n    return currGroup.length > 1\n  })\n\n  const errors = map(values(duplicates), (currDuplicates: any) => {\n    const firstProd: any = first(currDuplicates)\n    const msg = errMsgProvider.buildDuplicateFoundError(\n      topLevelRule,\n      currDuplicates\n    )\n    const dslName = getProductionDslName(firstProd)\n    const defError: IParserDuplicatesDefinitionError = {\n      message: msg,\n      type: ParserDefinitionErrorType.DUPLICATE_PRODUCTIONS,\n      ruleName: topLevelRule.name,\n      dslName: dslName,\n      occurrence: firstProd.idx\n    }\n\n    const param = getExtraProductionArgument(firstProd)\n    if (param) {\n      defError.parameter = param\n    }\n\n    return defError\n  })\n  return errors\n}\n\nexport function identifyProductionForDuplicates(\n  prod: IProductionWithOccurrence\n): string {\n  return `${getProductionDslName(prod)}_#_${\n    prod.idx\n  }_#_${getExtraProductionArgument(prod)}`\n}\n\nfunction getExtraProductionArgument(prod: IProductionWithOccurrence): string {\n  if (prod instanceof Terminal) {\n    return prod.terminalType.name\n  } else if (prod instanceof NonTerminal) {\n    return prod.nonTerminalName\n  } else {\n    return \"\"\n  }\n}\n\nexport class OccurrenceValidationCollector extends GAstVisitor {\n  public allProductions: IProductionWithOccurrence[] = []\n\n  public visitNonTerminal(subrule: NonTerminal): void {\n    this.allProductions.push(subrule)\n  }\n\n  public visitOption(option: Option): void {\n    this.allProductions.push(option)\n  }\n\n  public visitRepetitionWithSeparator(manySep: RepetitionWithSeparator): void {\n    this.allProductions.push(manySep)\n  }\n\n  public visitRepetitionMandatory(atLeastOne: RepetitionMandatory): void {\n    this.allProductions.push(atLeastOne)\n  }\n\n  public visitRepetitionMandatoryWithSeparator(\n    atLeastOneSep: RepetitionMandatoryWithSeparator\n  ): void {\n    this.allProductions.push(atLeastOneSep)\n  }\n\n  public visitRepetition(many: Repetition): void {\n    this.allProductions.push(many)\n  }\n\n  public visitAlternation(or: Alternation): void {\n    this.allProductions.push(or)\n  }\n\n  public visitTerminal(terminal: Terminal): void {\n    this.allProductions.push(terminal)\n  }\n}\n\nexport function validateRuleDoesNotAlreadyExist(\n  rule: Rule,\n  allRules: Rule[],\n  className: string,\n  errMsgProvider: IGrammarValidatorErrorMessageProvider\n): IParserDefinitionError[] {\n  const errors = []\n  const occurrences = reduce(\n    allRules,\n    (result, curRule) => {\n      if (curRule.name === rule.name) {\n        return result + 1\n      }\n      return result\n    },\n    0\n  )\n  if (occurrences > 1) {\n    const errMsg = errMsgProvider.buildDuplicateRuleNameError({\n      topLevelRule: rule,\n      grammarName: className\n    })\n    errors.push({\n      message: errMsg,\n      type: ParserDefinitionErrorType.DUPLICATE_RULE_NAME,\n      ruleName: rule.name\n    })\n  }\n\n  return errors\n}\n\n// TODO: is there anyway to get only the rule names of rules inherited from the super grammars?\n// This is not part of the IGrammarErrorProvider because the validation cannot be performed on\n// The grammar structure, only at runtime.\nexport function validateRuleIsOverridden(\n  ruleName: string,\n  definedRulesNames: string[],\n  className: string\n): IParserDefinitionError[] {\n  const errors = []\n  let errMsg\n\n  if (!includes(definedRulesNames, ruleName)) {\n    errMsg =\n      `Invalid rule override, rule: ->${ruleName}<- cannot be overridden in the grammar: ->${className}<-` +\n      `as it is not defined in any of the super grammars `\n    errors.push({\n      message: errMsg,\n      type: ParserDefinitionErrorType.INVALID_RULE_OVERRIDE,\n      ruleName: ruleName\n    })\n  }\n\n  return errors\n}\n\nexport function validateNoLeftRecursion(\n  topRule: Rule,\n  currRule: Rule,\n  errMsgProvider: IGrammarValidatorErrorMessageProvider,\n  path: Rule[] = []\n): IParserDefinitionError[] {\n  const errors: IParserDefinitionError[] = []\n  const nextNonTerminals = getFirstNoneTerminal(currRule.definition)\n  if (isEmpty(nextNonTerminals)) {\n    return []\n  } else {\n    const ruleName = topRule.name\n    const foundLeftRecursion = includes(nextNonTerminals, topRule)\n    if (foundLeftRecursion) {\n      errors.push({\n        message: errMsgProvider.buildLeftRecursionError({\n          topLevelRule: topRule,\n          leftRecursionPath: path\n        }),\n        type: ParserDefinitionErrorType.LEFT_RECURSION,\n        ruleName: ruleName\n      })\n    }\n\n    // we are only looking for cyclic paths leading back to the specific topRule\n    // other cyclic paths are ignored, we still need this difference to avoid infinite loops...\n    const validNextSteps = difference(nextNonTerminals, path.concat([topRule]))\n    const errorsFromNextSteps = flatMap(validNextSteps, (currRefRule) => {\n      const newPath = clone(path)\n      newPath.push(currRefRule)\n      return validateNoLeftRecursion(\n        topRule,\n        currRefRule,\n        errMsgProvider,\n        newPath\n      )\n    })\n\n    return errors.concat(errorsFromNextSteps)\n  }\n}\n\nexport function getFirstNoneTerminal(definition: IProduction[]): Rule[] {\n  let result: Rule[] = []\n  if (isEmpty(definition)) {\n    return result\n  }\n  const firstProd = first(definition)\n\n  /* istanbul ignore else */\n  if (firstProd instanceof NonTerminal) {\n    result.push(firstProd.referencedRule)\n  } else if (\n    firstProd instanceof AlternativeGAST ||\n    firstProd instanceof Option ||\n    firstProd instanceof RepetitionMandatory ||\n    firstProd instanceof RepetitionMandatoryWithSeparator ||\n    firstProd instanceof RepetitionWithSeparator ||\n    firstProd instanceof Repetition\n  ) {\n    result = result.concat(\n      getFirstNoneTerminal(<IProduction[]>firstProd.definition)\n    )\n  } else if (firstProd instanceof Alternation) {\n    // each sub definition in alternation is a FLAT\n    result = flatten(\n      map(firstProd.definition, (currSubDef) =>\n        getFirstNoneTerminal((<AlternativeGAST>currSubDef).definition)\n      )\n    )\n  } else if (firstProd instanceof Terminal) {\n    // nothing to see, move along\n  } else {\n    throw Error(\"non exhaustive match\")\n  }\n\n  const isFirstOptional = isOptionalProd(firstProd)\n  const hasMore = definition.length > 1\n  if (isFirstOptional && hasMore) {\n    const rest = drop(definition)\n    return result.concat(getFirstNoneTerminal(rest))\n  } else {\n    return result\n  }\n}\n\nclass OrCollector extends GAstVisitor {\n  public alternations: Alternation[] = []\n\n  public visitAlternation(node: Alternation): void {\n    this.alternations.push(node)\n  }\n}\n\nexport function validateEmptyOrAlternative(\n  topLevelRule: Rule,\n  errMsgProvider: IGrammarValidatorErrorMessageProvider\n): IParserEmptyAlternativeDefinitionError[] {\n  const orCollector = new OrCollector()\n  topLevelRule.accept(orCollector)\n  const ors = orCollector.alternations\n\n  const errors = flatMap<Alternation, IParserEmptyAlternativeDefinitionError>(\n    ors,\n    (currOr) => {\n      const exceptLast = dropRight(currOr.definition)\n      return flatMap(exceptLast, (currAlternative, currAltIdx) => {\n        const possibleFirstInAlt = nextPossibleTokensAfter(\n          [currAlternative],\n          [],\n          tokenStructuredMatcher,\n          1\n        )\n        if (isEmpty(possibleFirstInAlt)) {\n          return [\n            {\n              message: errMsgProvider.buildEmptyAlternationError({\n                topLevelRule: topLevelRule,\n                alternation: currOr,\n                emptyChoiceIdx: currAltIdx\n              }),\n              type: ParserDefinitionErrorType.NONE_LAST_EMPTY_ALT,\n              ruleName: topLevelRule.name,\n              occurrence: currOr.idx,\n              alternative: currAltIdx + 1\n            }\n          ]\n        } else {\n          return []\n        }\n      })\n    }\n  )\n\n  return errors\n}\n\nexport function validateAmbiguousAlternationAlternatives(\n  topLevelRule: Rule,\n  globalMaxLookahead: number,\n  errMsgProvider: IGrammarValidatorErrorMessageProvider\n): IParserAmbiguousAlternativesDefinitionError[] {\n  const orCollector = new OrCollector()\n  topLevelRule.accept(orCollector)\n  let ors = orCollector.alternations\n\n  // New Handling of ignoring ambiguities\n  // - https://github.com/chevrotain/chevrotain/issues/869\n  ors = reject(ors, (currOr) => currOr.ignoreAmbiguities === true)\n\n  const errors = flatMap(ors, (currOr: Alternation) => {\n    const currOccurrence = currOr.idx\n    const actualMaxLookahead = currOr.maxLookahead || globalMaxLookahead\n    const alternatives = getLookaheadPathsForOr(\n      currOccurrence,\n      topLevelRule,\n      actualMaxLookahead,\n      currOr\n    )\n    const altsAmbiguityErrors = checkAlternativesAmbiguities(\n      alternatives,\n      currOr,\n      topLevelRule,\n      errMsgProvider\n    )\n    const altsPrefixAmbiguityErrors = checkPrefixAlternativesAmbiguities(\n      alternatives,\n      currOr,\n      topLevelRule,\n      errMsgProvider\n    )\n\n    return altsAmbiguityErrors.concat(altsPrefixAmbiguityErrors)\n  })\n\n  return errors\n}\n\nexport class RepetitionCollector extends GAstVisitor {\n  public allProductions: (IProductionWithOccurrence & {\n    maxLookahead?: number\n  })[] = []\n\n  public visitRepetitionWithSeparator(manySep: RepetitionWithSeparator): void {\n    this.allProductions.push(manySep)\n  }\n\n  public visitRepetitionMandatory(atLeastOne: RepetitionMandatory): void {\n    this.allProductions.push(atLeastOne)\n  }\n\n  public visitRepetitionMandatoryWithSeparator(\n    atLeastOneSep: RepetitionMandatoryWithSeparator\n  ): void {\n    this.allProductions.push(atLeastOneSep)\n  }\n\n  public visitRepetition(many: Repetition): void {\n    this.allProductions.push(many)\n  }\n}\n\nexport function validateTooManyAlts(\n  topLevelRule: Rule,\n  errMsgProvider: IGrammarValidatorErrorMessageProvider\n): IParserDefinitionError[] {\n  const orCollector = new OrCollector()\n  topLevelRule.accept(orCollector)\n  const ors = orCollector.alternations\n\n  const errors = flatMap(ors, (currOr) => {\n    if (currOr.definition.length > 255) {\n      return [\n        {\n          message: errMsgProvider.buildTooManyAlternativesError({\n            topLevelRule: topLevelRule,\n            alternation: currOr\n          }),\n          type: ParserDefinitionErrorType.TOO_MANY_ALTS,\n          ruleName: topLevelRule.name,\n          occurrence: currOr.idx\n        }\n      ]\n    } else {\n      return []\n    }\n  })\n\n  return errors\n}\n\nexport function validateSomeNonEmptyLookaheadPath(\n  topLevelRules: Rule[],\n  maxLookahead: number,\n  errMsgProvider: IGrammarValidatorErrorMessageProvider\n): IParserDefinitionError[] {\n  const errors: IParserDefinitionError[] = []\n  forEach(topLevelRules, (currTopRule) => {\n    const collectorVisitor = new RepetitionCollector()\n    currTopRule.accept(collectorVisitor)\n    const allRuleProductions = collectorVisitor.allProductions\n    forEach(allRuleProductions, (currProd) => {\n      const prodType = getProdType(currProd)\n      const actualMaxLookahead = currProd.maxLookahead || maxLookahead\n      const currOccurrence = currProd.idx\n      const paths = getLookaheadPathsForOptionalProd(\n        currOccurrence,\n        currTopRule,\n        prodType,\n        actualMaxLookahead\n      )\n      const pathsInsideProduction = paths[0]\n      if (isEmpty(flatten(pathsInsideProduction))) {\n        const errMsg = errMsgProvider.buildEmptyRepetitionError({\n          topLevelRule: currTopRule,\n          repetition: currProd\n        })\n        errors.push({\n          message: errMsg,\n          type: ParserDefinitionErrorType.NO_NON_EMPTY_LOOKAHEAD,\n          ruleName: currTopRule.name\n        })\n      }\n    })\n  })\n\n  return errors\n}\n\nexport interface IAmbiguityDescriptor {\n  alts: number[]\n  path: TokenType[]\n}\n\nfunction checkAlternativesAmbiguities(\n  alternatives: Alternative[],\n  alternation: Alternation,\n  rule: Rule,\n  errMsgProvider: IGrammarValidatorErrorMessageProvider\n): IParserAmbiguousAlternativesDefinitionError[] {\n  const foundAmbiguousPaths: Alternative = []\n  const identicalAmbiguities = reduce(\n    alternatives,\n    (result, currAlt, currAltIdx) => {\n      // ignore (skip) ambiguities with this alternative\n      if (alternation.definition[currAltIdx].ignoreAmbiguities === true) {\n        return result\n      }\n\n      forEach(currAlt, (currPath) => {\n        const altsCurrPathAppearsIn = [currAltIdx]\n        forEach(alternatives, (currOtherAlt, currOtherAltIdx) => {\n          if (\n            currAltIdx !== currOtherAltIdx &&\n            containsPath(currOtherAlt, currPath) &&\n            // ignore (skip) ambiguities with this \"other\" alternative\n            alternation.definition[currOtherAltIdx].ignoreAmbiguities !== true\n          ) {\n            altsCurrPathAppearsIn.push(currOtherAltIdx)\n          }\n        })\n\n        if (\n          altsCurrPathAppearsIn.length > 1 &&\n          !containsPath(foundAmbiguousPaths, currPath)\n        ) {\n          foundAmbiguousPaths.push(currPath)\n          result.push({\n            alts: altsCurrPathAppearsIn,\n            path: currPath\n          })\n        }\n      })\n      return result\n    },\n    [] as { alts: number[]; path: TokenType[] }[]\n  )\n\n  const currErrors = map(identicalAmbiguities, (currAmbDescriptor) => {\n    const ambgIndices = map(\n      currAmbDescriptor.alts,\n      (currAltIdx) => currAltIdx + 1\n    )\n\n    const currMessage = errMsgProvider.buildAlternationAmbiguityError({\n      topLevelRule: rule,\n      alternation: alternation,\n      ambiguityIndices: ambgIndices,\n      prefixPath: currAmbDescriptor.path\n    })\n\n    return {\n      message: currMessage,\n      type: ParserDefinitionErrorType.AMBIGUOUS_ALTS,\n      ruleName: rule.name,\n      occurrence: alternation.idx,\n      alternatives: currAmbDescriptor.alts\n    }\n  })\n\n  return currErrors\n}\n\nexport function checkPrefixAlternativesAmbiguities(\n  alternatives: Alternative[],\n  alternation: Alternation,\n  rule: Rule,\n  errMsgProvider: IGrammarValidatorErrorMessageProvider\n): IParserAmbiguousAlternativesDefinitionError[] {\n  // flatten\n  const pathsAndIndices = reduce(\n    alternatives,\n    (result, currAlt, idx) => {\n      const currPathsAndIdx = map(currAlt, (currPath) => {\n        return { idx: idx, path: currPath }\n      })\n      return result.concat(currPathsAndIdx)\n    },\n    [] as { idx: number; path: TokenType[] }[]\n  )\n\n  const errors = compact(\n    flatMap(pathsAndIndices, (currPathAndIdx) => {\n      const alternativeGast = alternation.definition[currPathAndIdx.idx]\n      // ignore (skip) ambiguities with this alternative\n      if (alternativeGast.ignoreAmbiguities === true) {\n        return []\n      }\n      const targetIdx = currPathAndIdx.idx\n      const targetPath = currPathAndIdx.path\n\n      const prefixAmbiguitiesPathsAndIndices = filter(\n        pathsAndIndices,\n        (searchPathAndIdx) => {\n          // prefix ambiguity can only be created from lower idx (higher priority) path\n          return (\n            // ignore (skip) ambiguities with this \"other\" alternative\n            alternation.definition[searchPathAndIdx.idx].ignoreAmbiguities !==\n              true &&\n            searchPathAndIdx.idx < targetIdx &&\n            // checking for strict prefix because identical lookaheads\n            // will be be detected using a different validation.\n            isStrictPrefixOfPath(searchPathAndIdx.path, targetPath)\n          )\n        }\n      )\n\n      const currPathPrefixErrors = map(\n        prefixAmbiguitiesPathsAndIndices,\n        (currAmbPathAndIdx): IParserAmbiguousAlternativesDefinitionError => {\n          const ambgIndices = [currAmbPathAndIdx.idx + 1, targetIdx + 1]\n          const occurrence = alternation.idx === 0 ? \"\" : alternation.idx\n\n          const message = errMsgProvider.buildAlternationPrefixAmbiguityError({\n            topLevelRule: rule,\n            alternation: alternation,\n            ambiguityIndices: ambgIndices,\n            prefixPath: currAmbPathAndIdx.path\n          })\n          return {\n            message: message,\n            type: ParserDefinitionErrorType.AMBIGUOUS_PREFIX_ALTS,\n            ruleName: rule.name,\n            occurrence: occurrence,\n            alternatives: ambgIndices\n          }\n        }\n      )\n\n      return currPathPrefixErrors\n    })\n  )\n\n  return errors\n}\n\nfunction checkTerminalAndNoneTerminalsNameSpace(\n  topLevels: Rule[],\n  tokenTypes: TokenType[],\n  errMsgProvider: IGrammarValidatorErrorMessageProvider\n): IParserDefinitionError[] {\n  const errors: IParserDefinitionError[] = []\n\n  const tokenNames = map(tokenTypes, (currToken) => currToken.name)\n\n  forEach(topLevels, (currRule) => {\n    const currRuleName = currRule.name\n    if (includes(tokenNames, currRuleName)) {\n      const errMsg = errMsgProvider.buildNamespaceConflictError(currRule)\n\n      errors.push({\n        message: errMsg,\n        type: ParserDefinitionErrorType.CONFLICT_TOKENS_RULES_NAMESPACE,\n        ruleName: currRuleName\n      })\n    }\n  })\n\n  return errors\n}\n", "import { Rule } from \"@chevrotain/gast\"\nimport forEach from \"lodash/forEach\"\nimport defaults from \"lodash/defaults\"\nimport { resolveGrammar as orgResolveGrammar } from \"../resolver\"\nimport { validateGrammar as orgValidateGrammar } from \"../checks\"\nimport {\n  defaultGrammarResolverErrorProvider,\n  defaultGrammarValidatorErrorProvider\n} from \"../../errors_public\"\nimport { TokenType } from \"@chevrotain/types\"\nimport {\n  IGrammarResolverErrorMessageProvider,\n  IGrammarValidatorErrorMessageProvider,\n  IParserDefinitionError\n} from \"../types\"\n\ntype ResolveGrammarOpts = {\n  rules: Rule[]\n  errMsgProvider?: IGrammarResolverErrorMessageProvider\n}\nexport function resolveGrammar(\n  options: ResolveGrammarOpts\n): IParserDefinitionError[] {\n  const actualOptions: Required<ResolveGrammarOpts> = defaults(options, {\n    errMsgProvider: defaultGrammarResolverErrorProvider\n  })\n\n  const topRulesTable: { [ruleName: string]: Rule } = {}\n  forEach(options.rules, (rule) => {\n    topRulesTable[rule.name] = rule\n  })\n  return orgResolveGrammar(topRulesTable, actualOptions.errMsgProvider)\n}\n\nexport function validateGrammar(options: {\n  rules: Rule[]\n  tokenTypes: TokenType[]\n  grammarName: string\n  errMsgProvider: IGrammarValidatorErrorMessageProvider\n}): IParserDefinitionError[] {\n  options = defaults(options, {\n    errMsgProvider: defaultGrammarValidatorErrorProvider\n  })\n\n  return orgValidateGrammar(\n    options.rules,\n    options.tokenTypes,\n    options.errMsgProvider,\n    options.grammarName\n  )\n}\n", "import includes from \"lodash/includes\"\nimport {\n  IToken,\n  IRecognitionException,\n  IRecognizerContext\n} from \"@chevrotain/types\"\n\nconst MISMATCHED_TOKEN_EXCEPTION = \"MismatchedTokenException\"\nconst NO_VIABLE_ALT_EXCEPTION = \"NoViableAltException\"\nconst EARLY_EXIT_EXCEPTION = \"EarlyExitException\"\nconst NOT_ALL_INPUT_PARSED_EXCEPTION = \"NotAllInputParsedException\"\n\nconst RECOGNITION_EXCEPTION_NAMES = [\n  MISMATCHED_TOKEN_EXCEPTION,\n  NO_VIABLE_ALT_EXCEPTION,\n  EARLY_EXIT_EXCEPTION,\n  NOT_ALL_INPUT_PARSED_EXCEPTION\n]\n\nObject.freeze(RECOGNITION_EXCEPTION_NAMES)\n\n// hacks to bypass no support for custom Errors in javascript/typescript\nexport function isRecognitionException(error: Error) {\n  // can't do instanceof on hacked custom js exceptions\n  return includes(RECOGNITION_EXCEPTION_NAMES, error.name)\n}\n\nabstract class RecognitionException\n  extends Error\n  implements IRecognitionException\n{\n  context: IRecognizerContext\n  resyncedTokens: IToken[] = []\n\n  protected constructor(message: string, public token: IToken) {\n    super(message)\n\n    // fix prototype chain when typescript target is ES5\n    Object.setPrototypeOf(this, new.target.prototype)\n\n    /* istanbul ignore next - V8 workaround to remove constructor from stacktrace when typescript target is ES5 */\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, this.constructor)\n    }\n  }\n}\n\nexport class MismatchedTokenException extends RecognitionException {\n  constructor(message: string, token: IToken, public previousToken: IToken) {\n    super(message, token)\n    this.name = MISMATCHED_TOKEN_EXCEPTION\n  }\n}\n\nexport class NoViableAltException extends RecognitionException {\n  constructor(message: string, token: IToken, public previousToken: IToken) {\n    super(message, token)\n    this.name = NO_VIABLE_ALT_EXCEPTION\n  }\n}\n\nexport class NotAllInputParsedException extends RecognitionException {\n  constructor(message: string, token: IToken) {\n    super(message, token)\n    this.name = NOT_ALL_INPUT_PARSED_EXCEPTION\n  }\n}\n\nexport class EarlyExitException extends RecognitionException {\n  constructor(message: string, token: IToken, public previousToken: IToken) {\n    super(message, token)\n    this.name = EARLY_EXIT_EXCEPTION\n  }\n}\n", "import {\n  createTokenInstance,\n  EOF,\n  tokenMatcher\n} from \"../../../scan/tokens_public\"\nimport {\n  AbstractNextTerminalAfterProductionWalker,\n  IFirstAfterRepetition\n} from \"../../grammar/interpreter\"\nimport isEmpty from \"lodash/isEmpty\"\nimport dropRight from \"lodash/dropRight\"\nimport flatten from \"lodash/flatten\"\nimport map from \"lodash/map\"\nimport find from \"lodash/find\"\nimport has from \"lodash/has\"\nimport includes from \"lodash/includes\"\nimport clone from \"lodash/clone\"\nimport {\n  IParserConfig,\n  IToken,\n  ITokenGrammarPath,\n  TokenType\n} from \"@chevrotain/types\"\nimport { MismatchedTokenException } from \"../../exceptions_public\"\nimport { IN } from \"../../constants\"\nimport { MixedInParser } from \"./parser_traits\"\nimport { DEFAULT_PARSER_CONFIG } from \"../parser\"\n\nexport const EOF_FOLLOW_KEY: any = {}\n\nexport interface IFollowKey {\n  ruleName: string\n  idxInCallingRule: number\n  inRule: string\n}\n\nexport const IN_RULE_RECOVERY_EXCEPTION = \"InRuleRecoveryException\"\n\nexport class InRuleRecoveryException extends Error {\n  constructor(message: string) {\n    super(message)\n    this.name = IN_RULE_RECOVERY_EXCEPTION\n  }\n}\n\n/**\n * This trait is responsible for the error recovery and fault tolerant logic\n */\nexport class Recoverable {\n  recoveryEnabled: boolean\n  firstAfterRepMap: Record<string, IFirstAfterRepetition>\n  resyncFollows: Record<string, TokenType[]>\n\n  initRecoverable(config: IParserConfig) {\n    this.firstAfterRepMap = {}\n    this.resyncFollows = {}\n\n    this.recoveryEnabled = has(config, \"recoveryEnabled\")\n      ? (config.recoveryEnabled as boolean) // assumes end user provides the correct config value/type\n      : DEFAULT_PARSER_CONFIG.recoveryEnabled\n\n    // performance optimization, NOOP will be inlined which\n    // effectively means that this optional feature does not exist\n    // when not used.\n    if (this.recoveryEnabled) {\n      this.attemptInRepetitionRecovery = attemptInRepetitionRecovery\n    }\n  }\n\n  public getTokenToInsert(tokType: TokenType): IToken {\n    const tokToInsert = createTokenInstance(\n      tokType,\n      \"\",\n      NaN,\n      NaN,\n      NaN,\n      NaN,\n      NaN,\n      NaN\n    )\n    tokToInsert.isInsertedInRecovery = true\n    return tokToInsert\n  }\n\n  public canTokenTypeBeInsertedInRecovery(tokType: TokenType): boolean {\n    return true\n  }\n\n  public canTokenTypeBeDeletedInRecovery(tokType: TokenType): boolean {\n    return true\n  }\n\n  tryInRepetitionRecovery(\n    this: MixedInParser,\n    grammarRule: Function,\n    grammarRuleArgs: any[],\n    lookAheadFunc: () => boolean,\n    expectedTokType: TokenType\n  ): void {\n    // TODO: can the resyncTokenType be cached?\n    const reSyncTokType = this.findReSyncTokenType()\n    const savedLexerState = this.exportLexerState()\n    const resyncedTokens: IToken[] = []\n    let passedResyncPoint = false\n\n    const nextTokenWithoutResync = this.LA(1)\n    let currToken = this.LA(1)\n\n    const generateErrorMessage = () => {\n      const previousToken = this.LA(0)\n      // we are preemptively re-syncing before an error has been detected, therefor we must reproduce\n      // the error that would have been thrown\n      const msg = this.errorMessageProvider.buildMismatchTokenMessage({\n        expected: expectedTokType,\n        actual: nextTokenWithoutResync,\n        previous: previousToken,\n        ruleName: this.getCurrRuleFullName()\n      })\n      const error = new MismatchedTokenException(\n        msg,\n        nextTokenWithoutResync,\n        this.LA(0)\n      )\n      // the first token here will be the original cause of the error, this is not part of the resyncedTokens property.\n      error.resyncedTokens = dropRight(resyncedTokens)\n      this.SAVE_ERROR(error)\n    }\n\n    while (!passedResyncPoint) {\n      // re-synced to a point where we can safely exit the repetition/\n      if (this.tokenMatcher(currToken, expectedTokType)) {\n        generateErrorMessage()\n        return // must return here to avoid reverting the inputIdx\n      } else if (lookAheadFunc.call(this)) {\n        // we skipped enough tokens so we can resync right back into another iteration of the repetition grammar rule\n        generateErrorMessage()\n        // recursive invocation in other to support multiple re-syncs in the same top level repetition grammar rule\n        grammarRule.apply(this, grammarRuleArgs)\n        return // must return here to avoid reverting the inputIdx\n      } else if (this.tokenMatcher(currToken, reSyncTokType)) {\n        passedResyncPoint = true\n      } else {\n        currToken = this.SKIP_TOKEN()\n        this.addToResyncTokens(currToken, resyncedTokens)\n      }\n    }\n\n    // we were unable to find a CLOSER point to resync inside the Repetition, reset the state.\n    // The parsing exception we were trying to prevent will happen in the NEXT parsing step. it may be handled by\n    // \"between rules\" resync recovery later in the flow.\n    this.importLexerState(savedLexerState)\n  }\n\n  shouldInRepetitionRecoveryBeTried(\n    this: MixedInParser,\n    expectTokAfterLastMatch: TokenType,\n    nextTokIdx: number,\n    notStuck: boolean | undefined\n  ): boolean {\n    // Edge case of arriving from a MANY repetition which is stuck\n    // Attempting recovery in this case could cause an infinite loop\n    if (notStuck === false) {\n      return false\n    }\n\n    // no need to recover, next token is what we expect...\n    if (this.tokenMatcher(this.LA(1), expectTokAfterLastMatch)) {\n      return false\n    }\n\n    // error recovery is disabled during backtracking as it can make the parser ignore a valid grammar path\n    // and prefer some backtracking path that includes recovered errors.\n    if (this.isBackTracking()) {\n      return false\n    }\n\n    // if we can perform inRule recovery (single token insertion or deletion) we always prefer that recovery algorithm\n    // because if it works, it makes the least amount of changes to the input stream (greedy algorithm)\n    //noinspection RedundantIfStatementJS\n    if (\n      this.canPerformInRuleRecovery(\n        expectTokAfterLastMatch,\n        this.getFollowsForInRuleRecovery(expectTokAfterLastMatch, nextTokIdx)\n      )\n    ) {\n      return false\n    }\n\n    return true\n  }\n\n  // Error Recovery functionality\n  getFollowsForInRuleRecovery(\n    this: MixedInParser,\n    tokType: TokenType,\n    tokIdxInRule: number\n  ): TokenType[] {\n    const grammarPath = this.getCurrentGrammarPath(tokType, tokIdxInRule)\n    const follows = this.getNextPossibleTokenTypes(grammarPath)\n    return follows\n  }\n\n  tryInRuleRecovery(\n    this: MixedInParser,\n    expectedTokType: TokenType,\n    follows: TokenType[]\n  ): IToken {\n    if (this.canRecoverWithSingleTokenInsertion(expectedTokType, follows)) {\n      const tokToInsert = this.getTokenToInsert(expectedTokType)\n      return tokToInsert\n    }\n\n    if (this.canRecoverWithSingleTokenDeletion(expectedTokType)) {\n      const nextTok = this.SKIP_TOKEN()\n      this.consumeToken()\n      return nextTok\n    }\n\n    throw new InRuleRecoveryException(\"sad sad panda\")\n  }\n\n  canPerformInRuleRecovery(\n    this: MixedInParser,\n    expectedToken: TokenType,\n    follows: TokenType[]\n  ): boolean {\n    return (\n      this.canRecoverWithSingleTokenInsertion(expectedToken, follows) ||\n      this.canRecoverWithSingleTokenDeletion(expectedToken)\n    )\n  }\n\n  canRecoverWithSingleTokenInsertion(\n    this: MixedInParser,\n    expectedTokType: TokenType,\n    follows: TokenType[]\n  ): boolean {\n    if (!this.canTokenTypeBeInsertedInRecovery(expectedTokType)) {\n      return false\n    }\n\n    // must know the possible following tokens to perform single token insertion\n    if (isEmpty(follows)) {\n      return false\n    }\n\n    const mismatchedTok = this.LA(1)\n    const isMisMatchedTokInFollows =\n      find(follows, (possibleFollowsTokType: TokenType) => {\n        return this.tokenMatcher(mismatchedTok, possibleFollowsTokType)\n      }) !== undefined\n\n    return isMisMatchedTokInFollows\n  }\n\n  canRecoverWithSingleTokenDeletion(\n    this: MixedInParser,\n    expectedTokType: TokenType\n  ): boolean {\n    if (!this.canTokenTypeBeDeletedInRecovery(expectedTokType)) {\n      return false\n    }\n\n    const isNextTokenWhatIsExpected = this.tokenMatcher(\n      this.LA(2),\n      expectedTokType\n    )\n    return isNextTokenWhatIsExpected\n  }\n\n  isInCurrentRuleReSyncSet(\n    this: MixedInParser,\n    tokenTypeIdx: TokenType\n  ): boolean {\n    const followKey = this.getCurrFollowKey()\n    const currentRuleReSyncSet = this.getFollowSetFromFollowKey(followKey)\n    return includes(currentRuleReSyncSet, tokenTypeIdx)\n  }\n\n  findReSyncTokenType(this: MixedInParser): TokenType {\n    const allPossibleReSyncTokTypes = this.flattenFollowSet()\n    // this loop will always terminate as EOF is always in the follow stack and also always (virtually) in the input\n    let nextToken = this.LA(1)\n    let k = 2\n    while (true) {\n      const foundMatch = find(allPossibleReSyncTokTypes, (resyncTokType) => {\n        const canMatch = tokenMatcher(nextToken, resyncTokType)\n        return canMatch\n      })\n      if (foundMatch !== undefined) {\n        return foundMatch\n      }\n      nextToken = this.LA(k)\n      k++\n    }\n  }\n\n  getCurrFollowKey(this: MixedInParser): IFollowKey {\n    // the length is at least one as we always add the ruleName to the stack before invoking the rule.\n    if (this.RULE_STACK.length === 1) {\n      return EOF_FOLLOW_KEY\n    }\n    const currRuleShortName = this.getLastExplicitRuleShortName()\n    const currRuleIdx = this.getLastExplicitRuleOccurrenceIndex()\n    const prevRuleShortName = this.getPreviousExplicitRuleShortName()\n\n    return {\n      ruleName: this.shortRuleNameToFullName(currRuleShortName),\n      idxInCallingRule: currRuleIdx,\n      inRule: this.shortRuleNameToFullName(prevRuleShortName)\n    }\n  }\n\n  buildFullFollowKeyStack(this: MixedInParser): IFollowKey[] {\n    const explicitRuleStack = this.RULE_STACK\n    const explicitOccurrenceStack = this.RULE_OCCURRENCE_STACK\n\n    return map(explicitRuleStack, (ruleName, idx) => {\n      if (idx === 0) {\n        return EOF_FOLLOW_KEY\n      }\n      return {\n        ruleName: this.shortRuleNameToFullName(ruleName),\n        idxInCallingRule: explicitOccurrenceStack[idx],\n        inRule: this.shortRuleNameToFullName(explicitRuleStack[idx - 1])\n      }\n    })\n  }\n\n  flattenFollowSet(this: MixedInParser): TokenType[] {\n    const followStack = map(this.buildFullFollowKeyStack(), (currKey) => {\n      return this.getFollowSetFromFollowKey(currKey)\n    })\n    return <any>flatten(followStack)\n  }\n\n  getFollowSetFromFollowKey(\n    this: MixedInParser,\n    followKey: IFollowKey\n  ): TokenType[] {\n    if (followKey === EOF_FOLLOW_KEY) {\n      return [EOF]\n    }\n\n    const followName =\n      followKey.ruleName + followKey.idxInCallingRule + IN + followKey.inRule\n\n    return this.resyncFollows[followName]\n  }\n\n  // It does not make any sense to include a virtual EOF token in the list of resynced tokens\n  // as EOF does not really exist and thus does not contain any useful information (line/column numbers)\n  addToResyncTokens(\n    this: MixedInParser,\n    token: IToken,\n    resyncTokens: IToken[]\n  ): IToken[] {\n    if (!this.tokenMatcher(token, EOF)) {\n      resyncTokens.push(token)\n    }\n    return resyncTokens\n  }\n\n  reSyncTo(this: MixedInParser, tokType: TokenType): IToken[] {\n    const resyncedTokens: IToken[] = []\n    let nextTok = this.LA(1)\n    while (this.tokenMatcher(nextTok, tokType) === false) {\n      nextTok = this.SKIP_TOKEN()\n      this.addToResyncTokens(nextTok, resyncedTokens)\n    }\n    // the last token is not part of the error.\n    return dropRight(resyncedTokens)\n  }\n\n  attemptInRepetitionRecovery(\n    this: MixedInParser,\n    prodFunc: Function,\n    args: any[],\n    lookaheadFunc: () => boolean,\n    dslMethodIdx: number,\n    prodOccurrence: number,\n    nextToksWalker: typeof AbstractNextTerminalAfterProductionWalker,\n    notStuck?: boolean\n  ): void {\n    // by default this is a NO-OP\n    // The actual implementation is with the function(not method) below\n  }\n\n  getCurrentGrammarPath(\n    this: MixedInParser,\n    tokType: TokenType,\n    tokIdxInRule: number\n  ): ITokenGrammarPath {\n    const pathRuleStack: string[] = this.getHumanReadableRuleStack()\n    const pathOccurrenceStack: number[] = clone(this.RULE_OCCURRENCE_STACK)\n    const grammarPath: any = {\n      ruleStack: pathRuleStack,\n      occurrenceStack: pathOccurrenceStack,\n      lastTok: tokType,\n      lastTokOccurrence: tokIdxInRule\n    }\n\n    return grammarPath\n  }\n  getHumanReadableRuleStack(this: MixedInParser): string[] {\n    return map(this.RULE_STACK, (currShortName) =>\n      this.shortRuleNameToFullName(currShortName)\n    )\n  }\n}\n\nexport function attemptInRepetitionRecovery(\n  this: MixedInParser,\n  prodFunc: Function,\n  args: any[],\n  lookaheadFunc: () => boolean,\n  dslMethodIdx: number,\n  prodOccurrence: number,\n  nextToksWalker: typeof AbstractNextTerminalAfterProductionWalker,\n  notStuck?: boolean\n): void {\n  const key = this.getKeyForAutomaticLookahead(dslMethodIdx, prodOccurrence)\n  let firstAfterRepInfo = this.firstAfterRepMap[key]\n  if (firstAfterRepInfo === undefined) {\n    const currRuleName = this.getCurrRuleFullName()\n    const ruleGrammar = this.getGAstProductions()[currRuleName]\n    const walker: AbstractNextTerminalAfterProductionWalker =\n      new nextToksWalker(ruleGrammar, prodOccurrence)\n    firstAfterRepInfo = walker.startWalking()\n    this.firstAfterRepMap[key] = firstAfterRepInfo\n  }\n\n  let expectTokAfterLastMatch = firstAfterRepInfo.token\n  let nextTokIdx = firstAfterRepInfo.occurrence\n  const isEndOfRule = firstAfterRepInfo.isEndOfRule\n\n  // special edge case of a TOP most repetition after which the input should END.\n  // this will force an attempt for inRule recovery in that scenario.\n  if (\n    this.RULE_STACK.length === 1 &&\n    isEndOfRule &&\n    expectTokAfterLastMatch === undefined\n  ) {\n    expectTokAfterLastMatch = EOF\n    nextTokIdx = 1\n  }\n\n  // We don't have anything to re-sync to...\n  // this condition was extracted from `shouldInRepetitionRecoveryBeTried` to act as a type-guard\n  if (expectTokAfterLastMatch === undefined || nextTokIdx === undefined) {\n    return\n  }\n\n  if (\n    this.shouldInRepetitionRecoveryBeTried(\n      expectTokAfterLastMatch,\n      nextTokIdx,\n      notStuck\n    )\n  ) {\n    // TODO: performance optimization: instead of passing the original args here, we modify\n    // the args param (or create a new one) and make sure the lookahead func is explicitly provided\n    // to avoid searching the cache for it once more.\n    this.tryInRepetitionRecovery(\n      prodFunc,\n      args,\n      lookaheadFunc,\n      expectTokAfterLastMatch\n    )\n  }\n}\n", "// Lookahead keys are 32Bit integers in the form\n// TTTTTTTT-ZZZZZZZZZZZZ-YYYY-XXXXXXXX\n// XXXX -> Occurrence Index bitmap.\n// YYYY -> DSL Method Type bitmap.\n// ZZZZZZZZZZZZZZZ -> Rule short Index bitmap.\n// TTTTTTTTT -> alternation alternative index bitmap\n\nexport const BITS_FOR_METHOD_TYPE = 4\nexport const BITS_FOR_OCCURRENCE_IDX = 8\nexport const BITS_FOR_RULE_IDX = 12\n// TODO: validation, this means that there may at most 2^8 --> 256 alternatives for an alternation.\nexport const BITS_FOR_ALT_IDX = 8\n\n// short string used as part of mapping keys.\n// being short improves the performance when composing KEYS for maps out of these\n// The 5 - 8 bits (16 possible values, are reserved for the DSL method indices)\nexport const OR_IDX = 1 << BITS_FOR_OCCURRENCE_IDX\nexport const OPTION_IDX = 2 << BITS_FOR_OCCURRENCE_IDX\nexport const MANY_IDX = 3 << BITS_FOR_OCCURRENCE_IDX\nexport const AT_LEAST_ONE_IDX = 4 << BITS_FOR_OCCURRENCE_IDX\nexport const MANY_SEP_IDX = 5 << BITS_FOR_OCCURRENCE_IDX\nexport const AT_LEAST_ONE_SEP_IDX = 6 << BITS_FOR_OCCURRENCE_IDX\n\n// this actually returns a number, but it is always used as a string (object prop key)\nexport function getKeyForAutomaticLookahead(\n  ruleIdx: number,\n  dslMethodIdx: number,\n  occurrence: number\n): number {\n  return occurrence | dslMethodIdx | ruleIdx\n}\n\nconst BITS_START_FOR_ALT_IDX = 32 - BITS_FOR_ALT_IDX\n", "import {\n  ILookaheadStrategy,\n  ILookaheadValidationError,\n  IOrAlt,\n  Rule,\n  TokenType,\n  OptionalProductionType\n} from \"@chevrotain/types\"\nimport flatMap from \"lodash/flatMap\"\nimport isEmpty from \"lodash/isEmpty\"\nimport { defaultGrammarValidatorErrorProvider } from \"../errors_public\"\nimport { DEFAULT_PARSER_CONFIG } from \"../parser/parser\"\nimport {\n  validateAmbiguousAlternationAlternatives,\n  validateEmptyOrAlternative,\n  validateNoLeftRecursion,\n  validateSomeNonEmptyLookaheadPath\n} from \"./checks\"\nimport {\n  buildAlternativesLookAheadFunc,\n  buildLookaheadFuncForOptionalProd,\n  buildLookaheadFuncForOr,\n  buildSingleAlternativeLookaheadFunction,\n  getProdType\n} from \"./lookahead\"\nimport { IParserDefinitionError } from \"./types\"\n\nexport class LLkLookaheadStrategy implements ILookaheadStrategy {\n  readonly maxLookahead: number\n\n  constructor(options?: { maxLookahead?: number }) {\n    this.maxLookahead =\n      options?.maxLookahead ?? DEFAULT_PARSER_CONFIG.maxLookahead\n  }\n\n  validate(options: {\n    rules: Rule[]\n    tokenTypes: TokenType[]\n    grammarName: string\n  }): ILookaheadValidationError[] {\n    const leftRecursionErrors = this.validateNoLeftRecursion(options.rules)\n\n    if (isEmpty(leftRecursionErrors)) {\n      const emptyAltErrors = this.validateEmptyOrAlternatives(options.rules)\n      const ambiguousAltsErrors = this.validateAmbiguousAlternationAlternatives(\n        options.rules,\n        this.maxLookahead\n      )\n      const emptyRepetitionErrors = this.validateSomeNonEmptyLookaheadPath(\n        options.rules,\n        this.maxLookahead\n      )\n      const allErrors = [\n        ...leftRecursionErrors,\n        ...emptyAltErrors,\n        ...ambiguousAltsErrors,\n        ...emptyRepetitionErrors\n      ]\n      return allErrors\n    }\n    return leftRecursionErrors\n  }\n\n  validateNoLeftRecursion(rules: Rule[]): IParserDefinitionError[] {\n    return flatMap(rules, (currTopRule) =>\n      validateNoLeftRecursion(\n        currTopRule,\n        currTopRule,\n        defaultGrammarValidatorErrorProvider\n      )\n    )\n  }\n\n  validateEmptyOrAlternatives(rules: Rule[]): IParserDefinitionError[] {\n    return flatMap(rules, (currTopRule) =>\n      validateEmptyOrAlternative(\n        currTopRule,\n        defaultGrammarValidatorErrorProvider\n      )\n    )\n  }\n\n  validateAmbiguousAlternationAlternatives(\n    rules: Rule[],\n    maxLookahead: number\n  ): IParserDefinitionError[] {\n    return flatMap(rules, (currTopRule) =>\n      validateAmbiguousAlternationAlternatives(\n        currTopRule,\n        maxLookahead,\n        defaultGrammarValidatorErrorProvider\n      )\n    )\n  }\n\n  validateSomeNonEmptyLookaheadPath(\n    rules: Rule[],\n    maxLookahead: number\n  ): IParserDefinitionError[] {\n    return validateSomeNonEmptyLookaheadPath(\n      rules,\n      maxLookahead,\n      defaultGrammarValidatorErrorProvider\n    )\n  }\n\n  buildLookaheadForAlternation(options: {\n    prodOccurrence: number\n    rule: Rule\n    maxLookahead: number\n    hasPredicates: boolean\n    dynamicTokensEnabled: boolean\n  }): (orAlts?: IOrAlt<any>[] | undefined) => number | undefined {\n    return buildLookaheadFuncForOr(\n      options.prodOccurrence,\n      options.rule,\n      options.maxLookahead,\n      options.hasPredicates,\n      options.dynamicTokensEnabled,\n      buildAlternativesLookAheadFunc\n    )\n  }\n\n  buildLookaheadForOptional(options: {\n    prodOccurrence: number\n    prodType: OptionalProductionType\n    rule: Rule\n    maxLookahead: number\n    dynamicTokensEnabled: boolean\n  }): () => boolean {\n    return buildLookaheadFuncForOptionalProd(\n      options.prodOccurrence,\n      options.rule,\n      options.maxLookahead,\n      options.dynamicTokensEnabled,\n      getProdType(options.prodType),\n      buildSingleAlternativeLookaheadFunction\n    )\n  }\n}\n", "import forEach from \"lodash/forEach\"\nimport has from \"lodash/has\"\nimport { DEFAULT_PARSER_CONFIG } from \"../parser\"\nimport {\n  ILookaheadStrategy,\n  IParserConfig,\n  OptionalProductionType\n} from \"@chevrotain/types\"\nimport {\n  AT_LEAST_ONE_IDX,\n  AT_LEAST_ONE_SEP_IDX,\n  getKeyForAutomaticLookahead,\n  MANY_IDX,\n  MANY_SEP_IDX,\n  OPTION_IDX,\n  OR_IDX\n} from \"../../grammar/keys\"\nimport { MixedInParser } from \"./parser_traits\"\nimport {\n  Alternation,\n  GAstVisitor,\n  Option,\n  Repetition,\n  RepetitionMandatory,\n  RepetitionMandatoryWithSeparator,\n  RepetitionWithSeparator,\n  Rule\n} from \"@chevrotain/gast\"\nimport { getProductionDslName } from \"@chevrotain/gast\"\nimport { LLkLookaheadStrategy } from \"../../grammar/llk_lookahead\"\n\n/**\n * Trait responsible for the lookahead related utilities and optimizations.\n */\nexport class LooksAhead {\n  maxLookahead: number\n  lookAheadFuncsCache: any\n  dynamicTokensEnabled: boolean\n  lookaheadStrategy: ILookaheadStrategy\n\n  initLooksAhead(config: IParserConfig) {\n    this.dynamicTokensEnabled = has(config, \"dynamicTokensEnabled\")\n      ? (config.dynamicTokensEnabled as boolean) // assumes end user provides the correct config value/type\n      : DEFAULT_PARSER_CONFIG.dynamicTokensEnabled\n\n    this.maxLookahead = has(config, \"maxLookahead\")\n      ? (config.maxLookahead as number) // assumes end user provides the correct config value/type\n      : DEFAULT_PARSER_CONFIG.maxLookahead\n\n    this.lookaheadStrategy = has(config, \"lookaheadStrategy\")\n      ? (config.lookaheadStrategy as ILookaheadStrategy) // assumes end user provides the correct config value/type\n      : new LLkLookaheadStrategy({ maxLookahead: this.maxLookahead })\n\n    this.lookAheadFuncsCache = new Map()\n  }\n\n  preComputeLookaheadFunctions(this: MixedInParser, rules: Rule[]): void {\n    forEach(rules, (currRule) => {\n      this.TRACE_INIT(`${currRule.name} Rule Lookahead`, () => {\n        const {\n          alternation,\n          repetition,\n          option,\n          repetitionMandatory,\n          repetitionMandatoryWithSeparator,\n          repetitionWithSeparator\n        } = collectMethods(currRule)\n\n        forEach(alternation, (currProd) => {\n          const prodIdx = currProd.idx === 0 ? \"\" : currProd.idx\n          this.TRACE_INIT(`${getProductionDslName(currProd)}${prodIdx}`, () => {\n            const laFunc = this.lookaheadStrategy.buildLookaheadForAlternation({\n              prodOccurrence: currProd.idx,\n              rule: currRule,\n              maxLookahead: currProd.maxLookahead || this.maxLookahead,\n              hasPredicates: currProd.hasPredicates,\n              dynamicTokensEnabled: this.dynamicTokensEnabled\n            })\n\n            const key = getKeyForAutomaticLookahead(\n              this.fullRuleNameToShort[currRule.name],\n              OR_IDX,\n              currProd.idx\n            )\n            this.setLaFuncCache(key, laFunc)\n          })\n        })\n\n        forEach(repetition, (currProd) => {\n          this.computeLookaheadFunc(\n            currRule,\n            currProd.idx,\n            MANY_IDX,\n            \"Repetition\",\n            currProd.maxLookahead,\n            getProductionDslName(currProd)\n          )\n        })\n\n        forEach(option, (currProd) => {\n          this.computeLookaheadFunc(\n            currRule,\n            currProd.idx,\n            OPTION_IDX,\n            \"Option\",\n            currProd.maxLookahead,\n            getProductionDslName(currProd)\n          )\n        })\n\n        forEach(repetitionMandatory, (currProd) => {\n          this.computeLookaheadFunc(\n            currRule,\n            currProd.idx,\n            AT_LEAST_ONE_IDX,\n            \"RepetitionMandatory\",\n            currProd.maxLookahead,\n            getProductionDslName(currProd)\n          )\n        })\n\n        forEach(repetitionMandatoryWithSeparator, (currProd) => {\n          this.computeLookaheadFunc(\n            currRule,\n            currProd.idx,\n            AT_LEAST_ONE_SEP_IDX,\n            \"RepetitionMandatoryWithSeparator\",\n            currProd.maxLookahead,\n            getProductionDslName(currProd)\n          )\n        })\n\n        forEach(repetitionWithSeparator, (currProd) => {\n          this.computeLookaheadFunc(\n            currRule,\n            currProd.idx,\n            MANY_SEP_IDX,\n            \"RepetitionWithSeparator\",\n            currProd.maxLookahead,\n            getProductionDslName(currProd)\n          )\n        })\n      })\n    })\n  }\n\n  computeLookaheadFunc(\n    this: MixedInParser,\n    rule: Rule,\n    prodOccurrence: number,\n    prodKey: number,\n    prodType: OptionalProductionType,\n    prodMaxLookahead: number | undefined,\n    dslMethodName: string\n  ): void {\n    this.TRACE_INIT(\n      `${dslMethodName}${prodOccurrence === 0 ? \"\" : prodOccurrence}`,\n      () => {\n        const laFunc = this.lookaheadStrategy.buildLookaheadForOptional({\n          prodOccurrence,\n          rule,\n          maxLookahead: prodMaxLookahead || this.maxLookahead,\n          dynamicTokensEnabled: this.dynamicTokensEnabled,\n          prodType\n        })\n        const key = getKeyForAutomaticLookahead(\n          this.fullRuleNameToShort[rule.name],\n          prodKey,\n          prodOccurrence\n        )\n        this.setLaFuncCache(key, laFunc)\n      }\n    )\n  }\n\n  // this actually returns a number, but it is always used as a string (object prop key)\n  getKeyForAutomaticLookahead(\n    this: MixedInParser,\n    dslMethodIdx: number,\n    occurrence: number\n  ): number {\n    const currRuleShortName: any = this.getLastExplicitRuleShortName()\n    return getKeyForAutomaticLookahead(\n      currRuleShortName,\n      dslMethodIdx,\n      occurrence\n    )\n  }\n\n  getLaFuncFromCache(this: MixedInParser, key: number): Function {\n    return this.lookAheadFuncsCache.get(key)\n  }\n\n  /* istanbul ignore next */\n  setLaFuncCache(this: MixedInParser, key: number, value: Function): void {\n    this.lookAheadFuncsCache.set(key, value)\n  }\n}\n\nclass DslMethodsCollectorVisitor extends GAstVisitor {\n  public dslMethods: {\n    option: Option[]\n    alternation: Alternation[]\n    repetition: Repetition[]\n    repetitionWithSeparator: RepetitionWithSeparator[]\n    repetitionMandatory: RepetitionMandatory[]\n    repetitionMandatoryWithSeparator: RepetitionMandatoryWithSeparator[]\n  } = {\n    option: [],\n    alternation: [],\n    repetition: [],\n    repetitionWithSeparator: [],\n    repetitionMandatory: [],\n    repetitionMandatoryWithSeparator: []\n  }\n\n  reset() {\n    this.dslMethods = {\n      option: [],\n      alternation: [],\n      repetition: [],\n      repetitionWithSeparator: [],\n      repetitionMandatory: [],\n      repetitionMandatoryWithSeparator: []\n    }\n  }\n\n  public visitOption(option: Option): void {\n    this.dslMethods.option.push(option)\n  }\n\n  public visitRepetitionWithSeparator(manySep: RepetitionWithSeparator): void {\n    this.dslMethods.repetitionWithSeparator.push(manySep)\n  }\n\n  public visitRepetitionMandatory(atLeastOne: RepetitionMandatory): void {\n    this.dslMethods.repetitionMandatory.push(atLeastOne)\n  }\n\n  public visitRepetitionMandatoryWithSeparator(\n    atLeastOneSep: RepetitionMandatoryWithSeparator\n  ): void {\n    this.dslMethods.repetitionMandatoryWithSeparator.push(atLeastOneSep)\n  }\n\n  public visitRepetition(many: Repetition): void {\n    this.dslMethods.repetition.push(many)\n  }\n\n  public visitAlternation(or: Alternation): void {\n    this.dslMethods.alternation.push(or)\n  }\n}\n\nconst collectorVisitor = new DslMethodsCollectorVisitor()\nexport function collectMethods(rule: Rule): {\n  option: Option[]\n  alternation: Alternation[]\n  repetition: Repetition[]\n  repetitionWithSeparator: RepetitionWithSeparator[]\n  repetitionMandatory: RepetitionMandatory[]\n  repetitionMandatoryWithSeparator: RepetitionMandatoryWithSeparator[]\n} {\n  collectorVisitor.reset()\n  rule.accept(collectorVisitor)\n  const dslMethods = collectorVisitor.dslMethods\n  // avoid uncleaned references\n  collectorVisitor.reset()\n  return <any>dslMethods\n}\n", "import { CstNode, CstNodeLocation, IToken } from \"@chevrotain/types\"\n\n/**\n * This nodeLocation tracking is not efficient and should only be used\n * when error recovery is enabled or the Token Vector contains virtual Tokens\n * (e.g, Python Indent/Outdent)\n * As it executes the calculation for every single terminal/nonTerminal\n * and does not rely on the fact the token vector is **sorted**\n */\nexport function setNodeLocationOnlyOffset(\n  currNodeLocation: CstNodeLocation,\n  newLocationInfo: Required<Pick<IToken, \"startOffset\" | \"endOffset\">>\n): void {\n  // First (valid) update for this cst node\n  if (isNaN(currNodeLocation.startOffset) === true) {\n    // assumption1: Token location information is either NaN or a valid number\n    // assumption2: Token location information is fully valid if it exist\n    // (both start/end offsets exist and are numbers).\n    currNodeLocation.startOffset = newLocationInfo.startOffset\n    currNodeLocation.endOffset = newLocationInfo.endOffset\n  }\n  // Once the startOffset has been updated with a valid number it should never receive\n  // any farther updates as the Token vector is sorted.\n  // We still have to check this this condition for every new possible location info\n  // because with error recovery enabled we may encounter invalid tokens (NaN location props)\n  else if (currNodeLocation.endOffset! < newLocationInfo.endOffset === true) {\n    currNodeLocation.endOffset = newLocationInfo.endOffset\n  }\n}\n\n/**\n * This nodeLocation tracking is not efficient and should only be used\n * when error recovery is enabled or the Token Vector contains virtual Tokens\n * (e.g, Python Indent/Outdent)\n * As it executes the calculation for every single terminal/nonTerminal\n * and does not rely on the fact the token vector is **sorted**\n */\nexport function setNodeLocationFull(\n  currNodeLocation: CstNodeLocation,\n  newLocationInfo: CstNodeLocation\n): void {\n  // First (valid) update for this cst node\n  if (isNaN(currNodeLocation.startOffset) === true) {\n    // assumption1: Token location information is either NaN or a valid number\n    // assumption2: Token location information is fully valid if it exist\n    // (all start/end props exist and are numbers).\n    currNodeLocation.startOffset = newLocationInfo.startOffset\n    currNodeLocation.startColumn = newLocationInfo.startColumn\n    currNodeLocation.startLine = newLocationInfo.startLine\n    currNodeLocation.endOffset = newLocationInfo.endOffset\n    currNodeLocation.endColumn = newLocationInfo.endColumn\n    currNodeLocation.endLine = newLocationInfo.endLine\n  }\n  // Once the start props has been updated with a valid number it should never receive\n  // any farther updates as the Token vector is sorted.\n  // We still have to check this this condition for every new possible location info\n  // because with error recovery enabled we may encounter invalid tokens (NaN location props)\n  else if (currNodeLocation.endOffset! < newLocationInfo.endOffset! === true) {\n    currNodeLocation.endOffset = newLocationInfo.endOffset\n    currNodeLocation.endColumn = newLocationInfo.endColumn\n    currNodeLocation.endLine = newLocationInfo.endLine\n  }\n}\n\nexport function addTerminalToCst(\n  node: CstNode,\n  token: IToken,\n  tokenTypeName: string\n): void {\n  if (node.children[tokenTypeName] === undefined) {\n    node.children[tokenTypeName] = [token]\n  } else {\n    node.children[tokenTypeName].push(token)\n  }\n}\n\nexport function addNoneTerminalToCst(\n  node: CstNode,\n  ruleName: string,\n  ruleResult: any\n): void {\n  if (node.children[ruleName] === undefined) {\n    node.children[ruleName] = [ruleResult]\n  } else {\n    node.children[ruleName].push(ruleResult)\n  }\n}\n", "const NAME = \"name\"\n\nexport function defineNameProp(obj: {}, nameValue: string): void {\n  Object.defineProperty(obj, NAME, {\n    enumerable: false,\n    configurable: true,\n    writable: false,\n    value: nameValue\n  })\n}\n", "import isEmpty from \"lodash/isEmpty\"\nimport compact from \"lodash/compact\"\nimport isArray from \"lodash/isArray\"\nimport map from \"lodash/map\"\nimport forEach from \"lodash/forEach\"\nimport filter from \"lodash/filter\"\nimport keys from \"lodash/keys\"\nimport isFunction from \"lodash/isFunction\"\nimport isUndefined from \"lodash/isUndefined\"\nimport { defineNameProp } from \"../../lang/lang_extensions\"\nimport { CstNode, ICstVisitor } from \"@chevrotain/types\"\n\nexport function defaultVisit<IN>(ctx: any, param: IN): void {\n  const childrenNames = keys(ctx)\n  const childrenNamesLength = childrenNames.length\n  for (let i = 0; i < childrenNamesLength; i++) {\n    const currChildName = childrenNames[i]\n    const currChildArray = ctx[currChildName]\n    const currChildArrayLength = currChildArray.length\n    for (let j = 0; j < currChildArrayLength; j++) {\n      const currChild: any = currChildArray[j]\n      // distinction between Tokens Children and CstNode children\n      if (currChild.tokenTypeIdx === undefined) {\n        this[currChild.name](currChild.children, param)\n      }\n    }\n  }\n  // defaultVisit does not support generic out param\n}\n\nexport function createBaseSemanticVisitorConstructor(\n  grammarName: string,\n  ruleNames: string[]\n): {\n  new (...args: any[]): ICstVisitor<any, any>\n} {\n  const derivedConstructor: any = function () {}\n\n  // can be overwritten according to:\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/\n  // name?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FFunction%2Fname\n  defineNameProp(derivedConstructor, grammarName + \"BaseSemantics\")\n\n  const semanticProto = {\n    visit: function (cstNode: CstNode | CstNode[], param: any) {\n      // enables writing more concise visitor methods when CstNode has only a single child\n      if (isArray(cstNode)) {\n        // A CST Node's children dictionary can never have empty arrays as values\n        // If a key is defined there will be at least one element in the corresponding value array.\n        cstNode = cstNode[0]\n      }\n\n      // enables passing optional CstNodes concisely.\n      if (isUndefined(cstNode)) {\n        return undefined\n      }\n\n      return this[cstNode.name](cstNode.children, param)\n    },\n\n    validateVisitor: function () {\n      const semanticDefinitionErrors = validateVisitor(this, ruleNames)\n      if (!isEmpty(semanticDefinitionErrors)) {\n        const errorMessages = map(\n          semanticDefinitionErrors,\n          (currDefError) => currDefError.msg\n        )\n        throw Error(\n          `Errors Detected in CST Visitor <${this.constructor.name}>:\\n\\t` +\n            `${errorMessages.join(\"\\n\\n\").replace(/\\n/g, \"\\n\\t\")}`\n        )\n      }\n    }\n  }\n\n  derivedConstructor.prototype = semanticProto\n  derivedConstructor.prototype.constructor = derivedConstructor\n\n  derivedConstructor._RULE_NAMES = ruleNames\n\n  return derivedConstructor\n}\n\nexport function createBaseVisitorConstructorWithDefaults(\n  grammarName: string,\n  ruleNames: string[],\n  baseConstructor: Function\n): {\n  new (...args: any[]): ICstVisitor<any, any>\n} {\n  const derivedConstructor: any = function () {}\n\n  // can be overwritten according to:\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/\n  // name?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FFunction%2Fname\n  defineNameProp(derivedConstructor, grammarName + \"BaseSemanticsWithDefaults\")\n\n  const withDefaultsProto = Object.create(baseConstructor.prototype)\n  forEach(ruleNames, (ruleName) => {\n    withDefaultsProto[ruleName] = defaultVisit\n  })\n\n  derivedConstructor.prototype = withDefaultsProto\n  derivedConstructor.prototype.constructor = derivedConstructor\n\n  return derivedConstructor\n}\n\nexport enum CstVisitorDefinitionError {\n  REDUNDANT_METHOD,\n  MISSING_METHOD\n}\n\nexport interface IVisitorDefinitionError {\n  msg: string\n  type: CstVisitorDefinitionError\n  methodName: string\n}\n\nexport function validateVisitor(\n  visitorInstance: ICstVisitor<unknown, unknown>,\n  ruleNames: string[]\n): IVisitorDefinitionError[] {\n  const missingErrors = validateMissingCstMethods(visitorInstance, ruleNames)\n\n  return missingErrors\n}\n\nexport function validateMissingCstMethods(\n  visitorInstance: ICstVisitor<unknown, unknown>,\n  ruleNames: string[]\n): IVisitorDefinitionError[] {\n  const missingRuleNames = filter(ruleNames, (currRuleName) => {\n    return isFunction((visitorInstance as any)[currRuleName]) === false\n  })\n\n  const errors: IVisitorDefinitionError[] = map(\n    missingRuleNames,\n    (currRuleName) => {\n      return {\n        msg: `Missing visitor method: <${currRuleName}> on ${<any>(\n          visitorInstance.constructor.name\n        )} CST Visitor.`,\n        type: CstVisitorDefinitionError.MISSING_METHOD,\n        methodName: currRuleName\n      }\n    }\n  )\n\n  return compact<IVisitorDefinitionError>(errors)\n}\n", "import {\n  addNoneTerminalToCst,\n  addTerminalToCst,\n  setNodeLocationFull,\n  setNodeLocationOnlyOffset\n} from \"../../cst/cst\"\nimport noop from \"lodash/noop\"\nimport has from \"lodash/has\"\nimport keys from \"lodash/keys\"\nimport isUndefined from \"lodash/isUndefined\"\nimport {\n  createBaseSemanticVisitorConstructor,\n  createBaseVisitorConstructorWithDefaults\n} from \"../../cst/cst_visitor\"\nimport {\n  CstNode,\n  CstNodeLocation,\n  ICstVisitor,\n  IParserConfig,\n  IToken,\n  nodeLocationTrackingOptions\n} from \"@chevrotain/types\"\nimport { MixedInParser } from \"./parser_traits\"\nimport { DEFAULT_PARSER_CONFIG } from \"../parser\"\n\n/**\n * This trait is responsible for the CST building logic.\n */\nexport class TreeBuilder {\n  outputCst: boolean\n  CST_STACK: CstNode[]\n  baseCstVisitorConstructor: Function\n  baseCstVisitorWithDefaultsConstructor: Function\n\n  // dynamically assigned Methods\n  setNodeLocationFromNode: (\n    nodeLocation: CstNodeLocation,\n    locationInformation: CstNodeLocation\n  ) => void\n  setNodeLocationFromToken: (\n    nodeLocation: CstNodeLocation,\n    locationInformation: CstNodeLocation\n  ) => void\n  cstPostRule: (this: MixedInParser, ruleCstNode: CstNode) => void\n\n  setInitialNodeLocation: (cstNode: CstNode) => void\n  nodeLocationTracking: nodeLocationTrackingOptions\n\n  initTreeBuilder(this: MixedInParser, config: IParserConfig) {\n    this.CST_STACK = []\n\n    // outputCst is no longer exposed/defined in the pubic API\n    this.outputCst = (config as any).outputCst\n\n    this.nodeLocationTracking = has(config, \"nodeLocationTracking\")\n      ? (config.nodeLocationTracking as nodeLocationTrackingOptions) // assumes end user provides the correct config value/type\n      : DEFAULT_PARSER_CONFIG.nodeLocationTracking\n\n    if (!this.outputCst) {\n      this.cstInvocationStateUpdate = noop\n      this.cstFinallyStateUpdate = noop\n      this.cstPostTerminal = noop\n      this.cstPostNonTerminal = noop\n      this.cstPostRule = noop\n    } else {\n      if (/full/i.test(this.nodeLocationTracking)) {\n        if (this.recoveryEnabled) {\n          this.setNodeLocationFromToken = setNodeLocationFull\n          this.setNodeLocationFromNode = setNodeLocationFull\n          this.cstPostRule = noop\n          this.setInitialNodeLocation = this.setInitialNodeLocationFullRecovery\n        } else {\n          this.setNodeLocationFromToken = noop\n          this.setNodeLocationFromNode = noop\n          this.cstPostRule = this.cstPostRuleFull\n          this.setInitialNodeLocation = this.setInitialNodeLocationFullRegular\n        }\n      } else if (/onlyOffset/i.test(this.nodeLocationTracking)) {\n        if (this.recoveryEnabled) {\n          this.setNodeLocationFromToken = <any>setNodeLocationOnlyOffset\n          this.setNodeLocationFromNode = <any>setNodeLocationOnlyOffset\n          this.cstPostRule = noop\n          this.setInitialNodeLocation =\n            this.setInitialNodeLocationOnlyOffsetRecovery\n        } else {\n          this.setNodeLocationFromToken = noop\n          this.setNodeLocationFromNode = noop\n          this.cstPostRule = this.cstPostRuleOnlyOffset\n          this.setInitialNodeLocation =\n            this.setInitialNodeLocationOnlyOffsetRegular\n        }\n      } else if (/none/i.test(this.nodeLocationTracking)) {\n        this.setNodeLocationFromToken = noop\n        this.setNodeLocationFromNode = noop\n        this.cstPostRule = noop\n        this.setInitialNodeLocation = noop\n      } else {\n        throw Error(\n          `Invalid <nodeLocationTracking> config option: \"${config.nodeLocationTracking}\"`\n        )\n      }\n    }\n  }\n\n  setInitialNodeLocationOnlyOffsetRecovery(\n    this: MixedInParser,\n    cstNode: any\n  ): void {\n    cstNode.location = {\n      startOffset: NaN,\n      endOffset: NaN\n    }\n  }\n\n  setInitialNodeLocationOnlyOffsetRegular(\n    this: MixedInParser,\n    cstNode: any\n  ): void {\n    cstNode.location = {\n      // without error recovery the starting Location of a new CstNode is guaranteed\n      // To be the next Token's startOffset (for valid inputs).\n      // For invalid inputs there won't be any CSTOutput so this potential\n      // inaccuracy does not matter\n      startOffset: this.LA(1).startOffset,\n      endOffset: NaN\n    }\n  }\n\n  setInitialNodeLocationFullRecovery(this: MixedInParser, cstNode: any): void {\n    cstNode.location = {\n      startOffset: NaN,\n      startLine: NaN,\n      startColumn: NaN,\n      endOffset: NaN,\n      endLine: NaN,\n      endColumn: NaN\n    }\n  }\n\n  /**\n     *  @see setInitialNodeLocationOnlyOffsetRegular for explanation why this work\n\n     * @param cstNode\n     */\n  setInitialNodeLocationFullRegular(this: MixedInParser, cstNode: any): void {\n    const nextToken = this.LA(1)\n    cstNode.location = {\n      startOffset: nextToken.startOffset,\n      startLine: nextToken.startLine,\n      startColumn: nextToken.startColumn,\n      endOffset: NaN,\n      endLine: NaN,\n      endColumn: NaN\n    }\n  }\n\n  cstInvocationStateUpdate(this: MixedInParser, fullRuleName: string): void {\n    const cstNode: CstNode = {\n      name: fullRuleName,\n      children: Object.create(null)\n    }\n\n    this.setInitialNodeLocation(cstNode)\n    this.CST_STACK.push(cstNode)\n  }\n\n  cstFinallyStateUpdate(this: MixedInParser): void {\n    this.CST_STACK.pop()\n  }\n\n  cstPostRuleFull(this: MixedInParser, ruleCstNode: CstNode): void {\n    // casts to `required<CstNodeLocation>` are safe because `cstPostRuleFull` should only be invoked when full location is enabled\n    const prevToken = this.LA(0) as Required<CstNodeLocation>\n    const loc = ruleCstNode.location as Required<CstNodeLocation>\n\n    // If this condition is true it means we consumed at least one Token\n    // In this CstNode.\n    if (loc.startOffset <= prevToken.startOffset === true) {\n      loc.endOffset = prevToken.endOffset\n      loc.endLine = prevToken.endLine\n      loc.endColumn = prevToken.endColumn\n    }\n    // \"empty\" CstNode edge case\n    else {\n      loc.startOffset = NaN\n      loc.startLine = NaN\n      loc.startColumn = NaN\n    }\n  }\n\n  cstPostRuleOnlyOffset(this: MixedInParser, ruleCstNode: CstNode): void {\n    const prevToken = this.LA(0)\n    // `location' is not null because `cstPostRuleOnlyOffset` will only be invoked when location tracking is enabled.\n    const loc = ruleCstNode.location!\n\n    // If this condition is true it means we consumed at least one Token\n    // In this CstNode.\n    if (loc.startOffset <= prevToken.startOffset === true) {\n      loc.endOffset = prevToken.endOffset\n    }\n    // \"empty\" CstNode edge case\n    else {\n      loc.startOffset = NaN\n    }\n  }\n\n  cstPostTerminal(\n    this: MixedInParser,\n    key: string,\n    consumedToken: IToken\n  ): void {\n    const rootCst = this.CST_STACK[this.CST_STACK.length - 1]\n    addTerminalToCst(rootCst, consumedToken, key)\n    // This is only used when **both** error recovery and CST Output are enabled.\n    this.setNodeLocationFromToken(rootCst.location!, <any>consumedToken)\n  }\n\n  cstPostNonTerminal(\n    this: MixedInParser,\n    ruleCstResult: CstNode,\n    ruleName: string\n  ): void {\n    const preCstNode = this.CST_STACK[this.CST_STACK.length - 1]\n    addNoneTerminalToCst(preCstNode, ruleName, ruleCstResult)\n    // This is only used when **both** error recovery and CST Output are enabled.\n    this.setNodeLocationFromNode(preCstNode.location!, ruleCstResult.location!)\n  }\n\n  getBaseCstVisitorConstructor<IN = any, OUT = any>(\n    this: MixedInParser\n  ): {\n    new (...args: any[]): ICstVisitor<IN, OUT>\n  } {\n    if (isUndefined(this.baseCstVisitorConstructor)) {\n      const newBaseCstVisitorConstructor = createBaseSemanticVisitorConstructor(\n        this.className,\n        keys(this.gastProductionsCache)\n      )\n      this.baseCstVisitorConstructor = newBaseCstVisitorConstructor\n      return newBaseCstVisitorConstructor\n    }\n\n    return <any>this.baseCstVisitorConstructor\n  }\n\n  getBaseCstVisitorConstructorWithDefaults<IN = any, OUT = any>(\n    this: MixedInParser\n  ): {\n    new (...args: any[]): ICstVisitor<IN, OUT>\n  } {\n    if (isUndefined(this.baseCstVisitorWithDefaultsConstructor)) {\n      const newConstructor = createBaseVisitorConstructorWithDefaults(\n        this.className,\n        keys(this.gastProductionsCache),\n        this.getBaseCstVisitorConstructor()\n      )\n      this.baseCstVisitorWithDefaultsConstructor = newConstructor\n      return newConstructor\n    }\n\n    return <any>this.baseCstVisitorWithDefaultsConstructor\n  }\n\n  getLastExplicitRuleShortName(this: MixedInParser): number {\n    const ruleStack = this.RULE_STACK\n    return ruleStack[ruleStack.length - 1]\n  }\n\n  getPreviousExplicitRuleShortName(this: MixedInParser): number {\n    const ruleStack = this.RULE_STACK\n    return ruleStack[ruleStack.length - 2]\n  }\n\n  getLastExplicitRuleOccurrenceIndex(this: MixedInParser): number {\n    const occurrenceStack = this.RULE_OCCURRENCE_STACK\n    return occurrenceStack[occurrenceStack.length - 1]\n  }\n}\n", "import { END_OF_FILE } from \"../parser\"\nimport { IToken } from \"@chevrotain/types\"\nimport { MixedInParser } from \"./parser_traits\"\n\n/**\n * Trait responsible abstracting over the interaction with Lexer output (Token vector).\n *\n * This could be generalized to support other kinds of lexers, e.g.\n * - Just in Time Lexing / Lexer-Less parsing.\n * - Streaming Lexer.\n */\nexport class LexerAdapter {\n  tokVector: IToken[]\n  tokVectorLength: number\n  currIdx: number\n\n  initLexerAdapter() {\n    this.tokVector = []\n    this.tokVectorLength = 0\n    this.currIdx = -1\n  }\n\n  set input(newInput: IToken[]) {\n    // @ts-ignore - `this parameter` not supported in setters/getters\n    //   - https://www.typescriptlang.org/docs/handbook/functions.html#this-parameters\n    if (this.selfAnalysisDone !== true) {\n      throw Error(\n        `Missing <performSelfAnalysis> invocation at the end of the Parser's constructor.`\n      )\n    }\n    // @ts-ignore - `this parameter` not supported in setters/getters\n    //   - https://www.typescriptlang.org/docs/handbook/functions.html#this-parameters\n    this.reset()\n    this.tokVector = newInput\n    this.tokVectorLength = newInput.length\n  }\n\n  get input(): IToken[] {\n    return this.tokVector\n  }\n\n  // skips a token and returns the next token\n  SKIP_TOKEN(this: MixedInParser): IToken {\n    if (this.currIdx <= this.tokVector.length - 2) {\n      this.consumeToken()\n      return this.LA(1)\n    } else {\n      return END_OF_FILE\n    }\n  }\n\n  // Lexer (accessing Token vector) related methods which can be overridden to implement lazy lexers\n  // or lexers dependent on parser context.\n  LA(this: MixedInParser, howMuch: number): IToken {\n    const soughtIdx = this.currIdx + howMuch\n    if (soughtIdx < 0 || this.tokVectorLength <= soughtIdx) {\n      return END_OF_FILE\n    } else {\n      return this.tokVector[soughtIdx]\n    }\n  }\n\n  consumeToken(this: MixedInParser) {\n    this.currIdx++\n  }\n\n  exportLexerState(this: MixedInParser): number {\n    return this.currIdx\n  }\n\n  importLexerState(this: MixedInParser, newState: number) {\n    this.currIdx = newState\n  }\n\n  resetLexerState(this: MixedInParser): void {\n    this.currIdx = -1\n  }\n\n  moveToTerminatedState(this: MixedInParser): void {\n    this.currIdx = this.tokVector.length - 1\n  }\n\n  getLexerPosition(this: MixedInParser): number {\n    return this.exportLexerState()\n  }\n}\n", "import {\n  AtLeastOneSepMethodOpts,\n  ConsumeMethodOpts,\n  DSLMethodOpts,\n  DSLMethodOptsWithErr,\n  GrammarAction,\n  IOrAlt,\n  IRuleConfig,\n  ISerializedGast,\n  IToken,\n  ManySepMethodOpts,\n  OrMethodOpts,\n  SubruleMethodOpts,\n  TokenType\n} from \"@chevrotain/types\"\nimport values from \"lodash/values\"\nimport includes from \"lodash/includes\"\nimport { isRecognitionException } from \"../../exceptions_public\"\nimport { DEFAULT_RULE_CONFIG, ParserDefinitionErrorType } from \"../parser\"\nimport { defaultGrammarValidatorErrorProvider } from \"../../errors_public\"\nimport { validateRuleIsOverridden } from \"../../grammar/checks\"\nimport { MixedInParser } from \"./parser_traits\"\nimport { Rule, serializeGrammar } from \"@chevrotain/gast\"\nimport { IParserDefinitionError } from \"../../grammar/types\"\nimport { ParserMethodInternal } from \"../types\"\n\n/**\n * This trait is responsible for implementing the public API\n * for defining Chevrotain parsers, i.e:\n * - CONSUME\n * - RULE\n * - OPTION\n * - ...\n */\nexport class RecognizerApi {\n  ACTION<T>(this: MixedInParser, impl: () => T): T {\n    return impl.call(this)\n  }\n\n  consume(\n    this: MixedInParser,\n    idx: number,\n    tokType: TokenType,\n    options?: ConsumeMethodOpts\n  ): IToken {\n    return this.consumeInternal(tokType, idx, options)\n  }\n\n  subrule<ARGS extends unknown[], R>(\n    this: MixedInParser,\n    idx: number,\n    ruleToCall: ParserMethodInternal<ARGS, R>,\n    options?: SubruleMethodOpts<ARGS>\n  ): R {\n    return this.subruleInternal(ruleToCall, idx, options)\n  }\n\n  option<OUT>(\n    this: MixedInParser,\n    idx: number,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>\n  ): OUT | undefined {\n    return this.optionInternal(actionORMethodDef, idx)\n  }\n\n  or(\n    this: MixedInParser,\n    idx: number,\n    altsOrOpts: IOrAlt<any>[] | OrMethodOpts<any>\n  ): any {\n    return this.orInternal(altsOrOpts, idx)\n  }\n\n  many(\n    this: MixedInParser,\n    idx: number,\n    actionORMethodDef: GrammarAction<any> | DSLMethodOpts<any>\n  ): void {\n    return this.manyInternal(idx, actionORMethodDef)\n  }\n\n  atLeastOne(\n    this: MixedInParser,\n    idx: number,\n    actionORMethodDef: GrammarAction<any> | DSLMethodOptsWithErr<any>\n  ): void {\n    return this.atLeastOneInternal(idx, actionORMethodDef)\n  }\n\n  CONSUME(\n    this: MixedInParser,\n    tokType: TokenType,\n    options?: ConsumeMethodOpts\n  ): IToken {\n    return this.consumeInternal(tokType, 0, options)\n  }\n\n  CONSUME1(\n    this: MixedInParser,\n    tokType: TokenType,\n    options?: ConsumeMethodOpts\n  ): IToken {\n    return this.consumeInternal(tokType, 1, options)\n  }\n\n  CONSUME2(\n    this: MixedInParser,\n    tokType: TokenType,\n    options?: ConsumeMethodOpts\n  ): IToken {\n    return this.consumeInternal(tokType, 2, options)\n  }\n\n  CONSUME3(\n    this: MixedInParser,\n    tokType: TokenType,\n    options?: ConsumeMethodOpts\n  ): IToken {\n    return this.consumeInternal(tokType, 3, options)\n  }\n\n  CONSUME4(\n    this: MixedInParser,\n    tokType: TokenType,\n    options?: ConsumeMethodOpts\n  ): IToken {\n    return this.consumeInternal(tokType, 4, options)\n  }\n\n  CONSUME5(\n    this: MixedInParser,\n    tokType: TokenType,\n    options?: ConsumeMethodOpts\n  ): IToken {\n    return this.consumeInternal(tokType, 5, options)\n  }\n\n  CONSUME6(\n    this: MixedInParser,\n    tokType: TokenType,\n    options?: ConsumeMethodOpts\n  ): IToken {\n    return this.consumeInternal(tokType, 6, options)\n  }\n\n  CONSUME7(\n    this: MixedInParser,\n    tokType: TokenType,\n    options?: ConsumeMethodOpts\n  ): IToken {\n    return this.consumeInternal(tokType, 7, options)\n  }\n\n  CONSUME8(\n    this: MixedInParser,\n    tokType: TokenType,\n    options?: ConsumeMethodOpts\n  ): IToken {\n    return this.consumeInternal(tokType, 8, options)\n  }\n\n  CONSUME9(\n    this: MixedInParser,\n    tokType: TokenType,\n    options?: ConsumeMethodOpts\n  ): IToken {\n    return this.consumeInternal(tokType, 9, options)\n  }\n\n  SUBRULE<ARGS extends unknown[], R>(\n    this: MixedInParser,\n    ruleToCall: ParserMethodInternal<ARGS, R>,\n    options?: SubruleMethodOpts<ARGS>\n  ): R {\n    return this.subruleInternal(ruleToCall, 0, options)\n  }\n\n  SUBRULE1<ARGS extends unknown[], R>(\n    this: MixedInParser,\n    ruleToCall: ParserMethodInternal<ARGS, R>,\n    options?: SubruleMethodOpts<ARGS>\n  ): R {\n    return this.subruleInternal(ruleToCall, 1, options)\n  }\n\n  SUBRULE2<ARGS extends unknown[], R>(\n    this: MixedInParser,\n    ruleToCall: ParserMethodInternal<ARGS, R>,\n    options?: SubruleMethodOpts<ARGS>\n  ): R {\n    return this.subruleInternal(ruleToCall, 2, options)\n  }\n\n  SUBRULE3<ARGS extends unknown[], R>(\n    this: MixedInParser,\n    ruleToCall: ParserMethodInternal<ARGS, R>,\n    options?: SubruleMethodOpts<ARGS>\n  ): R {\n    return this.subruleInternal(ruleToCall, 3, options)\n  }\n\n  SUBRULE4<ARGS extends unknown[], R>(\n    this: MixedInParser,\n    ruleToCall: ParserMethodInternal<ARGS, R>,\n    options?: SubruleMethodOpts<ARGS>\n  ): R {\n    return this.subruleInternal(ruleToCall, 4, options)\n  }\n\n  SUBRULE5<ARGS extends unknown[], R>(\n    this: MixedInParser,\n    ruleToCall: ParserMethodInternal<ARGS, R>,\n    options?: SubruleMethodOpts<ARGS>\n  ): R {\n    return this.subruleInternal(ruleToCall, 5, options)\n  }\n\n  SUBRULE6<ARGS extends unknown[], R>(\n    this: MixedInParser,\n    ruleToCall: ParserMethodInternal<ARGS, R>,\n    options?: SubruleMethodOpts<ARGS>\n  ): R {\n    return this.subruleInternal(ruleToCall, 6, options)\n  }\n\n  SUBRULE7<ARGS extends unknown[], R>(\n    this: MixedInParser,\n    ruleToCall: ParserMethodInternal<ARGS, R>,\n    options?: SubruleMethodOpts<ARGS>\n  ): R {\n    return this.subruleInternal(ruleToCall, 7, options)\n  }\n\n  SUBRULE8<ARGS extends unknown[], R>(\n    this: MixedInParser,\n    ruleToCall: ParserMethodInternal<ARGS, R>,\n    options?: SubruleMethodOpts<ARGS>\n  ): R {\n    return this.subruleInternal(ruleToCall, 8, options)\n  }\n\n  SUBRULE9<ARGS extends unknown[], R>(\n    this: MixedInParser,\n    ruleToCall: ParserMethodInternal<ARGS, R>,\n    options?: SubruleMethodOpts<ARGS>\n  ): R {\n    return this.subruleInternal(ruleToCall, 9, options)\n  }\n\n  OPTION<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>\n  ): OUT | undefined {\n    return this.optionInternal(actionORMethodDef, 0)\n  }\n\n  OPTION1<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>\n  ): OUT | undefined {\n    return this.optionInternal(actionORMethodDef, 1)\n  }\n\n  OPTION2<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>\n  ): OUT | undefined {\n    return this.optionInternal(actionORMethodDef, 2)\n  }\n\n  OPTION3<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>\n  ): OUT | undefined {\n    return this.optionInternal(actionORMethodDef, 3)\n  }\n\n  OPTION4<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>\n  ): OUT | undefined {\n    return this.optionInternal(actionORMethodDef, 4)\n  }\n\n  OPTION5<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>\n  ): OUT | undefined {\n    return this.optionInternal(actionORMethodDef, 5)\n  }\n\n  OPTION6<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>\n  ): OUT | undefined {\n    return this.optionInternal(actionORMethodDef, 6)\n  }\n\n  OPTION7<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>\n  ): OUT | undefined {\n    return this.optionInternal(actionORMethodDef, 7)\n  }\n\n  OPTION8<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>\n  ): OUT | undefined {\n    return this.optionInternal(actionORMethodDef, 8)\n  }\n\n  OPTION9<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>\n  ): OUT | undefined {\n    return this.optionInternal(actionORMethodDef, 9)\n  }\n\n  OR<T>(\n    this: MixedInParser,\n    altsOrOpts: IOrAlt<any>[] | OrMethodOpts<unknown>\n  ): T {\n    return this.orInternal(altsOrOpts, 0)\n  }\n\n  OR1<T>(\n    this: MixedInParser,\n    altsOrOpts: IOrAlt<any>[] | OrMethodOpts<unknown>\n  ): T {\n    return this.orInternal(altsOrOpts, 1)\n  }\n\n  OR2<T>(\n    this: MixedInParser,\n    altsOrOpts: IOrAlt<any>[] | OrMethodOpts<unknown>\n  ): T {\n    return this.orInternal(altsOrOpts, 2)\n  }\n\n  OR3<T>(\n    this: MixedInParser,\n    altsOrOpts: IOrAlt<any>[] | OrMethodOpts<unknown>\n  ): T {\n    return this.orInternal(altsOrOpts, 3)\n  }\n\n  OR4<T>(\n    this: MixedInParser,\n    altsOrOpts: IOrAlt<any>[] | OrMethodOpts<unknown>\n  ): T {\n    return this.orInternal(altsOrOpts, 4)\n  }\n\n  OR5<T>(\n    this: MixedInParser,\n    altsOrOpts: IOrAlt<any>[] | OrMethodOpts<unknown>\n  ): T {\n    return this.orInternal(altsOrOpts, 5)\n  }\n\n  OR6<T>(\n    this: MixedInParser,\n    altsOrOpts: IOrAlt<any>[] | OrMethodOpts<unknown>\n  ): T {\n    return this.orInternal(altsOrOpts, 6)\n  }\n\n  OR7<T>(\n    this: MixedInParser,\n    altsOrOpts: IOrAlt<any>[] | OrMethodOpts<unknown>\n  ): T {\n    return this.orInternal(altsOrOpts, 7)\n  }\n\n  OR8<T>(\n    this: MixedInParser,\n    altsOrOpts: IOrAlt<any>[] | OrMethodOpts<unknown>\n  ): T {\n    return this.orInternal(altsOrOpts, 8)\n  }\n\n  OR9<T>(\n    this: MixedInParser,\n    altsOrOpts: IOrAlt<any>[] | OrMethodOpts<unknown>\n  ): T {\n    return this.orInternal(altsOrOpts, 9)\n  }\n\n  MANY<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>\n  ): void {\n    this.manyInternal(0, actionORMethodDef)\n  }\n\n  MANY1<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>\n  ): void {\n    this.manyInternal(1, actionORMethodDef)\n  }\n\n  MANY2<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>\n  ): void {\n    this.manyInternal(2, actionORMethodDef)\n  }\n\n  MANY3<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>\n  ): void {\n    this.manyInternal(3, actionORMethodDef)\n  }\n\n  MANY4<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>\n  ): void {\n    this.manyInternal(4, actionORMethodDef)\n  }\n\n  MANY5<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>\n  ): void {\n    this.manyInternal(5, actionORMethodDef)\n  }\n\n  MANY6<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>\n  ): void {\n    this.manyInternal(6, actionORMethodDef)\n  }\n\n  MANY7<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>\n  ): void {\n    this.manyInternal(7, actionORMethodDef)\n  }\n\n  MANY8<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>\n  ): void {\n    this.manyInternal(8, actionORMethodDef)\n  }\n\n  MANY9<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>\n  ): void {\n    this.manyInternal(9, actionORMethodDef)\n  }\n\n  MANY_SEP<OUT>(this: MixedInParser, options: ManySepMethodOpts<OUT>): void {\n    this.manySepFirstInternal(0, options)\n  }\n\n  MANY_SEP1<OUT>(this: MixedInParser, options: ManySepMethodOpts<OUT>): void {\n    this.manySepFirstInternal(1, options)\n  }\n\n  MANY_SEP2<OUT>(this: MixedInParser, options: ManySepMethodOpts<OUT>): void {\n    this.manySepFirstInternal(2, options)\n  }\n\n  MANY_SEP3<OUT>(this: MixedInParser, options: ManySepMethodOpts<OUT>): void {\n    this.manySepFirstInternal(3, options)\n  }\n\n  MANY_SEP4<OUT>(this: MixedInParser, options: ManySepMethodOpts<OUT>): void {\n    this.manySepFirstInternal(4, options)\n  }\n\n  MANY_SEP5<OUT>(this: MixedInParser, options: ManySepMethodOpts<OUT>): void {\n    this.manySepFirstInternal(5, options)\n  }\n\n  MANY_SEP6<OUT>(this: MixedInParser, options: ManySepMethodOpts<OUT>): void {\n    this.manySepFirstInternal(6, options)\n  }\n\n  MANY_SEP7<OUT>(this: MixedInParser, options: ManySepMethodOpts<OUT>): void {\n    this.manySepFirstInternal(7, options)\n  }\n\n  MANY_SEP8<OUT>(this: MixedInParser, options: ManySepMethodOpts<OUT>): void {\n    this.manySepFirstInternal(8, options)\n  }\n\n  MANY_SEP9<OUT>(this: MixedInParser, options: ManySepMethodOpts<OUT>): void {\n    this.manySepFirstInternal(9, options)\n  }\n\n  AT_LEAST_ONE<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOptsWithErr<OUT>\n  ): void {\n    this.atLeastOneInternal(0, actionORMethodDef)\n  }\n\n  AT_LEAST_ONE1<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOptsWithErr<OUT>\n  ): void {\n    return this.atLeastOneInternal(1, actionORMethodDef)\n  }\n\n  AT_LEAST_ONE2<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOptsWithErr<OUT>\n  ): void {\n    this.atLeastOneInternal(2, actionORMethodDef)\n  }\n\n  AT_LEAST_ONE3<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOptsWithErr<OUT>\n  ): void {\n    this.atLeastOneInternal(3, actionORMethodDef)\n  }\n\n  AT_LEAST_ONE4<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOptsWithErr<OUT>\n  ): void {\n    this.atLeastOneInternal(4, actionORMethodDef)\n  }\n\n  AT_LEAST_ONE5<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOptsWithErr<OUT>\n  ): void {\n    this.atLeastOneInternal(5, actionORMethodDef)\n  }\n\n  AT_LEAST_ONE6<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOptsWithErr<OUT>\n  ): void {\n    this.atLeastOneInternal(6, actionORMethodDef)\n  }\n\n  AT_LEAST_ONE7<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOptsWithErr<OUT>\n  ): void {\n    this.atLeastOneInternal(7, actionORMethodDef)\n  }\n\n  AT_LEAST_ONE8<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOptsWithErr<OUT>\n  ): void {\n    this.atLeastOneInternal(8, actionORMethodDef)\n  }\n\n  AT_LEAST_ONE9<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOptsWithErr<OUT>\n  ): void {\n    this.atLeastOneInternal(9, actionORMethodDef)\n  }\n\n  AT_LEAST_ONE_SEP<OUT>(\n    this: MixedInParser,\n    options: AtLeastOneSepMethodOpts<OUT>\n  ): void {\n    this.atLeastOneSepFirstInternal(0, options)\n  }\n\n  AT_LEAST_ONE_SEP1<OUT>(\n    this: MixedInParser,\n    options: AtLeastOneSepMethodOpts<OUT>\n  ): void {\n    this.atLeastOneSepFirstInternal(1, options)\n  }\n\n  AT_LEAST_ONE_SEP2<OUT>(\n    this: MixedInParser,\n    options: AtLeastOneSepMethodOpts<OUT>\n  ): void {\n    this.atLeastOneSepFirstInternal(2, options)\n  }\n\n  AT_LEAST_ONE_SEP3<OUT>(\n    this: MixedInParser,\n    options: AtLeastOneSepMethodOpts<OUT>\n  ): void {\n    this.atLeastOneSepFirstInternal(3, options)\n  }\n\n  AT_LEAST_ONE_SEP4<OUT>(\n    this: MixedInParser,\n    options: AtLeastOneSepMethodOpts<OUT>\n  ): void {\n    this.atLeastOneSepFirstInternal(4, options)\n  }\n\n  AT_LEAST_ONE_SEP5<OUT>(\n    this: MixedInParser,\n    options: AtLeastOneSepMethodOpts<OUT>\n  ): void {\n    this.atLeastOneSepFirstInternal(5, options)\n  }\n\n  AT_LEAST_ONE_SEP6<OUT>(\n    this: MixedInParser,\n    options: AtLeastOneSepMethodOpts<OUT>\n  ): void {\n    this.atLeastOneSepFirstInternal(6, options)\n  }\n\n  AT_LEAST_ONE_SEP7<OUT>(\n    this: MixedInParser,\n    options: AtLeastOneSepMethodOpts<OUT>\n  ): void {\n    this.atLeastOneSepFirstInternal(7, options)\n  }\n\n  AT_LEAST_ONE_SEP8<OUT>(\n    this: MixedInParser,\n    options: AtLeastOneSepMethodOpts<OUT>\n  ): void {\n    this.atLeastOneSepFirstInternal(8, options)\n  }\n\n  AT_LEAST_ONE_SEP9<OUT>(\n    this: MixedInParser,\n    options: AtLeastOneSepMethodOpts<OUT>\n  ): void {\n    this.atLeastOneSepFirstInternal(9, options)\n  }\n\n  RULE<T>(\n    this: MixedInParser,\n    name: string,\n    implementation: (...implArgs: any[]) => T,\n    config: IRuleConfig<T> = DEFAULT_RULE_CONFIG\n  ): (idxInCallingRule?: number, ...args: any[]) => T | any {\n    if (includes(this.definedRulesNames, name)) {\n      const errMsg =\n        defaultGrammarValidatorErrorProvider.buildDuplicateRuleNameError({\n          topLevelRule: name,\n          grammarName: this.className\n        })\n\n      const error = {\n        message: errMsg,\n        type: ParserDefinitionErrorType.DUPLICATE_RULE_NAME,\n        ruleName: name\n      }\n      this.definitionErrors.push(error)\n    }\n\n    this.definedRulesNames.push(name)\n\n    const ruleImplementation = this.defineRule(name, implementation, config)\n    ;(this as any)[name] = ruleImplementation\n    return ruleImplementation\n  }\n\n  OVERRIDE_RULE<T>(\n    this: MixedInParser,\n    name: string,\n    impl: (...implArgs: any[]) => T,\n    config: IRuleConfig<T> = DEFAULT_RULE_CONFIG\n  ): (idxInCallingRule?: number, ...args: any[]) => T {\n    const ruleErrors: IParserDefinitionError[] = validateRuleIsOverridden(\n      name,\n      this.definedRulesNames,\n      this.className\n    )\n    this.definitionErrors = this.definitionErrors.concat(ruleErrors)\n\n    const ruleImplementation = this.defineRule(name, impl, config)\n    ;(this as any)[name] = ruleImplementation\n    return ruleImplementation\n  }\n\n  BACKTRACK<T>(\n    this: MixedInParser,\n    grammarRule: (...args: any[]) => T,\n    args?: any[]\n  ): () => boolean {\n    return function () {\n      // save org state\n      this.isBackTrackingStack.push(1)\n      const orgState = this.saveRecogState()\n      try {\n        grammarRule.apply(this, args)\n        // if no exception was thrown we have succeed parsing the rule.\n        return true\n      } catch (e) {\n        if (isRecognitionException(e)) {\n          return false\n        } else {\n          throw e\n        }\n      } finally {\n        this.reloadRecogState(orgState)\n        this.isBackTrackingStack.pop()\n      }\n    }\n  }\n\n  // GAST export APIs\n  public getGAstProductions(this: MixedInParser): Record<string, Rule> {\n    return this.gastProductionsCache\n  }\n\n  public getSerializedGastProductions(this: MixedInParser): ISerializedGast[] {\n    return serializeGrammar(values(this.gastProductionsCache))\n  }\n}\n", "import {\n  AtLeastOneSepMethodOpts,\n  ConsumeMethodOpts,\n  DSLMethodOpts,\n  DSLMethodOptsWithErr,\n  GrammarAction,\n  IOrAlt,\n  IParserConfig,\n  IRuleConfig,\n  IToken,\n  ManySepMethodOpts,\n  OrMethodOpts,\n  ParserMethod,\n  SubruleMethodOpts,\n  TokenType,\n  TokenTypeDictionary,\n  TokenVocabulary\n} from \"@chevrotain/types\"\nimport isEmpty from \"lodash/isEmpty\"\nimport isArray from \"lodash/isArray\"\nimport flatten from \"lodash/flatten\"\nimport every from \"lodash/every\"\nimport uniq from \"lodash/uniq\"\nimport isObject from \"lodash/isObject\"\nimport has from \"lodash/has\"\nimport values from \"lodash/values\"\nimport reduce from \"lodash/reduce\"\nimport clone from \"lodash/clone\"\nimport {\n  AT_LEAST_ONE_IDX,\n  AT_LEAST_ONE_SEP_IDX,\n  BITS_FOR_METHOD_TYPE,\n  BITS_FOR_OCCURRENCE_IDX,\n  MANY_IDX,\n  MANY_SEP_IDX,\n  OPTION_IDX,\n  OR_IDX\n} from \"../../grammar/keys\"\nimport {\n  isRecognitionException,\n  MismatchedTokenException,\n  NotAllInputParsedException\n} from \"../../exceptions_public\"\nimport { PROD_TYPE } from \"../../grammar/lookahead\"\nimport {\n  AbstractNextTerminalAfterProductionWalker,\n  NextTerminalAfterAtLeastOneSepWalker,\n  NextTerminalAfterAtLeastOneWalker,\n  NextTerminalAfterManySepWalker,\n  NextTerminalAfterManyWalker\n} from \"../../grammar/interpreter\"\nimport { DEFAULT_RULE_CONFIG, IParserState, TokenMatcher } from \"../parser\"\nimport { IN_RULE_RECOVERY_EXCEPTION } from \"./recoverable\"\nimport { EOF } from \"../../../scan/tokens_public\"\nimport { MixedInParser } from \"./parser_traits\"\nimport {\n  augmentTokenTypes,\n  isTokenType,\n  tokenStructuredMatcher,\n  tokenStructuredMatcherNoCategories\n} from \"../../../scan/tokens\"\nimport { Rule } from \"@chevrotain/gast\"\nimport { ParserMethodInternal } from \"../types\"\n\n/**\n * This trait is responsible for the runtime parsing engine\n * Used by the official API (recognizer_api.ts)\n */\nexport class RecognizerEngine {\n  isBackTrackingStack: boolean[]\n  className: string\n  RULE_STACK: number[]\n  RULE_OCCURRENCE_STACK: number[]\n  definedRulesNames: string[]\n  tokensMap: { [fqn: string]: TokenType }\n  gastProductionsCache: Record<string, Rule>\n  shortRuleNameToFull: Record<string, string>\n  fullRuleNameToShort: Record<string, number>\n  // The shortName Index must be coded \"after\" the first 8bits to enable building unique lookahead keys\n  ruleShortNameIdx: number\n  tokenMatcher: TokenMatcher\n  subruleIdx: number\n\n  initRecognizerEngine(\n    tokenVocabulary: TokenVocabulary,\n    config: IParserConfig\n  ) {\n    this.className = this.constructor.name\n    // TODO: would using an ES6 Map or plain object be faster (CST building scenario)\n    this.shortRuleNameToFull = {}\n    this.fullRuleNameToShort = {}\n    this.ruleShortNameIdx = 256\n    this.tokenMatcher = tokenStructuredMatcherNoCategories\n    this.subruleIdx = 0\n\n    this.definedRulesNames = []\n    this.tokensMap = {}\n    this.isBackTrackingStack = []\n    this.RULE_STACK = []\n    this.RULE_OCCURRENCE_STACK = []\n    this.gastProductionsCache = {}\n\n    if (has(config, \"serializedGrammar\")) {\n      throw Error(\n        \"The Parser's configuration can no longer contain a <serializedGrammar> property.\\n\" +\n          \"\\tSee: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_6-0-0\\n\" +\n          \"\\tFor Further details.\"\n      )\n    }\n\n    if (isArray(tokenVocabulary)) {\n      // This only checks for Token vocabularies provided as arrays.\n      // That is good enough because the main objective is to detect users of pre-V4.0 APIs\n      // rather than all edge cases of empty Token vocabularies.\n      if (isEmpty(tokenVocabulary as any[])) {\n        throw Error(\n          \"A Token Vocabulary cannot be empty.\\n\" +\n            \"\\tNote that the first argument for the parser constructor\\n\" +\n            \"\\tis no longer a Token vector (since v4.0).\"\n        )\n      }\n\n      if (typeof (tokenVocabulary as any[])[0].startOffset === \"number\") {\n        throw Error(\n          \"The Parser constructor no longer accepts a token vector as the first argument.\\n\" +\n            \"\\tSee: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_4-0-0\\n\" +\n            \"\\tFor Further details.\"\n        )\n      }\n    }\n\n    if (isArray(tokenVocabulary)) {\n      this.tokensMap = reduce(\n        tokenVocabulary,\n        (acc, tokType: TokenType) => {\n          acc[tokType.name] = tokType\n          return acc\n        },\n        {} as { [tokenName: string]: TokenType }\n      )\n    } else if (\n      has(tokenVocabulary, \"modes\") &&\n      every(flatten(values((<any>tokenVocabulary).modes)), isTokenType)\n    ) {\n      const allTokenTypes = flatten(values((<any>tokenVocabulary).modes))\n      const uniqueTokens = uniq(allTokenTypes)\n      this.tokensMap = <any>reduce(\n        uniqueTokens,\n        (acc, tokType: TokenType) => {\n          acc[tokType.name] = tokType\n          return acc\n        },\n        {} as { [tokenName: string]: TokenType }\n      )\n    } else if (isObject(tokenVocabulary)) {\n      this.tokensMap = clone(tokenVocabulary as TokenTypeDictionary)\n    } else {\n      throw new Error(\n        \"<tokensDictionary> argument must be An Array of Token constructors,\" +\n          \" A dictionary of Token constructors or an IMultiModeLexerDefinition\"\n      )\n    }\n\n    // always add EOF to the tokenNames -> constructors map. it is useful to assure all the input has been\n    // parsed with a clear error message (\"expecting EOF but found ...\")\n    this.tokensMap[\"EOF\"] = EOF\n\n    const allTokenTypes = has(tokenVocabulary, \"modes\")\n      ? flatten(values((<any>tokenVocabulary).modes))\n      : values(tokenVocabulary)\n    const noTokenCategoriesUsed = every(allTokenTypes, (tokenConstructor) =>\n      isEmpty(tokenConstructor.categoryMatches)\n    )\n\n    this.tokenMatcher = noTokenCategoriesUsed\n      ? tokenStructuredMatcherNoCategories\n      : tokenStructuredMatcher\n\n    // Because ES2015+ syntax should be supported for creating Token classes\n    // We cannot assume that the Token classes were created using the \"extendToken\" utilities\n    // Therefore we must augment the Token classes both on Lexer initialization and on Parser initialization\n    augmentTokenTypes(values(this.tokensMap))\n  }\n\n  defineRule<ARGS extends unknown[], R>(\n    this: MixedInParser,\n    ruleName: string,\n    impl: (...args: ARGS) => R,\n    config: IRuleConfig<R>\n  ): ParserMethodInternal<ARGS, R> {\n    if (this.selfAnalysisDone) {\n      throw Error(\n        `Grammar rule <${ruleName}> may not be defined after the 'performSelfAnalysis' method has been called'\\n` +\n          `Make sure that all grammar rule definitions are done before 'performSelfAnalysis' is called.`\n      )\n    }\n    const resyncEnabled: boolean = has(config, \"resyncEnabled\")\n      ? (config.resyncEnabled as boolean) // assumes end user provides the correct config value/type\n      : DEFAULT_RULE_CONFIG.resyncEnabled\n    const recoveryValueFunc = has(config, \"recoveryValueFunc\")\n      ? (config.recoveryValueFunc as () => R) // assumes end user provides the correct config value/type\n      : DEFAULT_RULE_CONFIG.recoveryValueFunc\n\n    // performance optimization: Use small integers as keys for the longer human readable \"full\" rule names.\n    // this greatly improves Map access time (as much as 8% for some performance benchmarks).\n    const shortName =\n      this.ruleShortNameIdx << (BITS_FOR_METHOD_TYPE + BITS_FOR_OCCURRENCE_IDX)\n\n    this.ruleShortNameIdx++\n    this.shortRuleNameToFull[shortName] = ruleName\n    this.fullRuleNameToShort[ruleName] = shortName\n\n    let invokeRuleWithTry: ParserMethod<ARGS, R>\n\n    // Micro optimization, only check the condition **once** on rule definition\n    // instead of **every single** rule invocation.\n    if (this.outputCst === true) {\n      invokeRuleWithTry = function invokeRuleWithTry(\n        this: MixedInParser,\n        ...args: ARGS\n      ): R {\n        try {\n          this.ruleInvocationStateUpdate(shortName, ruleName, this.subruleIdx)\n          impl.apply(this, args)\n          const cst = this.CST_STACK[this.CST_STACK.length - 1]\n          this.cstPostRule(cst)\n          return cst as unknown as R\n        } catch (e) {\n          return this.invokeRuleCatch(e, resyncEnabled, recoveryValueFunc) as R\n        } finally {\n          this.ruleFinallyStateUpdate()\n        }\n      }\n    } else {\n      invokeRuleWithTry = function invokeRuleWithTryCst(\n        this: MixedInParser,\n        ...args: ARGS\n      ): R {\n        try {\n          this.ruleInvocationStateUpdate(shortName, ruleName, this.subruleIdx)\n          return impl.apply(this, args)\n        } catch (e) {\n          return this.invokeRuleCatch(e, resyncEnabled, recoveryValueFunc) as R\n        } finally {\n          this.ruleFinallyStateUpdate()\n        }\n      }\n    }\n\n    const wrappedGrammarRule: ParserMethodInternal<ARGS, R> = Object.assign(\n      invokeRuleWithTry as any,\n      { ruleName, originalGrammarAction: impl }\n    )\n\n    return wrappedGrammarRule\n  }\n\n  invokeRuleCatch(\n    this: MixedInParser,\n    e: Error,\n    resyncEnabledConfig: boolean,\n    recoveryValueFunc: Function\n  ): unknown {\n    const isFirstInvokedRule = this.RULE_STACK.length === 1\n    // note the reSync is always enabled for the first rule invocation, because we must always be able to\n    // reSync with EOF and just output some INVALID ParseTree\n    // during backtracking reSync recovery is disabled, otherwise we can't be certain the backtracking\n    // path is really the most valid one\n    const reSyncEnabled =\n      resyncEnabledConfig && !this.isBackTracking() && this.recoveryEnabled\n\n    if (isRecognitionException(e)) {\n      const recogError: any = e\n      if (reSyncEnabled) {\n        const reSyncTokType = this.findReSyncTokenType()\n        if (this.isInCurrentRuleReSyncSet(reSyncTokType)) {\n          recogError.resyncedTokens = this.reSyncTo(reSyncTokType)\n          if (this.outputCst) {\n            const partialCstResult: any =\n              this.CST_STACK[this.CST_STACK.length - 1]\n            partialCstResult.recoveredNode = true\n            return partialCstResult\n          } else {\n            return recoveryValueFunc(e)\n          }\n        } else {\n          if (this.outputCst) {\n            const partialCstResult: any =\n              this.CST_STACK[this.CST_STACK.length - 1]\n            partialCstResult.recoveredNode = true\n            recogError.partialCstResult = partialCstResult\n          }\n          // to be handled Further up the call stack\n          throw recogError\n        }\n      } else if (isFirstInvokedRule) {\n        // otherwise a Redundant input error will be created as well and we cannot guarantee that this is indeed the case\n        this.moveToTerminatedState()\n        // the parser should never throw one of its own errors outside its flow.\n        // even if error recovery is disabled\n        return recoveryValueFunc(e)\n      } else {\n        // to be recovered Further up the call stack\n        throw recogError\n      }\n    } else {\n      // some other Error type which we don't know how to handle (for example a built in JavaScript Error)\n      throw e\n    }\n  }\n\n  // Implementation of parsing DSL\n  optionInternal<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,\n    occurrence: number\n  ): OUT | undefined {\n    const key = this.getKeyForAutomaticLookahead(OPTION_IDX, occurrence)\n    return this.optionInternalLogic(actionORMethodDef, occurrence, key)\n  }\n\n  optionInternalLogic<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,\n    occurrence: number,\n    key: number\n  ): OUT | undefined {\n    let lookAheadFunc = this.getLaFuncFromCache(key)\n    let action: GrammarAction<OUT>\n    if (typeof actionORMethodDef !== \"function\") {\n      action = actionORMethodDef.DEF\n      const predicate = actionORMethodDef.GATE\n      // predicate present\n      if (predicate !== undefined) {\n        const orgLookaheadFunction = lookAheadFunc\n        lookAheadFunc = () => {\n          return predicate.call(this) && orgLookaheadFunction.call(this)\n        }\n      }\n    } else {\n      action = actionORMethodDef\n    }\n\n    if (lookAheadFunc.call(this) === true) {\n      return action.call(this)\n    }\n    return undefined\n  }\n\n  atLeastOneInternal<OUT>(\n    this: MixedInParser,\n    prodOccurrence: number,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOptsWithErr<OUT>\n  ): void {\n    const laKey = this.getKeyForAutomaticLookahead(\n      AT_LEAST_ONE_IDX,\n      prodOccurrence\n    )\n    return this.atLeastOneInternalLogic(\n      prodOccurrence,\n      actionORMethodDef,\n      laKey\n    )\n  }\n\n  atLeastOneInternalLogic<OUT>(\n    this: MixedInParser,\n    prodOccurrence: number,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOptsWithErr<OUT>,\n    key: number\n  ): void {\n    let lookAheadFunc = this.getLaFuncFromCache(key)\n    let action\n    if (typeof actionORMethodDef !== \"function\") {\n      action = actionORMethodDef.DEF\n      const predicate = actionORMethodDef.GATE\n      // predicate present\n      if (predicate !== undefined) {\n        const orgLookaheadFunction = lookAheadFunc\n        lookAheadFunc = () => {\n          return predicate.call(this) && orgLookaheadFunction.call(this)\n        }\n      }\n    } else {\n      action = actionORMethodDef\n    }\n\n    if ((<Function>lookAheadFunc).call(this) === true) {\n      let notStuck = this.doSingleRepetition(action)\n      while (\n        (<Function>lookAheadFunc).call(this) === true &&\n        notStuck === true\n      ) {\n        notStuck = this.doSingleRepetition(action)\n      }\n    } else {\n      throw this.raiseEarlyExitException(\n        prodOccurrence,\n        PROD_TYPE.REPETITION_MANDATORY,\n        (<DSLMethodOptsWithErr<OUT>>actionORMethodDef).ERR_MSG\n      )\n    }\n\n    // note that while it may seem that this can cause an error because by using a recursive call to\n    // AT_LEAST_ONE we change the grammar to AT_LEAST_TWO, AT_LEAST_THREE ... , the possible recursive call\n    // from the tryInRepetitionRecovery(...) will only happen IFF there really are TWO/THREE/.... items.\n\n    // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n    this.attemptInRepetitionRecovery(\n      this.atLeastOneInternal,\n      [prodOccurrence, actionORMethodDef],\n      <any>lookAheadFunc,\n      AT_LEAST_ONE_IDX,\n      prodOccurrence,\n      NextTerminalAfterAtLeastOneWalker\n    )\n  }\n\n  atLeastOneSepFirstInternal<OUT>(\n    this: MixedInParser,\n    prodOccurrence: number,\n    options: AtLeastOneSepMethodOpts<OUT>\n  ): void {\n    const laKey = this.getKeyForAutomaticLookahead(\n      AT_LEAST_ONE_SEP_IDX,\n      prodOccurrence\n    )\n    this.atLeastOneSepFirstInternalLogic(prodOccurrence, options, laKey)\n  }\n\n  atLeastOneSepFirstInternalLogic<OUT>(\n    this: MixedInParser,\n    prodOccurrence: number,\n    options: AtLeastOneSepMethodOpts<OUT>,\n    key: number\n  ): void {\n    const action = options.DEF\n    const separator = options.SEP\n\n    const firstIterationLookaheadFunc = this.getLaFuncFromCache(key)\n\n    // 1st iteration\n    if (firstIterationLookaheadFunc.call(this) === true) {\n      ;(<GrammarAction<OUT>>action).call(this)\n\n      //  TODO: Optimization can move this function construction into \"attemptInRepetitionRecovery\"\n      //  because it is only needed in error recovery scenarios.\n      const separatorLookAheadFunc = () => {\n        return this.tokenMatcher(this.LA(1), separator)\n      }\n\n      // 2nd..nth iterations\n      while (this.tokenMatcher(this.LA(1), separator) === true) {\n        // note that this CONSUME will never enter recovery because\n        // the separatorLookAheadFunc checks that the separator really does exist.\n        this.CONSUME(separator)\n        // No need for checking infinite loop here due to consuming the separator.\n        ;(<GrammarAction<OUT>>action).call(this)\n      }\n\n      // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n      this.attemptInRepetitionRecovery(\n        this.repetitionSepSecondInternal,\n        [\n          prodOccurrence,\n          separator,\n          separatorLookAheadFunc,\n          action,\n          NextTerminalAfterAtLeastOneSepWalker\n        ],\n        separatorLookAheadFunc,\n        AT_LEAST_ONE_SEP_IDX,\n        prodOccurrence,\n        NextTerminalAfterAtLeastOneSepWalker\n      )\n    } else {\n      throw this.raiseEarlyExitException(\n        prodOccurrence,\n        PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR,\n        options.ERR_MSG\n      )\n    }\n  }\n\n  manyInternal<OUT>(\n    this: MixedInParser,\n    prodOccurrence: number,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>\n  ): void {\n    const laKey = this.getKeyForAutomaticLookahead(MANY_IDX, prodOccurrence)\n    return this.manyInternalLogic(prodOccurrence, actionORMethodDef, laKey)\n  }\n\n  manyInternalLogic<OUT>(\n    this: MixedInParser,\n    prodOccurrence: number,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,\n    key: number\n  ) {\n    let lookaheadFunction = this.getLaFuncFromCache(key)\n    let action\n    if (typeof actionORMethodDef !== \"function\") {\n      action = actionORMethodDef.DEF\n      const predicate = actionORMethodDef.GATE\n      // predicate present\n      if (predicate !== undefined) {\n        const orgLookaheadFunction = lookaheadFunction\n        lookaheadFunction = () => {\n          return predicate.call(this) && orgLookaheadFunction.call(this)\n        }\n      }\n    } else {\n      action = actionORMethodDef\n    }\n\n    let notStuck = true\n    while (lookaheadFunction.call(this) === true && notStuck === true) {\n      notStuck = this.doSingleRepetition(action)\n    }\n\n    // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n    this.attemptInRepetitionRecovery(\n      this.manyInternal,\n      [prodOccurrence, actionORMethodDef],\n      <any>lookaheadFunction,\n      MANY_IDX,\n      prodOccurrence,\n      NextTerminalAfterManyWalker,\n      // The notStuck parameter is only relevant when \"attemptInRepetitionRecovery\"\n      // is invoked from manyInternal, in the MANY_SEP case and AT_LEAST_ONE[_SEP]\n      // An infinite loop cannot occur as:\n      // - Either the lookahead is guaranteed to consume something (Single Token Separator)\n      // - AT_LEAST_ONE by definition is guaranteed to consume something (or error out).\n      notStuck\n    )\n  }\n\n  manySepFirstInternal<OUT>(\n    this: MixedInParser,\n    prodOccurrence: number,\n    options: ManySepMethodOpts<OUT>\n  ): void {\n    const laKey = this.getKeyForAutomaticLookahead(MANY_SEP_IDX, prodOccurrence)\n    this.manySepFirstInternalLogic(prodOccurrence, options, laKey)\n  }\n\n  manySepFirstInternalLogic<OUT>(\n    this: MixedInParser,\n    prodOccurrence: number,\n    options: ManySepMethodOpts<OUT>,\n    key: number\n  ): void {\n    const action = options.DEF\n    const separator = options.SEP\n    const firstIterationLaFunc = this.getLaFuncFromCache(key)\n\n    // 1st iteration\n    if (firstIterationLaFunc.call(this) === true) {\n      action.call(this)\n\n      const separatorLookAheadFunc = () => {\n        return this.tokenMatcher(this.LA(1), separator)\n      }\n      // 2nd..nth iterations\n      while (this.tokenMatcher(this.LA(1), separator) === true) {\n        // note that this CONSUME will never enter recovery because\n        // the separatorLookAheadFunc checks that the separator really does exist.\n        this.CONSUME(separator)\n        // No need for checking infinite loop here due to consuming the separator.\n        action.call(this)\n      }\n\n      // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n      this.attemptInRepetitionRecovery(\n        this.repetitionSepSecondInternal,\n        [\n          prodOccurrence,\n          separator,\n          separatorLookAheadFunc,\n          action,\n          NextTerminalAfterManySepWalker\n        ],\n        separatorLookAheadFunc,\n        MANY_SEP_IDX,\n        prodOccurrence,\n        NextTerminalAfterManySepWalker\n      )\n    }\n  }\n\n  repetitionSepSecondInternal<OUT>(\n    this: MixedInParser,\n    prodOccurrence: number,\n    separator: TokenType,\n    separatorLookAheadFunc: () => boolean,\n    action: GrammarAction<OUT>,\n    nextTerminalAfterWalker: typeof AbstractNextTerminalAfterProductionWalker\n  ): void {\n    while (separatorLookAheadFunc()) {\n      // note that this CONSUME will never enter recovery because\n      // the separatorLookAheadFunc checks that the separator really does exist.\n      this.CONSUME(separator)\n      action.call(this)\n    }\n\n    // we can only arrive to this function after an error\n    // has occurred (hence the name 'second') so the following\n    // IF will always be entered, its possible to remove it...\n    // however it is kept to avoid confusion and be consistent.\n    // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n    /* istanbul ignore else */\n    this.attemptInRepetitionRecovery(\n      this.repetitionSepSecondInternal,\n      [\n        prodOccurrence,\n        separator,\n        separatorLookAheadFunc,\n        action,\n        nextTerminalAfterWalker\n      ],\n      separatorLookAheadFunc,\n      AT_LEAST_ONE_SEP_IDX,\n      prodOccurrence,\n      nextTerminalAfterWalker\n    )\n  }\n\n  doSingleRepetition(this: MixedInParser, action: Function): any {\n    const beforeIteration = this.getLexerPosition()\n    action.call(this)\n    const afterIteration = this.getLexerPosition()\n\n    // This boolean will indicate if this repetition progressed\n    // or if we are \"stuck\" (potential infinite loop in the repetition).\n    return afterIteration > beforeIteration\n  }\n\n  orInternal<T>(\n    this: MixedInParser,\n    altsOrOpts: IOrAlt<any>[] | OrMethodOpts<unknown>,\n    occurrence: number\n  ): T {\n    const laKey = this.getKeyForAutomaticLookahead(OR_IDX, occurrence)\n    const alts = isArray(altsOrOpts) ? altsOrOpts : altsOrOpts.DEF\n\n    const laFunc = this.getLaFuncFromCache(laKey)\n    const altIdxToTake = laFunc.call(this, alts)\n    if (altIdxToTake !== undefined) {\n      const chosenAlternative: any = alts[altIdxToTake]\n      return chosenAlternative.ALT.call(this)\n    }\n    this.raiseNoAltException(\n      occurrence,\n      (altsOrOpts as OrMethodOpts<unknown>).ERR_MSG\n    )\n  }\n\n  ruleFinallyStateUpdate(this: MixedInParser): void {\n    this.RULE_STACK.pop()\n    this.RULE_OCCURRENCE_STACK.pop()\n\n    // NOOP when cst is disabled\n    this.cstFinallyStateUpdate()\n\n    if (this.RULE_STACK.length === 0 && this.isAtEndOfInput() === false) {\n      const firstRedundantTok = this.LA(1)\n      const errMsg = this.errorMessageProvider.buildNotAllInputParsedMessage({\n        firstRedundant: firstRedundantTok,\n        ruleName: this.getCurrRuleFullName()\n      })\n      this.SAVE_ERROR(new NotAllInputParsedException(errMsg, firstRedundantTok))\n    }\n  }\n\n  subruleInternal<ARGS extends unknown[], R>(\n    this: MixedInParser,\n    ruleToCall: ParserMethodInternal<ARGS, R>,\n    idx: number,\n    options?: SubruleMethodOpts<ARGS>\n  ): R {\n    let ruleResult\n    try {\n      const args = options !== undefined ? options.ARGS : undefined\n      this.subruleIdx = idx\n      ruleResult = ruleToCall.apply(this, args)\n      this.cstPostNonTerminal(\n        ruleResult,\n        options !== undefined && options.LABEL !== undefined\n          ? options.LABEL\n          : ruleToCall.ruleName\n      )\n      return ruleResult\n    } catch (e) {\n      throw this.subruleInternalError(e, options, ruleToCall.ruleName)\n    }\n  }\n\n  subruleInternalError(\n    this: MixedInParser,\n    e: any,\n    options: SubruleMethodOpts<unknown[]> | undefined,\n    ruleName: string\n  ): void {\n    if (isRecognitionException(e) && e.partialCstResult !== undefined) {\n      this.cstPostNonTerminal(\n        e.partialCstResult,\n        options !== undefined && options.LABEL !== undefined\n          ? options.LABEL\n          : ruleName\n      )\n\n      delete e.partialCstResult\n    }\n    throw e\n  }\n\n  consumeInternal(\n    this: MixedInParser,\n    tokType: TokenType,\n    idx: number,\n    options: ConsumeMethodOpts | undefined\n  ): IToken {\n    let consumedToken!: IToken\n    try {\n      const nextToken = this.LA(1)\n      if (this.tokenMatcher(nextToken, tokType) === true) {\n        this.consumeToken()\n        consumedToken = nextToken\n      } else {\n        this.consumeInternalError(tokType, nextToken, options)\n      }\n    } catch (eFromConsumption) {\n      consumedToken = this.consumeInternalRecovery(\n        tokType,\n        idx,\n        eFromConsumption\n      )\n    }\n\n    this.cstPostTerminal(\n      options !== undefined && options.LABEL !== undefined\n        ? options.LABEL\n        : tokType.name,\n      consumedToken\n    )\n    return consumedToken\n  }\n\n  consumeInternalError(\n    this: MixedInParser,\n    tokType: TokenType,\n    nextToken: IToken,\n    options: ConsumeMethodOpts | undefined\n  ): void {\n    let msg\n    const previousToken = this.LA(0)\n    if (options !== undefined && options.ERR_MSG) {\n      msg = options.ERR_MSG\n    } else {\n      msg = this.errorMessageProvider.buildMismatchTokenMessage({\n        expected: tokType,\n        actual: nextToken,\n        previous: previousToken,\n        ruleName: this.getCurrRuleFullName()\n      })\n    }\n    throw this.SAVE_ERROR(\n      new MismatchedTokenException(msg, nextToken, previousToken)\n    )\n  }\n\n  consumeInternalRecovery(\n    this: MixedInParser,\n    tokType: TokenType,\n    idx: number,\n    eFromConsumption: Error\n  ): IToken {\n    // no recovery allowed during backtracking, otherwise backtracking may recover invalid syntax and accept it\n    // but the original syntax could have been parsed successfully without any backtracking + recovery\n    if (\n      this.recoveryEnabled &&\n      // TODO: more robust checking of the exception type. Perhaps Typescript extending expressions?\n      eFromConsumption.name === \"MismatchedTokenException\" &&\n      !this.isBackTracking()\n    ) {\n      const follows = this.getFollowsForInRuleRecovery(<any>tokType, idx)\n      try {\n        return this.tryInRuleRecovery(<any>tokType, follows)\n      } catch (eFromInRuleRecovery) {\n        if (eFromInRuleRecovery.name === IN_RULE_RECOVERY_EXCEPTION) {\n          // failed in RuleRecovery.\n          // throw the original error in order to trigger reSync error recovery\n          throw eFromConsumption\n        } else {\n          throw eFromInRuleRecovery\n        }\n      }\n    } else {\n      throw eFromConsumption\n    }\n  }\n\n  saveRecogState(this: MixedInParser): IParserState {\n    // errors is a getter which will clone the errors array\n    const savedErrors = this.errors\n    const savedRuleStack = clone(this.RULE_STACK)\n    return {\n      errors: savedErrors,\n      lexerState: this.exportLexerState(),\n      RULE_STACK: savedRuleStack,\n      CST_STACK: this.CST_STACK\n    }\n  }\n\n  reloadRecogState(this: MixedInParser, newState: IParserState) {\n    this.errors = newState.errors\n    this.importLexerState(newState.lexerState)\n    this.RULE_STACK = newState.RULE_STACK\n  }\n\n  ruleInvocationStateUpdate(\n    this: MixedInParser,\n    shortName: number,\n    fullName: string,\n    idxInCallingRule: number\n  ): void {\n    this.RULE_OCCURRENCE_STACK.push(idxInCallingRule)\n    this.RULE_STACK.push(shortName)\n    // NOOP when cst is disabled\n    this.cstInvocationStateUpdate(fullName)\n  }\n\n  isBackTracking(this: MixedInParser): boolean {\n    return this.isBackTrackingStack.length !== 0\n  }\n\n  getCurrRuleFullName(this: MixedInParser): string {\n    const shortName = this.getLastExplicitRuleShortName()\n    return this.shortRuleNameToFull[shortName]\n  }\n\n  shortRuleNameToFullName(this: MixedInParser, shortName: number) {\n    return this.shortRuleNameToFull[shortName]\n  }\n\n  public isAtEndOfInput(this: MixedInParser): boolean {\n    return this.tokenMatcher(this.LA(1), EOF)\n  }\n\n  public reset(this: MixedInParser): void {\n    this.resetLexerState()\n    this.subruleIdx = 0\n    this.isBackTrackingStack = []\n    this.errors = []\n    this.RULE_STACK = []\n    // TODO: extract a specific reset for TreeBuilder trait\n    this.CST_STACK = []\n    this.RULE_OCCURRENCE_STACK = []\n  }\n}\n", "import {\n  IParserConfig,\n  IParserErrorMessageProvider,\n  IRecognitionException\n} from \"@chevrotain/types\"\nimport {\n  EarlyExitException,\n  isRecognitionException,\n  NoViableAltException\n} from \"../../exceptions_public\"\nimport has from \"lodash/has\"\nimport clone from \"lodash/clone\"\nimport {\n  getLookaheadPathsForOptionalProd,\n  getLookaheadPathsForOr,\n  PROD_TYPE\n} from \"../../grammar/lookahead\"\nimport { MixedInParser } from \"./parser_traits\"\nimport { DEFAULT_PARSER_CONFIG } from \"../parser\"\n\n/**\n * Trait responsible for runtime parsing errors.\n */\nexport class ErrorHandler {\n  _errors: IRecognitionException[]\n  errorMessageProvider: IParserErrorMessageProvider\n\n  initErrorHandler(config: IParserConfig) {\n    this._errors = []\n    this.errorMessageProvider = has(config, \"errorMessageProvider\")\n      ? (config.errorMessageProvider as IParserErrorMessageProvider) // assumes end user provides the correct config value/type\n      : DEFAULT_PARSER_CONFIG.errorMessageProvider\n  }\n\n  SAVE_ERROR(\n    this: MixedInParser,\n    error: IRecognitionException\n  ): IRecognitionException {\n    if (isRecognitionException(error)) {\n      error.context = {\n        ruleStack: this.getHumanReadableRuleStack(),\n        ruleOccurrenceStack: clone(this.RULE_OCCURRENCE_STACK)\n      }\n      this._errors.push(error)\n      return error\n    } else {\n      throw Error(\"Trying to save an Error which is not a RecognitionException\")\n    }\n  }\n\n  get errors(): IRecognitionException[] {\n    return clone(this._errors)\n  }\n\n  set errors(newErrors: IRecognitionException[]) {\n    this._errors = newErrors\n  }\n\n  // TODO: consider caching the error message computed information\n  raiseEarlyExitException(\n    this: MixedInParser,\n    occurrence: number,\n    prodType: PROD_TYPE,\n    userDefinedErrMsg: string | undefined\n  ): never {\n    const ruleName = this.getCurrRuleFullName()\n    const ruleGrammar = this.getGAstProductions()[ruleName]\n    const lookAheadPathsPerAlternative = getLookaheadPathsForOptionalProd(\n      occurrence,\n      ruleGrammar,\n      prodType,\n      this.maxLookahead\n    )\n    const insideProdPaths = lookAheadPathsPerAlternative[0]\n    const actualTokens = []\n    for (let i = 1; i <= this.maxLookahead; i++) {\n      actualTokens.push(this.LA(i))\n    }\n    const msg = this.errorMessageProvider.buildEarlyExitMessage({\n      expectedIterationPaths: insideProdPaths,\n      actual: actualTokens,\n      previous: this.LA(0),\n      customUserDescription: userDefinedErrMsg,\n      ruleName: ruleName\n    })\n\n    throw this.SAVE_ERROR(new EarlyExitException(msg, this.LA(1), this.LA(0)))\n  }\n\n  // TODO: consider caching the error message computed information\n  raiseNoAltException(\n    this: MixedInParser,\n    occurrence: number,\n    errMsgTypes: string | undefined\n  ): never {\n    const ruleName = this.getCurrRuleFullName()\n    const ruleGrammar = this.getGAstProductions()[ruleName]\n    // TODO: getLookaheadPathsForOr can be slow for large enough maxLookahead and certain grammars, consider caching ?\n    const lookAheadPathsPerAlternative = getLookaheadPathsForOr(\n      occurrence,\n      ruleGrammar,\n      this.maxLookahead\n    )\n\n    const actualTokens = []\n    for (let i = 1; i <= this.maxLookahead; i++) {\n      actualTokens.push(this.LA(i))\n    }\n    const previousToken = this.LA(0)\n\n    const errMsg = this.errorMessageProvider.buildNoViableAltMessage({\n      expectedPathsPerAlt: lookAheadPathsPerAlternative,\n      actual: actualTokens,\n      previous: previousToken,\n      customUserDescription: errMsgTypes,\n      ruleName: this.getCurrRuleFullName()\n    })\n\n    throw this.SAVE_ERROR(\n      new NoViableAltException(errMsg, this.LA(1), previousToken)\n    )\n  }\n}\n", "import {\n  ISyntacticContentAssistPath,\n  IToken,\n  ITokenGrammarPath,\n  TokenType\n} from \"@chevrotain/types\"\nimport {\n  NextAfterTokenWalker,\n  nextPossibleTokensAfter\n} from \"../../grammar/interpreter\"\nimport first from \"lodash/first\"\nimport isUndefined from \"lodash/isUndefined\"\nimport { MixedInParser } from \"./parser_traits\"\n\nexport class ContentAssist {\n  initContentAssist() {}\n\n  public computeContentAssist(\n    this: MixedInParser,\n    startRuleName: string,\n    precedingInput: IToken[]\n  ): ISyntacticContentAssistPath[] {\n    const startRuleGast = this.gastProductionsCache[startRuleName]\n\n    if (isUndefined(startRuleGast)) {\n      throw Error(`Rule ->${startRuleName}<- does not exist in this grammar.`)\n    }\n\n    return nextPossibleTokensAfter(\n      [startRuleGast],\n      precedingInput,\n      this.tokenMatcher,\n      this.maxLookahead\n    )\n  }\n\n  // TODO: should this be a member method or a utility? it does not have any state or usage of 'this'...\n  // TODO: should this be more explicitly part of the public API?\n  public getNextPossibleTokenTypes(\n    this: MixedInParser,\n    grammarPath: ITokenGrammarPath\n  ): TokenType[] {\n    const topRuleName = first(grammarPath.ruleStack)!\n    const gastProductions = this.getGAstProductions()\n    const topProduction = gastProductions[topRuleName]\n    const nextPossibleTokenTypes = new NextAfterTokenWalker(\n      topProduction,\n      grammarPath\n    ).startWalking()\n    return nextPossibleTokenTypes\n  }\n}\n", "import {\n  AtLeastOneSepMethodOpts,\n  ConsumeMethodOpts,\n  CstNode,\n  DSLMethodOpts,\n  DSLMethodOptsWithErr,\n  GrammarAction,\n  IOrAlt,\n  IParserConfig,\n  IProduction,\n  IToken,\n  ManySepMethodOpts,\n  OrMethodOpts,\n  SubruleMethodOpts,\n  TokenType\n} from \"@chevrotain/types\"\nimport peek from \"lodash/last\"\nimport isArray from \"lodash/isArray\"\nimport some from \"lodash/some\"\nimport forEach from \"lodash/forEach\"\nimport isFunction from \"lodash/isFunction\"\nimport has from \"lodash/has\"\nimport { MixedInParser } from \"./parser_traits\"\nimport {\n  Alternation,\n  Alternative,\n  NonTerminal,\n  Option,\n  Repetition,\n  RepetitionMandatory,\n  RepetitionMandatoryWithSeparator,\n  RepetitionWithSeparator,\n  Rule,\n  Terminal\n} from \"@chevrotain/gast\"\nimport { Lexer } from \"../../../scan/lexer_public\"\nimport { augmentTokenTypes, hasShortKeyProperty } from \"../../../scan/tokens\"\nimport { createToken, createTokenInstance } from \"../../../scan/tokens_public\"\nimport { END_OF_FILE } from \"../parser\"\nimport { BITS_FOR_OCCURRENCE_IDX } from \"../../grammar/keys\"\nimport { ParserMethodInternal } from \"../types\"\n\ntype ProdWithDef = IProduction & { definition?: IProduction[] }\nconst RECORDING_NULL_OBJECT = {\n  description: \"This Object indicates the Parser is during Recording Phase\"\n}\nObject.freeze(RECORDING_NULL_OBJECT)\n\nconst HANDLE_SEPARATOR = true\nconst MAX_METHOD_IDX = Math.pow(2, BITS_FOR_OCCURRENCE_IDX) - 1\n\nconst RFT = createToken({ name: \"RECORDING_PHASE_TOKEN\", pattern: Lexer.NA })\naugmentTokenTypes([RFT])\nconst RECORDING_PHASE_TOKEN = createTokenInstance(\n  RFT,\n  \"This IToken indicates the Parser is in Recording Phase\\n\\t\" +\n    \"\" +\n    \"See: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details\",\n  // Using \"-1\" instead of NaN (as in EOF) because an actual number is less likely to\n  // cause errors if the output of LA or CONSUME would be (incorrectly) used during the recording phase.\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1\n)\nObject.freeze(RECORDING_PHASE_TOKEN)\n\nconst RECORDING_PHASE_CSTNODE: CstNode = {\n  name:\n    \"This CSTNode indicates the Parser is in Recording Phase\\n\\t\" +\n    \"See: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details\",\n  children: {}\n}\n\n/**\n * This trait handles the creation of the GAST structure for Chevrotain Grammars\n */\nexport class GastRecorder {\n  recordingProdStack: ProdWithDef[]\n  RECORDING_PHASE: boolean\n\n  initGastRecorder(this: MixedInParser, config: IParserConfig): void {\n    this.recordingProdStack = []\n    this.RECORDING_PHASE = false\n  }\n\n  enableRecording(this: MixedInParser): void {\n    this.RECORDING_PHASE = true\n\n    this.TRACE_INIT(\"Enable Recording\", () => {\n      /**\n       * Warning Dark Voodoo Magic upcoming!\n       * We are \"replacing\" the public parsing DSL methods API\n       * With **new** alternative implementations on the Parser **instance**\n       *\n       * So far this is the only way I've found to avoid performance regressions during parsing time.\n       * - Approx 30% performance regression was measured on Chrome 75 Canary when attempting to replace the \"internal\"\n       *   implementations directly instead.\n       */\n      for (let i = 0; i < 10; i++) {\n        const idx = i > 0 ? i : \"\"\n        this[`CONSUME${idx}` as \"CONSUME\"] = function (arg1, arg2) {\n          return this.consumeInternalRecord(arg1, i, arg2)\n        }\n        this[`SUBRULE${idx}` as \"SUBRULE\"] = function (arg1, arg2) {\n          return this.subruleInternalRecord(arg1, i, arg2) as any\n        }\n        this[`OPTION${idx}` as \"OPTION\"] = function (arg1) {\n          return this.optionInternalRecord(arg1, i)\n        }\n        this[`OR${idx}` as \"OR\"] = function (arg1) {\n          return this.orInternalRecord(arg1, i)\n        }\n        this[`MANY${idx}` as \"MANY\"] = function (arg1) {\n          this.manyInternalRecord(i, arg1)\n        }\n        this[`MANY_SEP${idx}` as \"MANY_SEP\"] = function (arg1) {\n          this.manySepFirstInternalRecord(i, arg1)\n        }\n        this[`AT_LEAST_ONE${idx}` as \"AT_LEAST_ONE\"] = function (arg1) {\n          this.atLeastOneInternalRecord(i, arg1)\n        }\n        this[`AT_LEAST_ONE_SEP${idx}` as \"AT_LEAST_ONE_SEP\"] = function (arg1) {\n          this.atLeastOneSepFirstInternalRecord(i, arg1)\n        }\n      }\n\n      // DSL methods with the idx(suffix) as an argument\n      this[`consume`] = function (idx, arg1, arg2) {\n        return this.consumeInternalRecord(arg1, idx, arg2)\n      }\n      this[`subrule`] = function (idx, arg1, arg2) {\n        return this.subruleInternalRecord(arg1, idx, arg2) as any\n      }\n      this[`option`] = function (idx, arg1) {\n        return this.optionInternalRecord(arg1, idx)\n      }\n      this[`or`] = function (idx, arg1) {\n        return this.orInternalRecord(arg1, idx)\n      }\n      this[`many`] = function (idx, arg1) {\n        this.manyInternalRecord(idx, arg1)\n      }\n      this[`atLeastOne`] = function (idx, arg1) {\n        this.atLeastOneInternalRecord(idx, arg1)\n      }\n\n      this.ACTION = this.ACTION_RECORD\n      this.BACKTRACK = this.BACKTRACK_RECORD\n      this.LA = this.LA_RECORD\n    })\n  }\n\n  disableRecording(this: MixedInParser) {\n    this.RECORDING_PHASE = false\n    // By deleting these **instance** properties, any future invocation\n    // will be deferred to the original methods on the **prototype** object\n    // This seems to get rid of any incorrect optimizations that V8 may\n    // do during the recording phase.\n    this.TRACE_INIT(\"Deleting Recording methods\", () => {\n      const that: any = this\n\n      for (let i = 0; i < 10; i++) {\n        const idx = i > 0 ? i : \"\"\n        delete that[`CONSUME${idx}`]\n        delete that[`SUBRULE${idx}`]\n        delete that[`OPTION${idx}`]\n        delete that[`OR${idx}`]\n        delete that[`MANY${idx}`]\n        delete that[`MANY_SEP${idx}`]\n        delete that[`AT_LEAST_ONE${idx}`]\n        delete that[`AT_LEAST_ONE_SEP${idx}`]\n      }\n\n      delete that[`consume`]\n      delete that[`subrule`]\n      delete that[`option`]\n      delete that[`or`]\n      delete that[`many`]\n      delete that[`atLeastOne`]\n\n      delete that.ACTION\n      delete that.BACKTRACK\n      delete that.LA\n    })\n  }\n\n  //   Parser methods are called inside an ACTION?\n  //   Maybe try/catch/finally on ACTIONS while disabling the recorders state changes?\n  // @ts-expect-error -- noop place holder\n  ACTION_RECORD<T>(this: MixedInParser, impl: () => T): T {\n    // NO-OP during recording\n  }\n\n  // Executing backtracking logic will break our recording logic assumptions\n  BACKTRACK_RECORD<T>(\n    grammarRule: (...args: any[]) => T,\n    args?: any[]\n  ): () => boolean {\n    return () => true\n  }\n\n  // LA is part of the official API and may be used for custom lookahead logic\n  // by end users who may forget to wrap it in ACTION or inside a GATE\n  LA_RECORD(howMuch: number): IToken {\n    // We cannot use the RECORD_PHASE_TOKEN here because someone may depend\n    // On LA return EOF at the end of the input so an infinite loop may occur.\n    return END_OF_FILE\n  }\n\n  topLevelRuleRecord(name: string, def: Function): Rule {\n    try {\n      const newTopLevelRule = new Rule({ definition: [], name: name })\n      newTopLevelRule.name = name\n      this.recordingProdStack.push(newTopLevelRule)\n      def.call(this)\n      this.recordingProdStack.pop()\n      return newTopLevelRule\n    } catch (originalError) {\n      if (originalError.KNOWN_RECORDER_ERROR !== true) {\n        try {\n          originalError.message =\n            originalError.message +\n            '\\n\\t This error was thrown during the \"grammar recording phase\" For more info see:\\n\\t' +\n            \"https://chevrotain.io/docs/guide/internals.html#grammar-recording\"\n        } catch (mutabilityError) {\n          // We may not be able to modify the original error object\n          throw originalError\n        }\n      }\n      throw originalError\n    }\n  }\n\n  // Implementation of parsing DSL\n  optionInternalRecord<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,\n    occurrence: number\n  ): OUT {\n    return recordProd.call(this, Option, actionORMethodDef, occurrence)\n  }\n\n  atLeastOneInternalRecord<OUT>(\n    this: MixedInParser,\n    occurrence: number,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOptsWithErr<OUT>\n  ): void {\n    recordProd.call(this, RepetitionMandatory, actionORMethodDef, occurrence)\n  }\n\n  atLeastOneSepFirstInternalRecord<OUT>(\n    this: MixedInParser,\n    occurrence: number,\n    options: AtLeastOneSepMethodOpts<OUT>\n  ): void {\n    recordProd.call(\n      this,\n      RepetitionMandatoryWithSeparator,\n      options,\n      occurrence,\n      HANDLE_SEPARATOR\n    )\n  }\n\n  manyInternalRecord<OUT>(\n    this: MixedInParser,\n    occurrence: number,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>\n  ): void {\n    recordProd.call(this, Repetition, actionORMethodDef, occurrence)\n  }\n\n  manySepFirstInternalRecord<OUT>(\n    this: MixedInParser,\n    occurrence: number,\n    options: ManySepMethodOpts<OUT>\n  ): void {\n    recordProd.call(\n      this,\n      RepetitionWithSeparator,\n      options,\n      occurrence,\n      HANDLE_SEPARATOR\n    )\n  }\n\n  orInternalRecord<T>(\n    this: MixedInParser,\n    altsOrOpts: IOrAlt<any>[] | OrMethodOpts<unknown>,\n    occurrence: number\n  ): T {\n    return recordOrProd.call(this, altsOrOpts, occurrence)\n  }\n\n  subruleInternalRecord<ARGS extends unknown[], R>(\n    this: MixedInParser,\n    ruleToCall: ParserMethodInternal<ARGS, R>,\n    occurrence: number,\n    options?: SubruleMethodOpts<ARGS>\n  ): R | CstNode {\n    assertMethodIdxIsValid(occurrence)\n    if (!ruleToCall || has(ruleToCall, \"ruleName\") === false) {\n      const error: any = new Error(\n        `<SUBRULE${getIdxSuffix(occurrence)}> argument is invalid` +\n          ` expecting a Parser method reference but got: <${JSON.stringify(\n            ruleToCall\n          )}>` +\n          `\\n inside top level rule: <${\n            (<Rule>this.recordingProdStack[0]).name\n          }>`\n      )\n      error.KNOWN_RECORDER_ERROR = true\n      throw error\n    }\n\n    const prevProd: any = peek(this.recordingProdStack)\n    const ruleName = ruleToCall.ruleName\n    const newNoneTerminal = new NonTerminal({\n      idx: occurrence,\n      nonTerminalName: ruleName,\n      label: options?.LABEL,\n      // The resolving of the `referencedRule` property will be done once all the Rule's GASTs have been created\n      referencedRule: undefined\n    })\n    prevProd.definition.push(newNoneTerminal)\n\n    return this.outputCst ? RECORDING_PHASE_CSTNODE : <any>RECORDING_NULL_OBJECT\n  }\n\n  consumeInternalRecord(\n    this: MixedInParser,\n    tokType: TokenType,\n    occurrence: number,\n    options?: ConsumeMethodOpts\n  ): IToken {\n    assertMethodIdxIsValid(occurrence)\n    if (!hasShortKeyProperty(tokType)) {\n      const error: any = new Error(\n        `<CONSUME${getIdxSuffix(occurrence)}> argument is invalid` +\n          ` expecting a TokenType reference but got: <${JSON.stringify(\n            tokType\n          )}>` +\n          `\\n inside top level rule: <${\n            (<Rule>this.recordingProdStack[0]).name\n          }>`\n      )\n      error.KNOWN_RECORDER_ERROR = true\n      throw error\n    }\n    const prevProd: any = peek(this.recordingProdStack)\n    const newNoneTerminal = new Terminal({\n      idx: occurrence,\n      terminalType: tokType,\n      label: options?.LABEL\n    })\n    prevProd.definition.push(newNoneTerminal)\n\n    return RECORDING_PHASE_TOKEN\n  }\n}\n\nfunction recordProd(\n  prodConstructor: any,\n  mainProdArg: any,\n  occurrence: number,\n  handleSep: boolean = false\n): any {\n  assertMethodIdxIsValid(occurrence)\n  const prevProd: any = peek(this.recordingProdStack)\n  const grammarAction = isFunction(mainProdArg) ? mainProdArg : mainProdArg.DEF\n\n  const newProd = new prodConstructor({ definition: [], idx: occurrence })\n  if (handleSep) {\n    newProd.separator = mainProdArg.SEP\n  }\n  if (has(mainProdArg, \"MAX_LOOKAHEAD\")) {\n    newProd.maxLookahead = mainProdArg.MAX_LOOKAHEAD\n  }\n\n  this.recordingProdStack.push(newProd)\n  grammarAction.call(this)\n  prevProd.definition.push(newProd)\n  this.recordingProdStack.pop()\n\n  return RECORDING_NULL_OBJECT\n}\n\nfunction recordOrProd(mainProdArg: any, occurrence: number): any {\n  assertMethodIdxIsValid(occurrence)\n  const prevProd: any = peek(this.recordingProdStack)\n  // Only an array of alternatives\n  const hasOptions = isArray(mainProdArg) === false\n  const alts: IOrAlt<unknown>[] =\n    hasOptions === false ? mainProdArg : mainProdArg.DEF\n\n  const newOrProd = new Alternation({\n    definition: [],\n    idx: occurrence,\n    ignoreAmbiguities: hasOptions && mainProdArg.IGNORE_AMBIGUITIES === true\n  })\n  if (has(mainProdArg, \"MAX_LOOKAHEAD\")) {\n    newOrProd.maxLookahead = mainProdArg.MAX_LOOKAHEAD\n  }\n\n  const hasPredicates = some(alts, (currAlt: any) => isFunction(currAlt.GATE))\n  newOrProd.hasPredicates = hasPredicates\n\n  prevProd.definition.push(newOrProd)\n\n  forEach(alts, (currAlt) => {\n    const currAltFlat = new Alternative({ definition: [] })\n    newOrProd.definition.push(currAltFlat)\n    if (has(currAlt, \"IGNORE_AMBIGUITIES\")) {\n      currAltFlat.ignoreAmbiguities = currAlt.IGNORE_AMBIGUITIES as boolean // assumes end user provides the correct config value/type\n    }\n    // **implicit** ignoreAmbiguities due to usage of gate\n    else if (has(currAlt, \"GATE\")) {\n      currAltFlat.ignoreAmbiguities = true\n    }\n    this.recordingProdStack.push(currAltFlat)\n    currAlt.ALT.call(this)\n    this.recordingProdStack.pop()\n  })\n  return RECORDING_NULL_OBJECT\n}\n\nfunction getIdxSuffix(idx: number): string {\n  return idx === 0 ? \"\" : `${idx}`\n}\n\nfunction assertMethodIdxIsValid(idx: number): void {\n  if (idx < 0 || idx > MAX_METHOD_IDX) {\n    const error: any = new Error(\n      // The stack trace will contain all the needed details\n      `Invalid DSL Method idx value: <${idx}>\\n\\t` +\n        `Idx value must be a none negative value smaller than ${\n          MAX_METHOD_IDX + 1\n        }`\n    )\n    error.KNOWN_RECORDER_ERROR = true\n    throw error\n  }\n}\n", "import { IParserConfig } from \"@chevrotain/types\"\nimport has from \"lodash/has\"\nimport { timer } from \"@chevrotain/utils\"\nimport { MixedInParser } from \"./parser_traits\"\nimport { DEFAULT_PARSER_CONFIG } from \"../parser\"\n\n/**\n * Trait responsible for runtime parsing errors.\n */\nexport class PerformanceTracer {\n  traceInitPerf: boolean | number\n  traceInitMaxIdent: number\n  traceInitIndent: number\n\n  initPerformanceTracer(config: IParserConfig) {\n    if (has(config, \"traceInitPerf\")) {\n      const userTraceInitPerf = config.traceInitPerf\n      const traceIsNumber = typeof userTraceInitPerf === \"number\"\n      this.traceInitMaxIdent = traceIsNumber\n        ? <number>userTraceInitPerf\n        : Infinity\n      this.traceInitPerf = traceIsNumber\n        ? userTraceInitPerf > 0\n        : (userTraceInitPerf as boolean) // assumes end user provides the correct config value/type\n    } else {\n      this.traceInitMaxIdent = 0\n      this.traceInitPerf = DEFAULT_PARSER_CONFIG.traceInitPerf\n    }\n\n    this.traceInitIndent = -1\n  }\n\n  TRACE_INIT<T>(this: MixedInParser, phaseDesc: string, phaseImpl: () => T): T {\n    // No need to optimize this using NOOP pattern because\n    // It is not called in a hot spot...\n    if (this.traceInitPerf === true) {\n      this.traceInitIndent++\n      const indent = new Array(this.traceInitIndent + 1).join(\"\\t\")\n      if (this.traceInitIndent < this.traceInitMaxIdent) {\n        console.log(`${indent}--> <${phaseDesc}>`)\n      }\n      const { time, value } = timer(phaseImpl)\n      /* istanbul ignore next - Difficult to reproduce specific performance behavior (>10ms) in tests */\n      const traceMethod = time > 10 ? console.warn : console.log\n      if (this.traceInitIndent < this.traceInitMaxIdent) {\n        traceMethod(`${indent}<-- <${phaseDesc}> time: ${time}ms`)\n      }\n      this.traceInitIndent--\n      return value\n    } else {\n      return phaseImpl()\n    }\n  }\n}\n", "export function applyMixins(derivedCtor: any, baseCtors: any[]) {\n  baseCtors.forEach((baseCtor) => {\n    const baseProto = baseCtor.prototype\n    Object.getOwnPropertyNames(baseProto).forEach((propName) => {\n      if (propName === \"constructor\") {\n        return\n      }\n\n      const basePropDescriptor = Object.getOwnPropertyDescriptor(\n        baseProto,\n        propName\n      )\n      // Handle Accessors\n      if (\n        basePropDescriptor &&\n        (basePropDescriptor.get || basePropDescriptor.set)\n      ) {\n        Object.defineProperty(\n          derivedCtor.prototype,\n          propName,\n          basePropDescriptor\n        )\n      } else {\n        derivedCtor.prototype[propName] = baseCtor.prototype[propName]\n      }\n    })\n  })\n}\n", "import isEmpty from \"lodash/isEmpty\"\nimport map from \"lodash/map\"\nimport forEach from \"lodash/forEach\"\nimport values from \"lodash/values\"\nimport has from \"lodash/has\"\nimport clone from \"lodash/clone\"\nimport { toFastProperties } from \"@chevrotain/utils\"\nimport { computeAllProdsFollows } from \"../grammar/follow\"\nimport { createTokenInstance, EOF } from \"../../scan/tokens_public\"\nimport {\n  defaultGrammarValidatorErrorProvider,\n  defaultParserErrorProvider\n} from \"../errors_public\"\nimport {\n  resolveGrammar,\n  validateGrammar\n} from \"../grammar/gast/gast_resolver_public\"\nimport {\n  CstNode,\n  IParserConfig,\n  IRecognitionException,\n  IRuleConfig,\n  IToken,\n  TokenType,\n  TokenVocabulary\n} from \"@chevrotain/types\"\nimport { Recoverable } from \"./traits/recoverable\"\nimport { LooksAhead } from \"./traits/looksahead\"\nimport { TreeBuilder } from \"./traits/tree_builder\"\nimport { LexerAdapter } from \"./traits/lexer_adapter\"\nimport { RecognizerApi } from \"./traits/recognizer_api\"\nimport { RecognizerEngine } from \"./traits/recognizer_engine\"\n\nimport { ErrorHandler } from \"./traits/error_handler\"\nimport { MixedInParser } from \"./traits/parser_traits\"\nimport { ContentAssist } from \"./traits/context_assist\"\nimport { GastRecorder } from \"./traits/gast_recorder\"\nimport { PerformanceTracer } from \"./traits/perf_tracer\"\nimport { applyMixins } from \"./utils/apply_mixins\"\nimport { IParserDefinitionError } from \"../grammar/types\"\nimport { Rule } from \"@chevrotain/gast\"\nimport { IParserConfigInternal, ParserMethodInternal } from \"./types\"\nimport { validateLookahead } from \"../grammar/checks\"\n\nexport const END_OF_FILE = createTokenInstance(\n  EOF,\n  \"\",\n  NaN,\n  NaN,\n  NaN,\n  NaN,\n  NaN,\n  NaN\n)\nObject.freeze(END_OF_FILE)\n\nexport type TokenMatcher = (token: IToken, tokType: TokenType) => boolean\n\nexport const DEFAULT_PARSER_CONFIG: Required<\n  Omit<IParserConfigInternal, \"lookaheadStrategy\">\n> = Object.freeze({\n  recoveryEnabled: false,\n  maxLookahead: 3,\n  dynamicTokensEnabled: false,\n  outputCst: true,\n  errorMessageProvider: defaultParserErrorProvider,\n  nodeLocationTracking: \"none\",\n  traceInitPerf: false,\n  skipValidations: false\n})\n\nexport const DEFAULT_RULE_CONFIG: Required<IRuleConfig<any>> = Object.freeze({\n  recoveryValueFunc: () => undefined,\n  resyncEnabled: true\n})\n\nexport enum ParserDefinitionErrorType {\n  INVALID_RULE_NAME = 0,\n  DUPLICATE_RULE_NAME = 1,\n  INVALID_RULE_OVERRIDE = 2,\n  DUPLICATE_PRODUCTIONS = 3,\n  UNRESOLVED_SUBRULE_REF = 4,\n  LEFT_RECURSION = 5,\n  NONE_LAST_EMPTY_ALT = 6,\n  AMBIGUOUS_ALTS = 7,\n  CONFLICT_TOKENS_RULES_NAMESPACE = 8,\n  INVALID_TOKEN_NAME = 9,\n  NO_NON_EMPTY_LOOKAHEAD = 10,\n  AMBIGUOUS_PREFIX_ALTS = 11,\n  TOO_MANY_ALTS = 12,\n  CUSTOM_LOOKAHEAD_VALIDATION = 13\n}\n\nexport interface IParserDuplicatesDefinitionError\n  extends IParserDefinitionError {\n  dslName: string\n  occurrence: number\n  parameter?: string\n}\n\nexport interface IParserEmptyAlternativeDefinitionError\n  extends IParserDefinitionError {\n  occurrence: number\n  alternative: number\n}\n\nexport interface IParserAmbiguousAlternativesDefinitionError\n  extends IParserDefinitionError {\n  occurrence: number | string\n  alternatives: number[]\n}\n\nexport interface IParserUnresolvedRefDefinitionError\n  extends IParserDefinitionError {\n  unresolvedRefName: string\n}\n\nexport interface IParserState {\n  errors: IRecognitionException[]\n  lexerState: any\n  RULE_STACK: number[]\n  CST_STACK: CstNode[]\n}\n\nexport type Predicate = () => boolean\n\nexport function EMPTY_ALT(): () => undefined\nexport function EMPTY_ALT<T>(value: T): () => T\nexport function EMPTY_ALT(value: any = undefined) {\n  return function () {\n    return value\n  }\n}\n\nexport class Parser {\n  // Set this flag to true if you don't want the Parser to throw error when problems in it's definition are detected.\n  // (normally during the parser's constructor).\n  // This is a design time flag, it will not affect the runtime error handling of the parser, just design time errors,\n  // for example: duplicate rule names, referencing an unresolved subrule, ect...\n  // This flag should not be enabled during normal usage, it is used in special situations, for example when\n  // needing to display the parser definition errors in some GUI(online playground).\n  static DEFER_DEFINITION_ERRORS_HANDLING: boolean = false\n\n  /**\n   *  @deprecated use the **instance** method with the same name instead\n   */\n  static performSelfAnalysis(parserInstance: Parser): void {\n    throw Error(\n      \"The **static** `performSelfAnalysis` method has been deprecated.\" +\n        \"\\t\\nUse the **instance** method with the same name instead.\"\n    )\n  }\n\n  public performSelfAnalysis(this: MixedInParser): void {\n    this.TRACE_INIT(\"performSelfAnalysis\", () => {\n      let defErrorsMsgs\n\n      this.selfAnalysisDone = true\n      const className = this.className\n\n      this.TRACE_INIT(\"toFastProps\", () => {\n        // Without this voodoo magic the parser would be x3-x4 slower\n        // It seems it is better to invoke `toFastProperties` **before**\n        // Any manipulations of the `this` object done during the recording phase.\n        toFastProperties(this)\n      })\n\n      this.TRACE_INIT(\"Grammar Recording\", () => {\n        try {\n          this.enableRecording()\n          // Building the GAST\n          forEach(this.definedRulesNames, (currRuleName) => {\n            const wrappedRule = (this as any)[\n              currRuleName\n            ] as ParserMethodInternal<unknown[], unknown>\n            const originalGrammarAction = wrappedRule[\"originalGrammarAction\"]\n            let recordedRuleGast!: Rule\n            this.TRACE_INIT(`${currRuleName} Rule`, () => {\n              recordedRuleGast = this.topLevelRuleRecord(\n                currRuleName,\n                originalGrammarAction\n              )\n            })\n            this.gastProductionsCache[currRuleName] = recordedRuleGast\n          })\n        } finally {\n          this.disableRecording()\n        }\n      })\n\n      let resolverErrors: IParserDefinitionError[] = []\n      this.TRACE_INIT(\"Grammar Resolving\", () => {\n        resolverErrors = resolveGrammar({\n          rules: values(this.gastProductionsCache)\n        })\n        this.definitionErrors = this.definitionErrors.concat(resolverErrors)\n      })\n\n      this.TRACE_INIT(\"Grammar Validations\", () => {\n        // only perform additional grammar validations IFF no resolving errors have occurred.\n        // as unresolved grammar may lead to unhandled runtime exceptions in the follow up validations.\n        if (isEmpty(resolverErrors) && this.skipValidations === false) {\n          const validationErrors = validateGrammar({\n            rules: values(this.gastProductionsCache),\n            tokenTypes: values(this.tokensMap),\n            errMsgProvider: defaultGrammarValidatorErrorProvider,\n            grammarName: className\n          })\n          const lookaheadValidationErrors = validateLookahead({\n            lookaheadStrategy: this.lookaheadStrategy,\n            rules: values(this.gastProductionsCache),\n            tokenTypes: values(this.tokensMap),\n            grammarName: className\n          })\n          this.definitionErrors = this.definitionErrors.concat(\n            validationErrors,\n            lookaheadValidationErrors\n          )\n        }\n      })\n\n      // this analysis may fail if the grammar is not perfectly valid\n      if (isEmpty(this.definitionErrors)) {\n        // The results of these computations are not needed unless error recovery is enabled.\n        if (this.recoveryEnabled) {\n          this.TRACE_INIT(\"computeAllProdsFollows\", () => {\n            const allFollows = computeAllProdsFollows(\n              values(this.gastProductionsCache)\n            )\n            this.resyncFollows = allFollows\n          })\n        }\n\n        this.TRACE_INIT(\"ComputeLookaheadFunctions\", () => {\n          this.lookaheadStrategy.initialize?.({\n            rules: values(this.gastProductionsCache)\n          })\n          this.preComputeLookaheadFunctions(values(this.gastProductionsCache))\n        })\n      }\n\n      if (\n        !Parser.DEFER_DEFINITION_ERRORS_HANDLING &&\n        !isEmpty(this.definitionErrors)\n      ) {\n        defErrorsMsgs = map(\n          this.definitionErrors,\n          (defError) => defError.message\n        )\n        throw new Error(\n          `Parser Definition Errors detected:\\n ${defErrorsMsgs.join(\n            \"\\n-------------------------------\\n\"\n          )}`\n        )\n      }\n    })\n  }\n\n  definitionErrors: IParserDefinitionError[] = []\n  selfAnalysisDone = false\n  protected skipValidations: boolean\n\n  constructor(tokenVocabulary: TokenVocabulary, config: IParserConfig) {\n    const that: MixedInParser = this as any\n    that.initErrorHandler(config)\n    that.initLexerAdapter()\n    that.initLooksAhead(config)\n    that.initRecognizerEngine(tokenVocabulary, config)\n    that.initRecoverable(config)\n    that.initTreeBuilder(config)\n    that.initContentAssist()\n    that.initGastRecorder(config)\n    that.initPerformanceTracer(config)\n\n    if (has(config, \"ignoredIssues\")) {\n      throw new Error(\n        \"The <ignoredIssues> IParserConfig property has been deprecated.\\n\\t\" +\n          \"Please use the <IGNORE_AMBIGUITIES> flag on the relevant DSL method instead.\\n\\t\" +\n          \"See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#IGNORING_AMBIGUITIES\\n\\t\" +\n          \"For further details.\"\n      )\n    }\n\n    this.skipValidations = has(config, \"skipValidations\")\n      ? (config.skipValidations as boolean) // casting assumes the end user passing the correct type\n      : DEFAULT_PARSER_CONFIG.skipValidations\n  }\n}\n\napplyMixins(Parser, [\n  Recoverable,\n  LooksAhead,\n  TreeBuilder,\n  LexerAdapter,\n  RecognizerEngine,\n  RecognizerApi,\n  ErrorHandler,\n  ContentAssist,\n  GastRecorder,\n  PerformanceTracer\n])\n\nexport class CstParser extends Parser {\n  constructor(\n    tokenVocabulary: TokenVocabulary,\n    config: IParserConfigInternal = DEFAULT_PARSER_CONFIG\n  ) {\n    const configClone = clone(config)\n    configClone.outputCst = true\n    super(tokenVocabulary, configClone)\n  }\n}\n\nexport class EmbeddedActionsParser extends Parser {\n  constructor(\n    tokenVocabulary: TokenVocabulary,\n    config: IParserConfigInternal = DEFAULT_PARSER_CONFIG\n  ) {\n    const configClone = clone(config)\n    configClone.outputCst = false\n    super(tokenVocabulary, configClone)\n  }\n}\n", "import type {\n  Alternation,\n  Alternative,\n  IProduction,\n  Option,\n  Repetition,\n  RepetitionMandatory,\n  RepetitionMandatoryWithSeparator,\n  RepetitionWithSeparator,\n  Rule,\n  Terminal,\n  TokenType\n} from \"@chevrotain/types\"\nimport { NonTerminal, GAstVisitor } from \"@chevrotain/gast\"\nimport map from \"lodash/map\"\nimport flatten from \"lodash/flatten\"\nimport values from \"lodash/values\"\nimport some from \"lodash/some\"\nimport groupBy from \"lodash/groupBy\"\nimport assign from \"lodash/assign\"\n\nexport function buildModel(\n  productions: Record<string, Rule>\n): CstNodeTypeDefinition[] {\n  const generator = new CstNodeDefinitionGenerator()\n  const allRules = values(productions)\n  return map(allRules, (rule) => generator.visitRule(rule))\n}\n\nexport type CstNodeTypeDefinition = {\n  name: string\n  properties: PropertyTypeDefinition[]\n}\n\nexport type PropertyTypeDefinition = {\n  name: string\n  type: PropertyArrayType\n  optional: boolean\n}\n\nexport type PropertyArrayType =\n  | TokenArrayType\n  | RuleArrayType\n  | (TokenArrayType | RuleArrayType)[]\n\nexport type TokenArrayType = { kind: \"token\" }\nexport type RuleArrayType = {\n  kind: \"rule\"\n  name: string\n}\n\nclass CstNodeDefinitionGenerator extends GAstVisitor {\n  visitRule(node: Rule): CstNodeTypeDefinition {\n    const rawElements = this.visitEach(node.definition)\n\n    const grouped = groupBy(rawElements, (el) => el.propertyName)\n    const properties = map(grouped, (group, propertyName) => {\n      const allNullable = !some(group, (el) => !el.canBeNull)\n\n      // In an alternation with a label a property name can have\n      // multiple types.\n      let propertyType: PropertyArrayType = group[0].type\n      if (group.length > 1) {\n        propertyType = map(group, (g) => g.type)\n      }\n\n      return {\n        name: propertyName,\n        type: propertyType,\n        optional: allNullable\n      } as PropertyTypeDefinition\n    })\n\n    return {\n      name: node.name,\n      properties: properties\n    }\n  }\n\n  visitAlternative(node: Alternative) {\n    return this.visitEachAndOverrideWith(node.definition, { canBeNull: true })\n  }\n\n  visitOption(node: Option) {\n    return this.visitEachAndOverrideWith(node.definition, { canBeNull: true })\n  }\n\n  visitRepetition(node: Repetition) {\n    return this.visitEachAndOverrideWith(node.definition, { canBeNull: true })\n  }\n\n  visitRepetitionMandatory(node: RepetitionMandatory) {\n    return this.visitEach(node.definition)\n  }\n\n  visitRepetitionMandatoryWithSeparator(\n    node: RepetitionMandatoryWithSeparator\n  ) {\n    return this.visitEach(node.definition).concat({\n      propertyName: node.separator.name,\n      canBeNull: true,\n      type: getType(node.separator)\n    })\n  }\n\n  visitRepetitionWithSeparator(node: RepetitionWithSeparator) {\n    return this.visitEachAndOverrideWith(node.definition, {\n      canBeNull: true\n    }).concat({\n      propertyName: node.separator.name,\n      canBeNull: true,\n      type: getType(node.separator)\n    })\n  }\n\n  visitAlternation(node: Alternation) {\n    return this.visitEachAndOverrideWith(node.definition, { canBeNull: true })\n  }\n\n  visitTerminal(node: Terminal): PropertyTupleElement[] {\n    return [\n      {\n        propertyName: node.label || node.terminalType.name,\n        canBeNull: false,\n        type: getType(node)\n      }\n    ]\n  }\n\n  visitNonTerminal(node: NonTerminal): PropertyTupleElement[] {\n    return [\n      {\n        propertyName: node.label || node.nonTerminalName,\n        canBeNull: false,\n        type: getType(node)\n      }\n    ]\n  }\n\n  private visitEachAndOverrideWith(\n    definition: IProduction[],\n    override: Partial<PropertyTupleElement>\n  ) {\n    return map(\n      this.visitEach(definition),\n      (definition) => assign({}, definition, override) as PropertyTupleElement\n    )\n  }\n\n  private visitEach(definition: IProduction[]) {\n    return flatten<PropertyTupleElement>(\n      map(\n        definition,\n        (definition) => this.visit(definition) as PropertyTupleElement[]\n      )\n    )\n  }\n}\n\ntype PropertyTupleElement = {\n  propertyName: string\n  canBeNull: boolean\n  type: TokenArrayType | RuleArrayType\n}\n\nfunction getType(\n  production: Terminal | NonTerminal | TokenType\n): TokenArrayType | RuleArrayType {\n  if (production instanceof NonTerminal) {\n    return {\n      kind: \"rule\",\n      name: production.referencedRule.name\n    }\n  }\n\n  return { kind: \"token\" }\n}\n", "var baseSlice = require('./_baseSlice');\n\n/**\n * Casts `array` to a slice if it's needed.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {number} start The start position.\n * @param {number} [end=array.length] The end position.\n * @returns {Array} Returns the cast slice.\n */\nfunction castSlice(array, start, end) {\n  var length = array.length;\n  end = end === undefined ? length : end;\n  return (!start && end >= length) ? array : baseSlice(array, start, end);\n}\n\nmodule.exports = castSlice;\n", "/** Used to compose unicode character classes. */\nvar rsAstralRange = '\\\\ud800-\\\\udfff',\n    rsComboMarksRange = '\\\\u0300-\\\\u036f',\n    reComboHalfMarksRange = '\\\\ufe20-\\\\ufe2f',\n    rsComboSymbolsRange = '\\\\u20d0-\\\\u20ff',\n    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,\n    rsVarRange = '\\\\ufe0e\\\\ufe0f';\n\n/** Used to compose unicode capture groups. */\nvar rsZWJ = '\\\\u200d';\n\n/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */\nvar reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');\n\n/**\n * Checks if `string` contains Unicode symbols.\n *\n * @private\n * @param {string} string The string to inspect.\n * @returns {boolean} Returns `true` if a symbol is found, else `false`.\n */\nfunction hasUnicode(string) {\n  return reHasUnicode.test(string);\n}\n\nmodule.exports = hasUnicode;\n", "/**\n * Converts an ASCII `string` to an array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the converted array.\n */\nfunction asciiToArray(string) {\n  return string.split('');\n}\n\nmodule.exports = asciiToArray;\n", "/** Used to compose unicode character classes. */\nvar rsAstralRange = '\\\\ud800-\\\\udfff',\n    rsComboMarksRange = '\\\\u0300-\\\\u036f',\n    reComboHalfMarksRange = '\\\\ufe20-\\\\ufe2f',\n    rsComboSymbolsRange = '\\\\u20d0-\\\\u20ff',\n    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,\n    rsVarRange = '\\\\ufe0e\\\\ufe0f';\n\n/** Used to compose unicode capture groups. */\nvar rsAstral = '[' + rsAstralRange + ']',\n    rsCombo = '[' + rsComboRange + ']',\n    rsFitz = '\\\\ud83c[\\\\udffb-\\\\udfff]',\n    rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',\n    rsNonAstral = '[^' + rsAstralRange + ']',\n    rsRegional = '(?:\\\\ud83c[\\\\udde6-\\\\uddff]){2}',\n    rsSurrPair = '[\\\\ud800-\\\\udbff][\\\\udc00-\\\\udfff]',\n    rsZWJ = '\\\\u200d';\n\n/** Used to compose unicode regexes. */\nvar reOptMod = rsModifier + '?',\n    rsOptVar = '[' + rsVarRange + ']?',\n    rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',\n    rsSeq = rsOptVar + reOptMod + rsOptJoin,\n    rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';\n\n/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */\nvar reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');\n\n/**\n * Converts a Unicode `string` to an array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the converted array.\n */\nfunction unicodeToArray(string) {\n  return string.match(reUnicode) || [];\n}\n\nmodule.exports = unicodeToArray;\n", "var asciiToArray = require('./_asciiToArray'),\n    hasUnicode = require('./_hasUnicode'),\n    unicodeToArray = require('./_unicodeToArray');\n\n/**\n * Converts `string` to an array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the converted array.\n */\nfunction stringToArray(string) {\n  return hasUnicode(string)\n    ? unicodeToArray(string)\n    : asciiToArray(string);\n}\n\nmodule.exports = stringToArray;\n", "var castSlice = require('./_castSlice'),\n    hasUnicode = require('./_hasUnicode'),\n    stringToArray = require('./_stringToArray'),\n    toString = require('./toString');\n\n/**\n * Creates a function like `_.lowerFirst`.\n *\n * @private\n * @param {string} methodName The name of the `String` case method to use.\n * @returns {Function} Returns the new case function.\n */\nfunction createCaseFirst(methodName) {\n  return function(string) {\n    string = toString(string);\n\n    var strSymbols = hasUnicode(string)\n      ? stringToArray(string)\n      : undefined;\n\n    var chr = strSymbols\n      ? strSymbols[0]\n      : string.charAt(0);\n\n    var trailing = strSymbols\n      ? castSlice(strSymbols, 1).join('')\n      : string.slice(1);\n\n    return chr[methodName]() + trailing;\n  };\n}\n\nmodule.exports = createCaseFirst;\n", "var createCaseFirst = require('./_createCaseFirst');\n\n/**\n * Converts the first character of `string` to upper case.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category String\n * @param {string} [string=''] The string to convert.\n * @returns {string} Returns the converted string.\n * @example\n *\n * _.upperFirst('fred');\n * // => 'Fred'\n *\n * _.upperFirst('FRED');\n * // => 'FRED'\n */\nvar upperFirst = createCaseFirst('toUpperCase');\n\nmodule.exports = upperFirst;\n", "import flatten from \"lodash/flatten\"\nimport isArray from \"lodash/isArray\"\nimport map from \"lodash/map\"\nimport reduce from \"lodash/reduce\"\nimport uniq from \"lodash/uniq\"\nimport upperFirst from \"lodash/upperFirst\"\nimport { GenerateDtsOptions } from \"@chevrotain/types\"\nimport {\n  CstNodeTypeDefinition,\n  PropertyTypeDefinition,\n  PropertyArrayType,\n  TokenArrayType,\n  RuleArrayType\n} from \"./model\"\n\nexport function genDts(\n  model: CstNodeTypeDefinition[],\n  options: Required<GenerateDtsOptions>\n): string {\n  let contentParts: string[] = []\n\n  contentParts = contentParts.concat(\n    `import type { CstNode, ICstVisitor, IToken } from \"chevrotain\";`\n  )\n\n  contentParts = contentParts.concat(\n    flatten(map(model, (node) => genCstNodeTypes(node)))\n  )\n\n  if (options.includeVisitorInterface) {\n    contentParts = contentParts.concat(\n      genVisitor(options.visitorInterfaceName, model)\n    )\n  }\n\n  return contentParts.join(\"\\n\\n\") + \"\\n\"\n}\n\nfunction genCstNodeTypes(node: CstNodeTypeDefinition) {\n  const nodeCstInterface = genNodeInterface(node)\n  const nodeChildrenInterface = genNodeChildrenType(node)\n\n  return [nodeCstInterface, nodeChildrenInterface]\n}\n\nfunction genNodeInterface(node: CstNodeTypeDefinition) {\n  const nodeInterfaceName = getNodeInterfaceName(node.name)\n  const childrenTypeName = getNodeChildrenTypeName(node.name)\n\n  return `export interface ${nodeInterfaceName} extends CstNode {\n  name: \"${node.name}\";\n  children: ${childrenTypeName};\n}`\n}\n\nfunction genNodeChildrenType(node: CstNodeTypeDefinition) {\n  const typeName = getNodeChildrenTypeName(node.name)\n\n  return `export type ${typeName} = {\n  ${map(node.properties, (property) => genChildProperty(property)).join(\"\\n  \")}\n};`\n}\n\nfunction genChildProperty(prop: PropertyTypeDefinition) {\n  const typeName = buildTypeString(prop.type)\n  return `${prop.name}${prop.optional ? \"?\" : \"\"}: ${typeName}[];`\n}\n\nfunction genVisitor(name: string, nodes: CstNodeTypeDefinition[]) {\n  return `export interface ${name}<IN, OUT> extends ICstVisitor<IN, OUT> {\n  ${map(nodes, (node) => genVisitorFunction(node)).join(\"\\n  \")}\n}`\n}\n\nfunction genVisitorFunction(node: CstNodeTypeDefinition) {\n  const childrenTypeName = getNodeChildrenTypeName(node.name)\n  return `${node.name}(children: ${childrenTypeName}, param?: IN): OUT;`\n}\n\nfunction buildTypeString(type: PropertyArrayType) {\n  if (isArray(type)) {\n    const typeNames = uniq(map(type, (t) => getTypeString(t)))\n    const typeString = reduce(typeNames, (sum, t) => sum + \" | \" + t)\n    return \"(\" + typeString + \")\"\n  } else {\n    return getTypeString(type)\n  }\n}\n\nfunction getTypeString(type: TokenArrayType | RuleArrayType) {\n  if (type.kind === \"token\") {\n    return \"IToken\"\n  }\n  return getNodeInterfaceName(type.name)\n}\n\nfunction getNodeInterfaceName(ruleName: string) {\n  return upperFirst(ruleName) + \"CstNode\"\n}\n\nfunction getNodeChildrenTypeName(ruleName: string) {\n  return upperFirst(ruleName) + \"CstChildren\"\n}\n", "import { Rule, GenerateDtsOptions } from \"@chevrotain/types\"\nimport { buildModel } from \"./model\"\nimport { genDts } from \"./generate\"\n\nconst defaultOptions: Required<GenerateDtsOptions> = {\n  includeVisitorInterface: true,\n  visitorInterfaceName: \"ICstNodeVisitor\"\n}\n\nexport function generateCstDts(\n  productions: Record<string, Rule>,\n  options?: GenerateDtsOptions\n): string {\n  const effectiveOptions = {\n    ...defaultOptions,\n    ...options\n  }\n\n  const model = buildModel(productions)\n\n  return genDts(model, effectiveOptions)\n}\n", "import { VERSION } from \"../version\"\nimport { ISerializedGast } from \"@chevrotain/types\"\n\nexport function createSyntaxDiagramsCode(\n  grammar: ISerializedGast[],\n  {\n    resourceBase = `https://unpkg.com/chevrotain@${VERSION}/diagrams/`,\n    css = `https://unpkg.com/chevrotain@${VERSION}/diagrams/diagrams.css`\n  }: {\n    resourceBase?: string\n    css?: string\n  } = {}\n) {\n  const header = `\n<!-- This is a generated file -->\n<!DOCTYPE html>\n<meta charset=\"utf-8\">\n<style>\n  body {\n    background-color: hsl(30, 20%, 95%)\n  }\n</style>\n\n`\n  const cssHtml = `\n<link rel='stylesheet' href='${css}'>\n`\n\n  const scripts = `\n<script src='${resourceBase}vendor/railroad-diagrams.js'></script>\n<script src='${resourceBase}src/diagrams_builder.js'></script>\n<script src='${resourceBase}src/diagrams_behavior.js'></script>\n<script src='${resourceBase}src/main.js'></script>\n`\n  const diagramsDiv = `\n<div id=\"diagrams\" align=\"center\"></div>    \n`\n  const serializedGrammar = `\n<script>\n    window.serializedGrammar = ${JSON.stringify(grammar, null, \"  \")};\n</script>\n`\n\n  const initLogic = `\n<script>\n    var diagramsDiv = document.getElementById(\"diagrams\");\n    main.drawDiagramsFromSerializedGrammar(serializedGrammar, diagramsDiv);\n</script>\n`\n  return (\n    header + cssHtml + scripts + diagramsDiv + serializedGrammar + initLogic\n  )\n}\n", "/* istanbul ignore file - tricky to import some things from this module during testing */\n\n// semantic version\nexport { VERSION } from \"./version\"\n\nexport {\n  CstParser,\n  EmbeddedActionsParser,\n  ParserDefinitionErrorType,\n  EMPTY_ALT\n} from \"./parse/parser/parser\"\n\nexport { Lexer, LexerDefinitionErrorType } from \"./scan/lexer_public\"\n\n// Tokens utilities\nexport {\n  createToken,\n  createTokenInstance,\n  EOF,\n  tokenLabel,\n  tokenMatcher,\n  tokenName\n} from \"./scan/tokens_public\"\n\n// Lookahead\n\nexport { getLookaheadPaths } from \"./parse/grammar/lookahead\"\n\nexport { LLkLookaheadStrategy } from \"./parse/grammar/llk_lookahead\"\n\n// Other Utilities\n\nexport { defaultParserErrorProvider } from \"./parse/errors_public\"\n\nexport {\n  EarlyExitException,\n  isRecognitionException,\n  MismatchedTokenException,\n  NotAllInputParsedException,\n  NoViableAltException\n} from \"./parse/exceptions_public\"\n\nexport { defaultLexerErrorProvider } from \"./scan/lexer_errors_public\"\n\n// grammar reflection API\nexport {\n  Alternation,\n  Alternative,\n  NonTerminal,\n  Option,\n  Repetition,\n  RepetitionMandatory,\n  RepetitionMandatoryWithSeparator,\n  RepetitionWithSeparator,\n  Rule,\n  Terminal\n} from \"@chevrotain/gast\"\n\n// GAST Utilities\n\nexport {\n  serializeGrammar,\n  serializeProduction,\n  GAstVisitor\n} from \"@chevrotain/gast\"\n\nexport { generateCstDts } from \"@chevrotain/cst-dts-gen\"\n\n/* istanbul ignore next */\nexport function clearCache() {\n  console.warn(\n    \"The clearCache function was 'soft' removed from the Chevrotain API.\" +\n      \"\\n\\t It performs no action other than printing this message.\" +\n      \"\\n\\t Please avoid using it as it will be completely removed in the future\"\n  )\n}\n\nexport { createSyntaxDiagramsCode } from \"./diagrams/render_public\"\n\nexport class Parser {\n  constructor() {\n    throw new Error(\n      \"The Parser class has been deprecated, use CstParser or EmbeddedActionsParser instead.\\t\\n\" +\n        \"See: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_7-0-0\"\n    )\n  }\n}\n"],
  "mappings": "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",
  "names": ["exports", "require_isPrototype", "__commonJSMin", "exports", "module", "objectProto", "isPrototype", "value", "Ctor", "proto", "require_overArg", "__commonJSMin", "exports", "module", "overArg", "func", "transform", "arg", "require_nativeKeys", "__commonJSMin", "exports", "module", "overArg", "nativeKeys", "require_baseKeys", "__commonJSMin", "exports", "module", "isPrototype", "nativeKeys", "objectProto", "hasOwnProperty", "baseKeys", "object", "result", "key", "require_freeGlobal", "__commonJSMin", "exports", "module", "freeGlobal", "require_root", "__commonJSMin", "exports", "module", "freeGlobal", "freeSelf", "root", "require_Symbol", "__commonJSMin", "exports", "module", "root", "Symbol", "require_getRawTag", "__commonJSMin", "exports", "module", "Symbol", "objectProto", "hasOwnProperty", "nativeObjectToString", "symToStringTag", "getRawTag", "value", "isOwn", "tag", "unmasked", "result", "require_objectToString", "__commonJSMin", "exports", "module", "objectProto", "nativeObjectToString", "objectToString", "value", "require_baseGetTag", "__commonJSMin", "exports", "module", "Symbol", "getRawTag", "objectToString", "nullTag", "undefinedTag", "symToStringTag", "baseGetTag", "value", "require_isObject", "__commonJSMin", "exports", "module", "isObject", "value", "type", "require_isFunction", "__commonJSMin", "exports", "module", "baseGetTag", "isObject", "asyncTag", "funcTag", "genTag", "proxyTag", "isFunction", "value", "tag", "require_coreJsData", "__commonJSMin", "exports", "module", "root", "coreJsData", "require_isMasked", "__commonJSMin", "exports", "module", "coreJsData", "maskSrcKey", "uid", "isMasked", "func", "require_toSource", "__commonJSMin", "exports", "module", "funcProto", "funcToString", "toSource", "func", "require_baseIsNative", "__commonJSMin", "exports", "module", "isFunction", "isMasked", "isObject", "toSource", "reRegExpChar", "reIsHostCtor", "funcProto", "objectProto", "funcToString", "hasOwnProperty", "reIsNative", "baseIsNative", "value", "pattern", "require_getValue", "__commonJSMin", "exports", "module", "getValue", "object", "key", "require_getNative", "__commonJSMin", "exports", "module", "baseIsNative", "getValue", "getNative", "object", "key", "value", "require_DataView", "__commonJSMin", "exports", "module", "getNative", "root", "DataView", "require_Map", "__commonJSMin", "exports", "module", "getNative", "root", "Map", "require_Promise", "__commonJSMin", "exports", "module", "getNative", "root", "Promise", "require_Set", "__commonJSMin", "exports", "module", "getNative", "root", "Set", "require_WeakMap", "__commonJSMin", "exports", "module", "getNative", "root", "WeakMap", "require_getTag", "__commonJSMin", "exports", "module", "DataView", "Map", "Promise", "Set", "WeakMap", "baseGetTag", "toSource", "mapTag", "objectTag", "promiseTag", "setTag", "weakMapTag", "dataViewTag", "dataViewCtorString", "mapCtorString", "promiseCtorString", "setCtorString", "weakMapCtorString", "getTag", "value", "result", "Ctor", "ctorString", "require_isObjectLike", "__commonJSMin", "exports", "module", "isObjectLike", "value", "require_baseIsArguments", "__commonJSMin", "exports", "module", "baseGetTag", "isObjectLike", "argsTag", "baseIsArguments", "value", "require_isArguments", "__commonJSMin", "exports", "module", "baseIsArguments", "isObjectLike", "objectProto", "hasOwnProperty", "propertyIsEnumerable", "isArguments", "value", "require_isArray", "__commonJSMin", "exports", "module", "isArray", "require_isLength", "__commonJSMin", "exports", "module", "MAX_SAFE_INTEGER", "isLength", "value", "require_isArrayLike", "__commonJSMin", "exports", "module", "isFunction", "isLength", "isArrayLike", "value", "require_stubFalse", "__commonJSMin", "exports", "module", "stubFalse", "require_isBuffer", "__commonJSMin", "exports", "module", "root", "stubFalse", "freeExports", "freeModule", "moduleExports", "Buffer", "nativeIsBuffer", "isBuffer", "require_baseIsTypedArray", "__commonJSMin", "exports", "module", "baseGetTag", "isLength", "isObjectLike", "argsTag", "arrayTag", "boolTag", "dateTag", "errorTag", "funcTag", "mapTag", "numberTag", "objectTag", "regexpTag", "setTag", "stringTag", "weakMapTag", "arrayBufferTag", "dataViewTag", "float32Tag", "float64Tag", "int8Tag", "int16Tag", "int32Tag", "uint8Tag", "uint8ClampedTag", "uint16Tag", "uint32Tag", "typedArrayTags", "baseIsTypedArray", "value", "require_baseUnary", "__commonJSMin", "exports", "module", "baseUnary", "func", "value", "require_nodeUtil", "__commonJSMin", "exports", "module", "freeGlobal", "freeExports", "freeModule", "moduleExports", "freeProcess", "nodeUtil", "types", "require_isTypedArray", "__commonJSMin", "exports", "module", "baseIsTypedArray", "baseUnary", "nodeUtil", "nodeIsTypedArray", "isTypedArray", "require_isEmpty", "__commonJSMin", "exports", "module", "baseKeys", "getTag", "isArguments", "isArray", "isArrayLike", "isBuffer", "isPrototype", "isTypedArray", "mapTag", "setTag", "objectProto", "hasOwnProperty", "isEmpty", "value", "tag", "key", "require_arrayMap", "__commonJSMin", "exports", "module", "arrayMap", "array", "iteratee", "index", "length", "result", "require_listCacheClear", "__commonJSMin", "exports", "module", "listCacheClear", "require_eq", "__commonJSMin", "exports", "module", "eq", "value", "other", "require_assocIndexOf", "__commonJSMin", "exports", "module", "eq", "assocIndexOf", "array", "key", "length", "require_listCacheDelete", "__commonJSMin", "exports", "module", "assocIndexOf", "arrayProto", "splice", "listCacheDelete", "key", "data", "index", "lastIndex", "require_listCacheGet", "__commonJSMin", "exports", "module", "assocIndexOf", "listCacheGet", "key", "data", "index", "require_listCacheHas", "__commonJSMin", "exports", "module", "assocIndexOf", "listCacheHas", "key", "require_listCacheSet", "__commonJSMin", "exports", "module", "assocIndexOf", "listCacheSet", "key", "value", "data", "index", "require_ListCache", "__commonJSMin", "exports", "module", "listCacheClear", "listCacheDelete", "listCacheGet", "listCacheHas", "listCacheSet", "ListCache", "entries", "index", "length", "entry", "require_stackClear", "__commonJSMin", "exports", "module", "ListCache", "stackClear", "require_stackDelete", "__commonJSMin", "exports", "module", "stackDelete", "key", "data", "result", "require_stackGet", "__commonJSMin", "exports", "module", "stackGet", "key", "require_stackHas", "__commonJSMin", "exports", "module", "stackHas", "key", "require_nativeCreate", "__commonJSMin", "exports", "module", "getNative", "nativeCreate", "require_hashClear", "__commonJSMin", "exports", "module", "nativeCreate", "hashClear", "require_hashDelete", "__commonJSMin", "exports", "module", "hashDelete", "key", "result", "require_hashGet", "__commonJSMin", "exports", "module", "nativeCreate", "HASH_UNDEFINED", "objectProto", "hasOwnProperty", "hashGet", "key", "data", "result", "require_hashHas", "__commonJSMin", "exports", "module", "nativeCreate", "objectProto", "hasOwnProperty", "hashHas", "key", "data", "require_hashSet", "__commonJSMin", "exports", "module", "nativeCreate", "HASH_UNDEFINED", "hashSet", "key", "value", "data", "require_Hash", "__commonJSMin", "exports", "module", "hashClear", "hashDelete", "hashGet", "hashHas", "hashSet", "Hash", "entries", "index", "length", "entry", "require_mapCacheClear", "__commonJSMin", "exports", "module", "Hash", "ListCache", "Map", "mapCacheClear", "require_isKeyable", "__commonJSMin", "exports", "module", "isKeyable", "value", "type", "require_getMapData", "__commonJSMin", "exports", "module", "isKeyable", "getMapData", "map", "key", "data", "require_mapCacheDelete", "__commonJSMin", "exports", "module", "getMapData", "mapCacheDelete", "key", "result", "require_mapCacheGet", "__commonJSMin", "exports", "module", "getMapData", "mapCacheGet", "key", "require_mapCacheHas", "__commonJSMin", "exports", "module", "getMapData", "mapCacheHas", "key", "require_mapCacheSet", "__commonJSMin", "exports", "module", "getMapData", "mapCacheSet", "key", "value", "data", "size", "require_MapCache", "__commonJSMin", "exports", "module", "mapCacheClear", "mapCacheDelete", "mapCacheGet", "mapCacheHas", "mapCacheSet", "MapCache", "entries", "index", "length", "entry", "require_stackSet", "__commonJSMin", "exports", "module", "ListCache", "Map", "MapCache", "LARGE_ARRAY_SIZE", "stackSet", "key", "value", "data", "pairs", "require_Stack", "__commonJSMin", "exports", "module", "ListCache", "stackClear", "stackDelete", "stackGet", "stackHas", "stackSet", "Stack", "entries", "data", "require_setCacheAdd", "__commonJSMin", "exports", "module", "HASH_UNDEFINED", "setCacheAdd", "value", "require_setCacheHas", "__commonJSMin", "exports", "module", "setCacheHas", "value", "require_SetCache", "__commonJSMin", "exports", "module", "MapCache", "setCacheAdd", "setCacheHas", "SetCache", "values", "index", "length", "require_arraySome", "__commonJSMin", "exports", "module", "arraySome", "array", "predicate", "index", "length", "require_cacheHas", "__commonJSMin", "exports", "module", "cacheHas", "cache", "key", "require_equalArrays", "__commonJSMin", "exports", "module", "SetCache", "arraySome", "cacheHas", "COMPARE_PARTIAL_FLAG", "COMPARE_UNORDERED_FLAG", "equalArrays", "array", "other", "bitmask", "customizer", "equalFunc", "stack", "isPartial", "arrLength", "othLength", "arrStacked", "othStacked", "index", "result", "seen", "arrValue", "othValue", "compared", "othIndex", "require_Uint8Array", "__commonJSMin", "exports", "module", "root", "Uint8Array", "require_mapToArray", "__commonJSMin", "exports", "module", "mapToArray", "map", "index", "result", "value", "key", "require_setToArray", "__commonJSMin", "exports", "module", "setToArray", "set", "index", "result", "value", "require_equalByTag", "__commonJSMin", "exports", "module", "Symbol", "Uint8Array", "eq", "equalArrays", "mapToArray", "setToArray", "COMPARE_PARTIAL_FLAG", "COMPARE_UNORDERED_FLAG", "boolTag", "dateTag", "errorTag", "mapTag", "numberTag", "regexpTag", "setTag", "stringTag", "symbolTag", "arrayBufferTag", "dataViewTag", "symbolProto", "symbolValueOf", "equalByTag", "object", "other", "tag", "bitmask", "customizer", "equalFunc", "stack", "convert", "isPartial", "stacked", "result", "require_arrayPush", "__commonJSMin", "exports", "module", "arrayPush", "array", "values", "index", "length", "offset", "require_baseGetAllKeys", "__commonJSMin", "exports", "module", "arrayPush", "isArray", "baseGetAllKeys", "object", "keysFunc", "symbolsFunc", "result", "require_arrayFilter", "__commonJSMin", "exports", "module", "arrayFilter", "array", "predicate", "index", "length", "resIndex", "result", "value", "require_stubArray", "__commonJSMin", "exports", "module", "stubArray", "require_getSymbols", "__commonJSMin", "exports", "module", "arrayFilter", "stubArray", "objectProto", "propertyIsEnumerable", "nativeGetSymbols", "getSymbols", "object", "symbol", "require_baseTimes", "__commonJSMin", "exports", "module", "baseTimes", "n", "iteratee", "index", "result", "require_isIndex", "__commonJSMin", "exports", "module", "MAX_SAFE_INTEGER", "reIsUint", "isIndex", "value", "length", "type", "require_arrayLikeKeys", "__commonJSMin", "exports", "module", "baseTimes", "isArguments", "isArray", "isBuffer", "isIndex", "isTypedArray", "objectProto", "hasOwnProperty", "arrayLikeKeys", "value", "inherited", "isArr", "isArg", "isBuff", "isType", "skipIndexes", "result", "length", "key", "require_keys", "__commonJSMin", "exports", "module", "arrayLikeKeys", "baseKeys", "isArrayLike", "keys", "object", "require_getAllKeys", "__commonJSMin", "exports", "module", "baseGetAllKeys", "getSymbols", "keys", "getAllKeys", "object", "require_equalObjects", "__commonJSMin", "exports", "module", "getAllKeys", "COMPARE_PARTIAL_FLAG", "objectProto", "hasOwnProperty", "equalObjects", "object", "other", "bitmask", "customizer", "equalFunc", "stack", "isPartial", "objProps", "objLength", "othProps", "othLength", "index", "key", "objStacked", "othStacked", "result", "skipCtor", "objValue", "othValue", "compared", "objCtor", "othCtor", "require_baseIsEqualDeep", "__commonJSMin", "exports", "module", "Stack", "equalArrays", "equalByTag", "equalObjects", "getTag", "isArray", "isBuffer", "isTypedArray", "COMPARE_PARTIAL_FLAG", "argsTag", "arrayTag", "objectTag", "objectProto", "hasOwnProperty", "baseIsEqualDeep", "object", "other", "bitmask", "customizer", "equalFunc", "stack", "objIsArr", "othIsArr", "objTag", "othTag", "objIsObj", "othIsObj", "isSameTag", "objIsWrapped", "othIsWrapped", "objUnwrapped", "othUnwrapped", "require_baseIsEqual", "__commonJSMin", "exports", "module", "baseIsEqualDeep", "isObjectLike", "baseIsEqual", "value", "other", "bitmask", "customizer", "stack", "require_baseIsMatch", "__commonJSMin", "exports", "module", "Stack", "baseIsEqual", "COMPARE_PARTIAL_FLAG", "COMPARE_UNORDERED_FLAG", "baseIsMatch", "object", "source", "matchData", "customizer", "index", "length", "noCustomizer", "data", "key", "objValue", "srcValue", "stack", "result", "require_isStrictComparable", "__commonJSMin", "exports", "module", "isObject", "isStrictComparable", "value", "require_getMatchData", "__commonJSMin", "exports", "module", "isStrictComparable", "keys", "getMatchData", "object", "result", "length", "key", "value", "require_matchesStrictComparable", "__commonJSMin", "exports", "module", "matchesStrictComparable", "key", "srcValue", "object", "require_baseMatches", "__commonJSMin", "exports", "module", "baseIsMatch", "getMatchData", "matchesStrictComparable", "baseMatches", "source", "matchData", "object", "require_isSymbol", "__commonJSMin", "exports", "module", "baseGetTag", "isObjectLike", "symbolTag", "isSymbol", "value", "require_isKey", "__commonJSMin", "exports", "module", "isArray", "isSymbol", "reIsDeepProp", "reIsPlainProp", "isKey", "value", "object", "type", "require_memoize", "__commonJSMin", "exports", "module", "MapCache", "FUNC_ERROR_TEXT", "memoize", "func", "resolver", "memoized", "args", "key", "cache", "result", "require_memoizeCapped", "__commonJSMin", "exports", "module", "memoize", "MAX_MEMOIZE_SIZE", "memoizeCapped", "func", "result", "key", "cache", "require_stringToPath", "__commonJSMin", "exports", "module", "memoizeCapped", "rePropName", "reEscapeChar", "stringToPath", "string", "result", "match", "number", "quote", "subString", "require_baseToString", "__commonJSMin", "exports", "module", "Symbol", "arrayMap", "isArray", "isSymbol", "INFINITY", "symbolProto", "symbolToString", "baseToString", "value", "result", "require_toString", "__commonJSMin", "exports", "module", "baseToString", "toString", "value", "require_castPath", "__commonJSMin", "exports", "module", "isArray", "isKey", "stringToPath", "toString", "castPath", "value", "object", "require_toKey", "__commonJSMin", "exports", "module", "isSymbol", "INFINITY", "toKey", "value", "result", "require_baseGet", "__commonJSMin", "exports", "module", "castPath", "toKey", "baseGet", "object", "path", "index", "length", "require_get", "__commonJSMin", "exports", "module", "baseGet", "get", "object", "path", "defaultValue", "result", "require_baseHasIn", "__commonJSMin", "exports", "module", "baseHasIn", "object", "key", "require_hasPath", "__commonJSMin", "exports", "module", "castPath", "isArguments", "isArray", "isIndex", "isLength", "toKey", "hasPath", "object", "path", "hasFunc", "index", "length", "result", "key", "require_hasIn", "__commonJSMin", "exports", "module", "baseHasIn", "hasPath", "hasIn", "object", "path", "require_baseMatchesProperty", "__commonJSMin", "exports", "module", "baseIsEqual", "get", "hasIn", "isKey", "isStrictComparable", "matchesStrictComparable", "toKey", "COMPARE_PARTIAL_FLAG", "COMPARE_UNORDERED_FLAG", "baseMatchesProperty", "path", "srcValue", "object", "objValue", "require_identity", "__commonJSMin", "exports", "module", "identity", "value", "require_baseProperty", "__commonJSMin", "exports", "module", "baseProperty", "key", "object", "require_basePropertyDeep", "__commonJSMin", "exports", "module", "baseGet", "basePropertyDeep", "path", "object", "require_property", "__commonJSMin", "exports", "module", "baseProperty", "basePropertyDeep", "isKey", "toKey", "property", "path", "require_baseIteratee", "__commonJSMin", "exports", "module", "baseMatches", "baseMatchesProperty", "identity", "isArray", "property", "baseIteratee", "value", "require_createBaseFor", "__commonJSMin", "exports", "module", "createBaseFor", "fromRight", "object", "iteratee", "keysFunc", "index", "iterable", "props", "length", "key", "require_baseFor", "__commonJSMin", "exports", "module", "createBaseFor", "baseFor", "require_baseForOwn", "__commonJSMin", "exports", "module", "baseFor", "keys", "baseForOwn", "object", "iteratee", "require_createBaseEach", "__commonJSMin", "exports", "module", "isArrayLike", "createBaseEach", "eachFunc", "fromRight", "collection", "iteratee", "length", "index", "iterable", "require_baseEach", "__commonJSMin", "exports", "module", "baseForOwn", "createBaseEach", "baseEach", "require_baseMap", "__commonJSMin", "exports", "module", "baseEach", "isArrayLike", "baseMap", "collection", "iteratee", "index", "result", "value", "key", "require_map", "__commonJSMin", "exports", "module", "arrayMap", "baseIteratee", "baseMap", "isArray", "map", "collection", "iteratee", "func", "require_arrayEach", "__commonJSMin", "exports", "module", "arrayEach", "array", "iteratee", "index", "length", "require_castFunction", "__commonJSMin", "exports", "module", "identity", "castFunction", "value", "require_forEach", "__commonJSMin", "exports", "module", "arrayEach", "baseEach", "castFunction", "isArray", "forEach", "collection", "iteratee", "func", "require_baseValues", "__commonJSMin", "exports", "module", "arrayMap", "baseValues", "object", "props", "key", "require_values", "__commonJSMin", "exports", "module", "baseValues", "keys", "values", "object", "require_baseHas", "__commonJSMin", "exports", "module", "objectProto", "hasOwnProperty", "baseHas", "object", "key", "require_has", "__commonJSMin", "exports", "module", "baseHas", "hasPath", "has", "object", "path", "require_defineProperty", "__commonJSMin", "exports", "module", "getNative", "defineProperty", "func", "require_baseAssignValue", "__commonJSMin", "exports", "module", "defineProperty", "baseAssignValue", "object", "key", "value", "require_assignValue", "__commonJSMin", "exports", "module", "baseAssignValue", "eq", "objectProto", "hasOwnProperty", "assignValue", "object", "key", "value", "objValue", "require_copyObject", "__commonJSMin", "exports", "module", "assignValue", "baseAssignValue", "copyObject", "source", "props", "object", "customizer", "isNew", "index", "length", "key", "newValue", "require_baseAssign", "__commonJSMin", "exports", "module", "copyObject", "keys", "baseAssign", "object", "source", "require_nativeKeysIn", "__commonJSMin", "exports", "module", "nativeKeysIn", "object", "result", "key", "require_baseKeysIn", "__commonJSMin", "exports", "module", "isObject", "isPrototype", "nativeKeysIn", "objectProto", "hasOwnProperty", "baseKeysIn", "object", "isProto", "result", "key", "require_keysIn", "__commonJSMin", "exports", "module", "arrayLikeKeys", "baseKeysIn", "isArrayLike", "keysIn", "object", "require_baseAssignIn", "__commonJSMin", "exports", "module", "copyObject", "keysIn", "baseAssignIn", "object", "source", "require_cloneBuffer", "__commonJSMin", "exports", "module", "root", "freeExports", "freeModule", "moduleExports", "Buffer", "allocUnsafe", "cloneBuffer", "buffer", "isDeep", "length", "result", "require_copyArray", "__commonJSMin", "exports", "module", "copyArray", "source", "array", "index", "length", "require_copySymbols", "__commonJSMin", "exports", "module", "copyObject", "getSymbols", "copySymbols", "source", "object", "require_getPrototype", "__commonJSMin", "exports", "module", "overArg", "getPrototype", "require_getSymbolsIn", "__commonJSMin", "exports", "module", "arrayPush", "getPrototype", "getSymbols", "stubArray", "nativeGetSymbols", "getSymbolsIn", "object", "result", "require_copySymbolsIn", "__commonJSMin", "exports", "module", "copyObject", "getSymbolsIn", "copySymbolsIn", "source", "object", "require_getAllKeysIn", "__commonJSMin", "exports", "module", "baseGetAllKeys", "getSymbolsIn", "keysIn", "getAllKeysIn", "object", "require_initCloneArray", "__commonJSMin", "exports", "module", "objectProto", "hasOwnProperty", "initCloneArray", "array", "length", "result", "require_cloneArrayBuffer", "__commonJSMin", "exports", "module", "Uint8Array", "cloneArrayBuffer", "arrayBuffer", "result", "require_cloneDataView", "__commonJSMin", "exports", "module", "cloneArrayBuffer", "cloneDataView", "dataView", "isDeep", "buffer", "require_cloneRegExp", "__commonJSMin", "exports", "module", "reFlags", "cloneRegExp", "regexp", "result", "require_cloneSymbol", "__commonJSMin", "exports", "module", "Symbol", "symbolProto", "symbolValueOf", "cloneSymbol", "symbol", "require_cloneTypedArray", "__commonJSMin", "exports", "module", "cloneArrayBuffer", "cloneTypedArray", "typedArray", "isDeep", "buffer", "require_initCloneByTag", "__commonJSMin", "exports", "module", "cloneArrayBuffer", "cloneDataView", "cloneRegExp", "cloneSymbol", "cloneTypedArray", "boolTag", "dateTag", "mapTag", "numberTag", "regexpTag", "setTag", "stringTag", "symbolTag", "arrayBufferTag", "dataViewTag", "float32Tag", "float64Tag", "int8Tag", "int16Tag", "int32Tag", "uint8Tag", "uint8ClampedTag", "uint16Tag", "uint32Tag", "initCloneByTag", "object", "tag", "isDeep", "Ctor", "require_baseCreate", "__commonJSMin", "exports", "module", "isObject", "objectCreate", "baseCreate", "object", "proto", "result", "require_initCloneObject", "__commonJSMin", "exports", "module", "baseCreate", "getPrototype", "isPrototype", "initCloneObject", "object", "require_baseIsMap", "__commonJSMin", "exports", "module", "getTag", "isObjectLike", "mapTag", "baseIsMap", "value", "require_isMap", "__commonJSMin", "exports", "module", "baseIsMap", "baseUnary", "nodeUtil", "nodeIsMap", "isMap", "require_baseIsSet", "__commonJSMin", "exports", "module", "getTag", "isObjectLike", "setTag", "baseIsSet", "value", "require_isSet", "__commonJSMin", "exports", "module", "baseIsSet", "baseUnary", "nodeUtil", "nodeIsSet", "isSet", "require_baseClone", "__commonJSMin", "exports", "module", "Stack", "arrayEach", "assignValue", "baseAssign", "baseAssignIn", "cloneBuffer", "copyArray", "copySymbols", "copySymbolsIn", "getAllKeys", "getAllKeysIn", "getTag", "initCloneArray", "initCloneByTag", "initCloneObject", "isArray", "isBuffer", "isMap", "isObject", "isSet", "keys", "keysIn", "CLONE_DEEP_FLAG", "CLONE_FLAT_FLAG", "CLONE_SYMBOLS_FLAG", "argsTag", "arrayTag", "boolTag", "dateTag", "errorTag", "funcTag", "genTag", "mapTag", "numberTag", "objectTag", "regexpTag", "setTag", "stringTag", "symbolTag", "weakMapTag", "arrayBufferTag", "dataViewTag", "float32Tag", "float64Tag", "int8Tag", "int16Tag", "int32Tag", "uint8Tag", "uint8ClampedTag", "uint16Tag", "uint32Tag", "cloneableTags", "baseClone", "value", "bitmask", "customizer", "key", "object", "stack", "result", "isDeep", "isFlat", "isFull", "isArr", "tag", "isFunc", "stacked", "subValue", "keysFunc", "props", "require_clone", "__commonJSMin", "exports", "module", "baseClone", "CLONE_SYMBOLS_FLAG", "clone", "value", "PRINT_ERROR", "msg", "exports", "PRINT_WARNING", "timer", "func", "start", "val", "end", "total", "exports", "print_1", "exports", "timer_1", "to_fast_properties_1", "require_baseSlice", "__commonJSMin", "exports", "module", "baseSlice", "array", "start", "end", "index", "length", "result", "require_trimmedEndIndex", "__commonJSMin", "exports", "module", "reWhitespace", "trimmedEndIndex", "string", "index", "require_baseTrim", "__commonJSMin", "exports", "module", "trimmedEndIndex", "reTrimStart", "baseTrim", "string", "require_toNumber", "__commonJSMin", "exports", "module", "baseTrim", "isObject", "isSymbol", "NAN", "reIsBadHex", "reIsBinary", "reIsOctal", "freeParseInt", "toNumber", "value", "other", "isBinary", "require_toFinite", "__commonJSMin", "exports", "module", "toNumber", "INFINITY", "MAX_INTEGER", "toFinite", "value", "sign", "require_toInteger", "__commonJSMin", "exports", "module", "toFinite", "toInteger", "value", "result", "remainder", "require_drop", "__commonJSMin", "exports", "module", "baseSlice", "toInteger", "drop", "array", "n", "guard", "length", "require_isString", "__commonJSMin", "exports", "module", "baseGetTag", "isArray", "isObjectLike", "stringTag", "isString", "value", "require_baseIsRegExp", "__commonJSMin", "exports", "module", "baseGetTag", "isObjectLike", "regexpTag", "baseIsRegExp", "value", "require_isRegExp", "__commonJSMin", "exports", "module", "baseIsRegExp", "baseUnary", "nodeUtil", "nodeIsRegExp", "isRegExp", "require_baseSet", "__commonJSMin", "exports", "module", "assignValue", "castPath", "isIndex", "isObject", "toKey", "baseSet", "object", "path", "value", "customizer", "index", "length", "lastIndex", "nested", "key", "newValue", "objValue", "require_basePickBy", "__commonJSMin", "exports", "module", "baseGet", "baseSet", "castPath", "basePickBy", "object", "paths", "predicate", "index", "length", "result", "path", "value", "require_pickBy", "__commonJSMin", "exports", "module", "arrayMap", "baseIteratee", "basePickBy", "getAllKeysIn", "pickBy", "object", "predicate", "props", "prop", "value", "path", "require_apply", "__commonJSMin", "exports", "module", "apply", "func", "thisArg", "args", "require_overRest", "__commonJSMin", "exports", "module", "apply", "nativeMax", "overRest", "func", "start", "transform", "args", "index", "length", "array", "otherArgs", "require_constant", "__commonJSMin", "exports", "module", "constant", "value", "require_baseSetToString", "__commonJSMin", "exports", "module", "constant", "defineProperty", "identity", "baseSetToString", "func", "string", "require_shortOut", "__commonJSMin", "exports", "module", "HOT_COUNT", "HOT_SPAN", "nativeNow", "shortOut", "func", "count", "lastCalled", "stamp", "remaining", "require_setToString", "__commonJSMin", "exports", "module", "baseSetToString", "shortOut", "setToString", "require_baseRest", "__commonJSMin", "exports", "module", "identity", "overRest", "setToString", "baseRest", "func", "start", "require_isIterateeCall", "__commonJSMin", "exports", "module", "eq", "isArrayLike", "isIndex", "isObject", "isIterateeCall", "value", "index", "object", "type", "require_createAssigner", "__commonJSMin", "exports", "module", "baseRest", "isIterateeCall", "createAssigner", "assigner", "object", "sources", "index", "length", "customizer", "guard", "source", "require_assign", "__commonJSMin", "exports", "module", "assignValue", "copyObject", "createAssigner", "isArrayLike", "isPrototype", "keys", "objectProto", "hasOwnProperty", "assign", "object", "source", "key", "map_1", "__importDefault", "forEach_1", "isString_1", "isRegExp_1", "pickBy_1", "assign_1", "tokenLabel", "tokType", "hasTokenLabel", "obj", "AbstractProduction", "_definition", "value", "visitor", "prod", "exports", "NonTerminal", "_super", "__extends", "options", "_this", "v", "definition", "Rule", "Alternative", "Option", "RepetitionMandatory", "RepetitionMandatoryWithSeparator", "Repetition", "RepetitionWithSeparator", "Alternation", "Terminal", "serializeGrammar", "topRules", "serializeProduction", "node", "convertDefinition", "serializedNonTerminal", "serializedTerminal", "pattern", "model_1", "GAstVisitor", "node", "nodeAny", "exports", "require_baseSome", "__commonJSMin", "exports", "module", "baseEach", "baseSome", "collection", "predicate", "result", "value", "index", "require_some", "__commonJSMin", "exports", "module", "arraySome", "baseIteratee", "baseSome", "isArray", "isIterateeCall", "some", "collection", "predicate", "guard", "func", "require_arrayEvery", "__commonJSMin", "exports", "module", "arrayEvery", "array", "predicate", "index", "length", "require_baseEvery", "__commonJSMin", "exports", "module", "baseEach", "baseEvery", "collection", "predicate", "result", "value", "index", "require_every", "__commonJSMin", "exports", "module", "arrayEvery", "baseEvery", "baseIteratee", "isArray", "isIterateeCall", "every", "collection", "predicate", "guard", "func", "require_baseFindIndex", "__commonJSMin", "exports", "module", "baseFindIndex", "array", "predicate", "fromIndex", "fromRight", "length", "index", "require_baseIsNaN", "__commonJSMin", "exports", "module", "baseIsNaN", "value", "require_strictIndexOf", "__commonJSMin", "exports", "module", "strictIndexOf", "array", "value", "fromIndex", "index", "length", "require_baseIndexOf", "__commonJSMin", "exports", "module", "baseFindIndex", "baseIsNaN", "strictIndexOf", "baseIndexOf", "array", "value", "fromIndex", "require_includes", "__commonJSMin", "exports", "module", "baseIndexOf", "isArrayLike", "isString", "toInteger", "values", "nativeMax", "includes", "collection", "value", "fromIndex", "guard", "length", "some_1", "__importDefault", "every_1", "includes_1", "model_1", "isSequenceProd", "prod", "exports", "isOptionalProd", "alreadyVisited", "isDirectlyOptional", "subProd", "isBranchingProd", "getProductionDslName", "model_1", "exports", "visitor_1", "helpers_1", "drop_1", "__importDefault", "forEach_1", "gast_1", "RestWalker", "prod", "prevRest", "_this", "subProd", "index", "currRest", "terminal", "refProd", "flatProd", "fullOrRest", "optionProd", "atLeastOneProd", "fullAtLeastOneRest", "atLeastOneSepProd", "fullAtLeastOneSepRest", "restForRepetitionWithSeparator", "manyProd", "fullManyRest", "manySepProd", "fullManySepRest", "orProd", "alt", "prodWrapper", "exports", "repSepProd", "repSepRest", "fullRepSepRest", "require_isFlattenable", "__commonJSMin", "exports", "module", "Symbol", "isArguments", "isArray", "spreadableSymbol", "isFlattenable", "value", "require_baseFlatten", "__commonJSMin", "exports", "module", "arrayPush", "isFlattenable", "baseFlatten", "array", "depth", "predicate", "isStrict", "result", "index", "length", "value", "require_flatten", "__commonJSMin", "exports", "module", "baseFlatten", "flatten", "array", "length", "require_arrayIncludes", "__commonJSMin", "exports", "module", "baseIndexOf", "arrayIncludes", "array", "value", "length", "require_arrayIncludesWith", "__commonJSMin", "exports", "module", "arrayIncludesWith", "array", "value", "comparator", "index", "length", "require_noop", "__commonJSMin", "exports", "module", "noop", "require_createSet", "__commonJSMin", "exports", "module", "Set", "noop", "setToArray", "INFINITY", "createSet", "values", "require_baseUniq", "__commonJSMin", "exports", "module", "SetCache", "arrayIncludes", "arrayIncludesWith", "cacheHas", "createSet", "setToArray", "LARGE_ARRAY_SIZE", "baseUniq", "array", "iteratee", "comparator", "index", "includes", "length", "isCommon", "result", "seen", "set", "outer", "value", "computed", "seenIndex", "require_uniq", "__commonJSMin", "exports", "module", "baseUniq", "uniq", "array", "flatten_1", "__importDefault", "uniq_1", "map_1", "gast_1", "gast_2", "first", "prod", "firstForTerminal", "firstForSequence", "firstForBranching", "exports", "firstSet", "seq", "nextSubProdIdx", "hasInnerProdsRemaining", "currSubProd", "isLastInnerProdOptional", "allAlternativesFirsts", "innerProd", "terminal", "exports", "rest_1", "first_1", "forEach_1", "__importDefault", "assign_1", "constants_1", "gast_1", "ResyncFollowsWalker", "_super", "__extends", "topProd", "_this", "terminal", "currRest", "prevRest", "refProd", "followName", "buildBetweenProdsFollowPrefix", "fullRest", "restProd", "t_in_topProd_follows", "exports", "computeAllProdsFollows", "topProductions", "reSyncFollows", "currRefsFollow", "inner", "occurenceInParent", "buildInProdFollowPrefix", "terminalName", "require_isUndefined", "__commonJSMin", "exports", "module", "isUndefined", "value", "require_regexp_to_ast", "__commonJSMin", "exports", "module", "root", "factory", "RegExpParser", "newState", "input", "value", "flags", "addFlag", "alts", "begin", "terms", "type", "ASSERT_EXISTS", "disjunction", "ASSERT_NEVER_REACH_HERE", "isBacktracking", "range", "atLeast", "atMost", "atom", "cc", "set", "complement", "digitsCharCodes", "whitespaceCodes", "wordCharCodes", "escapeCode", "letter", "letterCode", "escapedChar", "nextChar", "from", "isFromSingleChar", "to", "isToSingleChar", "insertToSet", "capturing", "groupAst", "number", "decimalPatternNoZero", "decimalPattern", "howMuch", "prevState", "howMany", "hexString", "i", "hexChar", "hexDigitPattern", "charCode", "char", "item", "subItem", "flagObj", "flagKey", "obj", "BaseRegExpVisitor", "node", "key", "child", "subChild", "require_head", "__commonJSMin", "exports", "module", "head", "array", "require_first", "__commonJSMin", "exports", "module", "require_compact", "__commonJSMin", "exports", "module", "compact", "array", "index", "length", "resIndex", "result", "value", "require_baseFilter", "__commonJSMin", "exports", "module", "baseEach", "baseFilter", "collection", "predicate", "result", "value", "index", "require_negate", "__commonJSMin", "exports", "module", "FUNC_ERROR_TEXT", "negate", "predicate", "args", "require_reject", "__commonJSMin", "exports", "module", "arrayFilter", "baseFilter", "baseIteratee", "isArray", "negate", "reject", "collection", "predicate", "func", "require_baseDifference", "__commonJSMin", "exports", "module", "SetCache", "arrayIncludes", "arrayIncludesWith", "arrayMap", "baseUnary", "cacheHas", "LARGE_ARRAY_SIZE", "baseDifference", "array", "values", "iteratee", "comparator", "index", "includes", "isCommon", "length", "result", "valuesLength", "outer", "value", "computed", "valuesIndex", "require_isArrayLikeObject", "__commonJSMin", "exports", "module", "isArrayLike", "isObjectLike", "isArrayLikeObject", "value", "require_difference", "__commonJSMin", "exports", "module", "baseDifference", "baseFlatten", "baseRest", "isArrayLikeObject", "difference", "array", "values", "require_indexOf", "__commonJSMin", "exports", "module", "baseIndexOf", "toInteger", "nativeMax", "indexOf", "array", "value", "fromIndex", "length", "index", "require_createFind", "__commonJSMin", "exports", "module", "baseIteratee", "isArrayLike", "keys", "createFind", "findIndexFunc", "collection", "predicate", "fromIndex", "iterable", "iteratee", "key", "index", "require_findIndex", "__commonJSMin", "exports", "module", "baseFindIndex", "baseIteratee", "toInteger", "nativeMax", "findIndex", "array", "predicate", "fromIndex", "length", "index", "require_find", "__commonJSMin", "exports", "module", "createFind", "findIndex", "find", "require_filter", "__commonJSMin", "exports", "module", "arrayFilter", "baseFilter", "baseIteratee", "isArray", "filter", "collection", "predicate", "func", "require_defaults", "__commonJSMin", "exports", "module", "baseRest", "eq", "isIterateeCall", "keysIn", "objectProto", "hasOwnProperty", "defaults", "object", "sources", "index", "length", "guard", "source", "props", "propsIndex", "propsLength", "key", "value", "require_arrayReduce", "__commonJSMin", "exports", "module", "arrayReduce", "array", "iteratee", "accumulator", "initAccum", "index", "length", "require_baseReduce", "__commonJSMin", "exports", "module", "baseReduce", "collection", "iteratee", "accumulator", "initAccum", "eachFunc", "value", "index", "require_reduce", "__commonJSMin", "exports", "module", "arrayReduce", "baseEach", "baseIteratee", "baseReduce", "isArray", "reduce", "collection", "iteratee", "accumulator", "func", "initAccum", "regexp_to_ast_1", "regExpAstCache", "regExpParser", "getRegExpAst", "regExp", "regExpStr", "regExpAst", "exports", "clearRegExpParserCache", "regexp_to_ast_1", "isArray_1", "__importDefault", "every_1", "forEach_1", "find_1", "values_1", "includes_1", "utils_1", "reg_exp_parser_1", "lexer_1", "complementErrorMessage", "exports", "getOptimizedStartCodesIndices", "regExp", "ensureOptimizations", "ast", "firstChars", "firstCharOptimizedIndices", "e", "msgSuffix", "result", "ignoreCase", "i", "terms", "term", "atom", "addOptimizedIdxToResult", "code", "range", "rangeCode", "minUnOptVal", "maxUnOptVal", "minOptIdx", "maxOptIdx", "currOptIdx", "isOptionalQuantifier", "isWholeOptional", "optimizedCharIdx", "handleIgnoreCase", "char", "upperChar", "lowerChar", "findCode", "setNode", "targetCharCodes", "codeOrRange", "range_1", "targetCode", "quantifier", "CharCodeFinder", "_super", "__extends", "_this", "node", "canMatchCharCode", "charCodes", "pattern", "charCodeFinder", "regexp_to_ast_1", "lexer_public_1", "first_1", "__importDefault", "isEmpty_1", "compact_1", "isArray_1", "values_1", "flatten_1", "reject_1", "difference_1", "indexOf_1", "map_1", "forEach_1", "isString_1", "isFunction_1", "isUndefined_1", "find_1", "has_1", "keys_1", "isRegExp_1", "filter_1", "defaults_1", "reduce_1", "includes_1", "utils_1", "reg_exp_1", "reg_exp_parser_1", "PATTERN", "exports", "disableSticky", "enableSticky", "analyzeTokenTypes", "tokenTypes", "options", "msg", "action", "tracer", "initCharCodeToOptimizedIndexMap", "onlyRelevantTypes", "currType", "hasCustom", "allTransformedPatterns", "currPattern", "regExpSource", "addStickyFlag", "addStartOfInput", "escapedRegExpString", "wrappedRegExp", "patternIdxToType", "patternIdxToGroup", "patternIdxToLongerAltIdxArr", "patternIdxToPushMode", "patternIdxToPopMode", "clazz", "groupName", "longerAltType", "longerAltIdxArr", "type", "patternIdxToCanLineTerminator", "lineTerminatorCharCodes", "getCharCodes", "tokType", "checkLineBreaksIssues", "patternIdxToIsCustom", "patternIdxToShort", "emptyGroups", "patternIdxToConfig", "isCustomPattern", "isShortPattern", "acc", "x", "idx", "canBeOptimized", "charCodeToPatternIdxToConfig", "result", "currTokType", "charCode", "optimizedIdx", "charCodeToOptimizedIndex", "addToMapOfArrays", "lastOptimizedIdx_1", "charOrInt", "currOptimizedIdx", "optimizedCodes", "code", "validatePatterns", "validModesNames", "errors", "missingResult", "findMissingPatterns", "invalidResult", "findInvalidPatterns", "validTokenTypes", "validateRegExpPattern", "findInvalidGroupType", "findModesThatDoNotExist", "findUnreachablePatterns", "withRegExpPatterns", "findEndOfInputAnchor", "findStartOfInputAnchor", "findUnsupportedFlags", "findDuplicatePatterns", "findEmptyMatchRegExps", "tokenTypesWithMissingPattern", "valid", "tokenTypesWithInvalidPattern", "pattern", "end_of_input", "EndAnchorFinder", "_super", "__extends", "_this", "node", "invalidRegex", "regexpAst", "endAnchorVisitor", "e", "matchesEmptyString", "start_of_input", "StartAnchorFinder", "startAnchorVisitor", "invalidFlags", "found", "identicalPatterns", "outerType", "innerType", "duplicatePatterns", "currIdenticalSet", "setOfIdentical", "tokenTypeNames", "dupPatternSrc", "invalidTypes", "group", "validModes", "invalidModes", "canBeTested", "noMetaChar", "testIdx", "_a", "str", "tokenType", "testTokenType", "regExpArray", "regExp", "metaChars", "char", "flags", "performRuntimeChecks", "lexerDefinition", "trackLines", "lineTerminatorCharacters", "currModeValue", "currModeName", "currIdx", "longerAlt", "currLongerAlt", "performWarningRuntimeChecks", "warnings", "hasAnyLineBreak", "allTokenTypes", "concreteTokenTypes", "terminatorCharCodes", "currIssue", "message", "buildLineBreakIssueMessage", "warningDescriptor", "cloneEmptyGroups", "clonedResult", "groupKeys", "currKey", "currGroupValue", "text", "len", "i", "c", "details", "charsOrCodes", "charCodes", "numOrString", "map", "key", "value", "charCodeToOptimizedIdxMap", "require_last", "__commonJSMin", "exports", "module", "last", "array", "length", "isEmpty_1", "__importDefault", "compact_1", "isArray_1", "flatten_1", "difference_1", "map_1", "forEach_1", "has_1", "includes_1", "clone_1", "tokenStructuredMatcher", "tokInstance", "tokConstructor", "instanceType", "exports", "tokenStructuredMatcherNoCategories", "token", "tokType", "augmentTokenTypes", "tokenTypes", "tokenTypesAndParents", "expandCategories", "assignTokenDefaultProps", "assignCategoriesMapProp", "assignCategoriesTokensProp", "result", "categories", "searching", "currTokType", "newCategories", "hasShortKeyProperty", "hasCategoriesProperty", "hasExtendingTokensTypesProperty", "hasExtendingTokensTypesMapProperty", "val", "key", "singleAssignCategoriesToksMap", "path", "nextNode", "pathNode", "nextCategory", "newPath", "isTokenType", "exports", "token", "fullText", "startOffset", "length", "line", "column", "lexer_1", "noop_1", "__importDefault", "isEmpty_1", "isArray_1", "last_1", "reject_1", "map_1", "forEach_1", "keys_1", "isUndefined_1", "identity_1", "assign_1", "reduce_1", "clone_1", "utils_1", "tokens_1", "lexer_errors_public_1", "reg_exp_parser_1", "LexerDefinitionErrorType", "exports", "DEFAULT_LEXER_CONFIG", "Lexer", "lexerDefinition", "config", "_this", "phaseDesc", "phaseImpl", "indent", "_a", "time", "value", "traceMethod", "traceInitVal", "actualDefinition", "hasOnlySingleMode", "currModeValue", "currModeName", "currTokType", "allModeNames", "currModDef", "currModName", "currAnalyzeResult_1", "allErrMessages", "error", "allErrMessagesString", "warningDescriptor", "unOptimizedModes", "cannotBeOptimized", "canBeOptimized", "modeName", "text", "initialMode", "j", "k", "matchAltImage", "longerAlt", "matchedImage", "payload", "altPayload", "imageLength", "group", "tokType", "newToken", "errLength", "droppedChar", "msg", "match", "orgText", "orgLength", "offset", "matchedTokensIndex", "guessedNumberOfTokens", "matchedTokens", "errors", "line", "column", "groups", "trackLines", "lineTerminatorPattern", "currModePatternsLength", "patternIdxToConfig", "currCharCodeToPatternIdxToConfig", "modeStack", "emptyArray", "getPossiblePatterns", "getPossiblePatternsSlow", "getPossiblePatternsOptimized", "charCode", "optimizedCharIdx", "possiblePatterns", "pop_mode", "popToken", "msg_1", "newMode", "modeCanBeOptimized", "push_mode", "currConfig", "recoveryEnabled", "nextCharCode", "chosenPatternIdxToConfig", "chosenPatternsLength", "currPattern", "singleCharCode", "longerAltLength", "longerAltConfig", "longerAltPattern", "numOfLTsInMatch", "foundTerminator", "lastLTEndOffset", "errorStartOffset", "errorLine", "errorColumn", "foundResyncPoint", "currConfig_1", "pushMode", "length", "regExp", "newLastIndex", "lastLTIdx", "lastCharIsLT", "fixForEndingInLT", "oldColumn", "image", "startOffset", "tokenTypeIdx", "tokenType", "startLine", "startColumn", "tokenVector", "index", "tokenToAdd", "token", "pattern", "found", "regExpArray", "isString_1", "__importDefault", "has_1", "isUndefined_1", "lexer_public_1", "tokens_1", "tokenLabel", "tokType", "hasTokenLabel", "exports", "tokenName", "obj", "PARENT", "CATEGORIES", "LABEL", "GROUP", "PUSH_MODE", "POP_MODE", "LONGER_ALT", "LINE_BREAKS", "START_CHARS_HINT", "createToken", "config", "createTokenInternal", "pattern", "tokenType", "createTokenInstance", "image", "startOffset", "endOffset", "startLine", "endLine", "startColumn", "endColumn", "tokenMatcher", "token", "tokens_public_1", "first_1", "__importDefault", "map_1", "reduce_1", "gast_1", "gast_2", "exports", "_a", "expected", "actual", "previous", "ruleName", "hasLabel", "expectedMsg", "msg", "firstRedundant", "expectedPathsPerAlt", "customUserDescription", "errPrefix", "actualText", "errSuffix", "allLookAheadPaths", "result", "currAltPaths", "nextValidTokenSequences", "currPath", "currTokenType", "nextValidSequenceItems", "itemMsg", "idx", "calculatedDescription", "expectedIterationPaths", "topLevelRule", "undefinedRule", "duplicateProds", "getExtraProductionArgument", "prod", "topLevelName", "duplicateProd", "index", "dslName", "extraArgument", "hasExplicitIndex", "rule", "errMsg", "options", "pathMsg", "currTok", "occurrence", "currtok", "currMessage", "pathNames", "currRule", "leftRecursivePath", "parser_1", "forEach_1", "__importDefault", "values_1", "gast_1", "resolveGrammar", "topLevels", "errMsgProvider", "refResolver", "GastRefResolverVisitor", "exports", "_super", "__extends", "nameToTopRule", "_this", "prod", "node", "ref", "msg", "require_arrayAggregator", "__commonJSMin", "exports", "module", "arrayAggregator", "array", "setter", "iteratee", "accumulator", "index", "length", "value", "require_baseAggregator", "__commonJSMin", "exports", "module", "baseEach", "baseAggregator", "collection", "setter", "iteratee", "accumulator", "value", "key", "require_createAggregator", "__commonJSMin", "exports", "module", "arrayAggregator", "baseAggregator", "baseIteratee", "isArray", "createAggregator", "setter", "initializer", "collection", "iteratee", "func", "accumulator", "require_groupBy", "__commonJSMin", "exports", "module", "baseAssignValue", "createAggregator", "objectProto", "hasOwnProperty", "groupBy", "result", "value", "key", "require_flatMap", "__commonJSMin", "exports", "module", "baseFlatten", "map", "flatMap", "collection", "iteratee", "require_dropRight", "__commonJSMin", "exports", "module", "baseSlice", "toInteger", "dropRight", "array", "n", "guard", "length", "rest_1", "first_1", "__importDefault", "isEmpty_1", "dropRight_1", "drop_1", "last_1", "forEach_1", "clone_1", "first_2", "gast_1", "AbstractNextPossibleTokensWalker", "_super", "__extends", "topProd", "path", "_this", "prod", "prevRest", "refProd", "currRest", "fullRest", "exports", "NextAfterTokenWalker", "terminal", "restProd", "AbstractNextTerminalAfterProductionWalker", "topRule", "occurrence", "NextTerminalAfterManyWalker", "manyProd", "firstAfterMany", "NextTerminalAfterManySepWalker", "manySepProd", "firstAfterManySep", "NextTerminalAfterAtLeastOneWalker", "atLeastOneProd", "firstAfterAtLeastOne", "NextTerminalAfterAtLeastOneSepWalker", "atleastOneSepProd", "firstAfterfirstAfterAtLeastOneSep", "possiblePathsFrom", "targetDef", "maxLength", "currPath", "result", "remainingPathWith", "nextDef", "getAlternativesForProd", "definition", "alternatives", "newDef", "currAlt", "nextPossibleTokensAfter", "initialDef", "tokenVector", "tokMatcher", "maxLookAhead", "EXIT_NON_TERMINAL", "EXIT_NON_TERMINAL_ARR", "EXIT_ALTERNATIVE", "foundCompletePath", "tokenVectorLength", "minimalAlternativesIndex", "possiblePaths", "currDef", "currIdx", "currRuleStack", "currOccurrenceStack", "nextPath", "nextIdx", "actualToken", "newRuleStack", "newOccurrenceStack", "nextPathWithout", "nextPathWith", "secondIteration", "separatorGast", "nthRepetition", "i", "currAltPath", "expandTopLevelRule", "newCurrOccurrenceStack", "isEmpty_1", "__importDefault", "flatten_1", "every_1", "map_1", "forEach_1", "has_1", "reduce_1", "interpreter_1", "rest_1", "tokens_1", "gast_1", "gast_2", "PROD_TYPE", "exports", "getProdType", "prod", "getLookaheadPaths", "options", "occurrence", "rule", "prodType", "maxLookahead", "type", "getLookaheadPathsForOr", "getLookaheadPathsForOptionalProd", "buildLookaheadFuncForOr", "ruleGrammar", "hasPredicates", "dynamicTokensEnabled", "laFuncBuilder", "lookAheadPaths", "tokenMatcher", "areTokenCategoriesNotUsed", "buildLookaheadFuncForOptionalProd", "k", "lookaheadBuilder", "buildAlternativesLookAheadFunc", "alts", "numOfAlts", "areAllOneTokenLookahead", "currAlt", "currPath", "orAlts", "predicates", "t", "currNumOfPaths", "currPredicate", "nextPath", "j", "currPathLength", "i", "nextToken", "singleTokenAlts", "choiceToAlt_1", "result", "idx", "currTokType", "currExtendingType", "buildSingleAlternativeLookaheadFunction", "alt", "numOfPaths", "singleTokensTypes", "expectedTokenType", "expectedTokenUniqueKey_1", "choiceToAlt_2", "RestDefinitionFinderWalker", "_super", "__extends", "topProd", "targetOccurrence", "targetProdType", "_this", "node", "expectedProdType", "currRest", "prevRest", "optionProd", "atLeastOneProd", "atLeastOneSepProd", "manyProd", "manySepProd", "InsideDefinitionFinderVisitor", "targetRef", "expectedProdName", "initializeArrayOfArrays", "size", "pathToHashKeys", "path", "keys", "tokType", "longerKeys", "currShorterKey", "categoriesKeySuffix", "isUniquePrefixHash", "altKnownPathsKeys", "searchPathKeys", "currAltIdx", "otherAltKnownPathsKeys", "searchIdx", "searchKey", "lookAheadSequenceFromAlternatives", "altsDefs", "partialAlts", "finalResult", "altsHashes", "currAltPaths", "dict", "item", "currKey", "newData", "pathLength", "currDataset", "altIdx", "currAltPathsAndSuffixes", "currPathIdx", "currPathPrefix", "suffixDef", "prefixKeys", "isUnique", "currAltResult", "containsPath", "newPartialPathsAndSuffixes", "key", "orProd", "visitor", "insideDefVisitor", "insideDef", "afterDefWalker", "afterDef", "insideFlat", "afterFlat", "alternative", "searchPath", "compareOtherPath", "otherPath", "searchTok", "otherTok", "matchingTokens", "isStrictPrefixOfPath", "prefix", "other", "otherTokType", "singleAltPaths", "singlePath", "token", "first_1", "__importDefault", "isEmpty_1", "drop_1", "flatten_1", "filter_1", "reject_1", "difference_1", "map_1", "forEach_1", "groupBy_1", "reduce_1", "pickBy_1", "values_1", "includes_1", "flatMap_1", "clone_1", "parser_1", "gast_1", "lookahead_1", "interpreter_1", "gast_2", "gast_3", "dropRight_1", "compact_1", "tokens_1", "validateLookahead", "options", "lookaheadValidationErrorMessages", "errorMessage", "__assign", "exports", "validateGrammar", "topLevels", "tokenTypes", "errMsgProvider", "grammarName", "duplicateErrors", "currTopLevel", "validateDuplicateProductions", "termsNamespaceConflictErrors", "checkTerminalAndNoneTerminalsNameSpace", "tooManyAltsErrors", "curRule", "validateTooManyAlts", "duplicateRulesError", "validateRuleDoesNotAlreadyExist", "topLevelRule", "collectorVisitor", "OccurrenceValidationCollector", "allRuleProductions", "productionGroups", "identifyProductionForDuplicates", "duplicates", "currGroup", "errors", "currDuplicates", "firstProd", "msg", "dslName", "defError", "param", "getExtraProductionArgument", "prod", "_super", "__extends", "_this", "subrule", "option", "manySep", "atLeastOne", "atLeastOneSep", "many", "or", "terminal", "rule", "allRules", "className", "occurrences", "result", "errMsg", "validateRuleIsOverridden", "ruleName", "definedRulesNames", "validateNoLeftRecursion", "topRule", "currRule", "path", "nextNonTerminals", "getFirstNoneTerminal", "foundLeftRecursion", "validNextSteps", "errorsFromNextSteps", "currRefRule", "newPath", "definition", "currSubDef", "isFirstOptional", "hasMore", "rest", "OrCollector", "node", "validateEmptyOrAlternative", "orCollector", "ors", "currOr", "exceptLast", "currAlternative", "currAltIdx", "possibleFirstInAlt", "validateAmbiguousAlternationAlternatives", "globalMaxLookahead", "currOccurrence", "actualMaxLookahead", "alternatives", "altsAmbiguityErrors", "checkAlternativesAmbiguities", "altsPrefixAmbiguityErrors", "checkPrefixAlternativesAmbiguities", "RepetitionCollector", "validateSomeNonEmptyLookaheadPath", "topLevelRules", "maxLookahead", "currTopRule", "currProd", "prodType", "paths", "pathsInsideProduction", "alternation", "foundAmbiguousPaths", "identicalAmbiguities", "currAlt", "currPath", "altsCurrPathAppearsIn", "currOtherAlt", "currOtherAltIdx", "currErrors", "currAmbDescriptor", "ambgIndices", "currMessage", "pathsAndIndices", "idx", "currPathsAndIdx", "currPathAndIdx", "alternativeGast", "targetIdx", "targetPath", "prefixAmbiguitiesPathsAndIndices", "searchPathAndIdx", "currPathPrefixErrors", "currAmbPathAndIdx", "occurrence", "message", "tokenNames", "currToken", "currRuleName", "forEach_1", "__importDefault", "defaults_1", "resolver_1", "checks_1", "errors_public_1", "resolveGrammar", "options", "actualOptions", "topRulesTable", "rule", "exports", "validateGrammar", "includes_1", "__importDefault", "MISMATCHED_TOKEN_EXCEPTION", "NO_VIABLE_ALT_EXCEPTION", "EARLY_EXIT_EXCEPTION", "NOT_ALL_INPUT_PARSED_EXCEPTION", "RECOGNITION_EXCEPTION_NAMES", "isRecognitionException", "error", "exports", "RecognitionException", "_super", "__extends", "message", "token", "_this", "_newTarget", "MismatchedTokenException", "previousToken", "NoViableAltException", "NotAllInputParsedException", "EarlyExitException", "tokens_public_1", "isEmpty_1", "__importDefault", "dropRight_1", "flatten_1", "map_1", "find_1", "has_1", "includes_1", "clone_1", "exceptions_public_1", "constants_1", "parser_1", "exports", "InRuleRecoveryException", "_super", "__extends", "message", "_this", "Recoverable", "config", "attemptInRepetitionRecovery", "tokType", "tokToInsert", "grammarRule", "grammarRuleArgs", "lookAheadFunc", "expectedTokType", "reSyncTokType", "savedLexerState", "resyncedTokens", "passedResyncPoint", "nextTokenWithoutResync", "currToken", "generateErrorMessage", "previousToken", "msg", "error", "expectTokAfterLastMatch", "nextTokIdx", "notStuck", "tokIdxInRule", "grammarPath", "follows", "nextTok", "expectedToken", "mismatchedTok", "isMisMatchedTokInFollows", "possibleFollowsTokType", "isNextTokenWhatIsExpected", "tokenTypeIdx", "followKey", "currentRuleReSyncSet", "allPossibleReSyncTokTypes", "nextToken", "k", "foundMatch", "resyncTokType", "canMatch", "currRuleShortName", "currRuleIdx", "prevRuleShortName", "explicitRuleStack", "explicitOccurrenceStack", "ruleName", "idx", "followStack", "currKey", "followName", "token", "resyncTokens", "prodFunc", "args", "lookaheadFunc", "dslMethodIdx", "prodOccurrence", "nextToksWalker", "pathRuleStack", "pathOccurrenceStack", "currShortName", "key", "firstAfterRepInfo", "currRuleName", "ruleGrammar", "walker", "isEndOfRule", "exports", "getKeyForAutomaticLookahead", "ruleIdx", "dslMethodIdx", "occurrence", "BITS_START_FOR_ALT_IDX", "flatMap_1", "__importDefault", "isEmpty_1", "errors_public_1", "parser_1", "checks_1", "lookahead_1", "LLkLookaheadStrategy", "options", "_a", "leftRecursionErrors", "emptyAltErrors", "ambiguousAltsErrors", "emptyRepetitionErrors", "allErrors", "__spreadArray", "rules", "currTopRule", "maxLookahead", "exports", "forEach_1", "__importDefault", "has_1", "parser_1", "keys_1", "gast_1", "gast_2", "llk_lookahead_1", "LooksAhead", "config", "rules", "_this", "currRule", "_a", "collectMethods", "alternation", "repetition", "option", "repetitionMandatory", "repetitionMandatoryWithSeparator", "repetitionWithSeparator", "currProd", "prodIdx", "laFunc", "key", "rule", "prodOccurrence", "prodKey", "prodType", "prodMaxLookahead", "dslMethodName", "dslMethodIdx", "occurrence", "currRuleShortName", "value", "exports", "DslMethodsCollectorVisitor", "_super", "__extends", "manySep", "atLeastOne", "atLeastOneSep", "many", "or", "collectorVisitor", "dslMethods", "setNodeLocationOnlyOffset", "currNodeLocation", "newLocationInfo", "exports", "setNodeLocationFull", "addTerminalToCst", "node", "token", "tokenTypeName", "addNoneTerminalToCst", "ruleName", "ruleResult", "NAME", "defineNameProp", "obj", "nameValue", "exports", "isEmpty_1", "__importDefault", "compact_1", "isArray_1", "map_1", "forEach_1", "filter_1", "keys_1", "isFunction_1", "isUndefined_1", "lang_extensions_1", "defaultVisit", "ctx", "param", "childrenNames", "childrenNamesLength", "currChildName", "currChildArray", "currChildArrayLength", "j", "currChild", "exports", "createBaseSemanticVisitorConstructor", "grammarName", "ruleNames", "derivedConstructor", "semanticProto", "cstNode", "semanticDefinitionErrors", "validateVisitor", "errorMessages", "currDefError", "createBaseVisitorConstructorWithDefaults", "baseConstructor", "withDefaultsProto", "ruleName", "CstVisitorDefinitionError", "visitorInstance", "missingErrors", "validateMissingCstMethods", "missingRuleNames", "currRuleName", "errors", "cst_1", "noop_1", "__importDefault", "has_1", "keys_1", "isUndefined_1", "cst_visitor_1", "parser_1", "TreeBuilder", "config", "cstNode", "nextToken", "fullRuleName", "ruleCstNode", "prevToken", "loc", "key", "consumedToken", "rootCst", "ruleCstResult", "ruleName", "preCstNode", "newBaseCstVisitorConstructor", "newConstructor", "ruleStack", "occurrenceStack", "exports", "parser_1", "LexerAdapter", "newInput", "howMuch", "soughtIdx", "newState", "exports", "values_1", "__importDefault", "includes_1", "exceptions_public_1", "parser_1", "errors_public_1", "checks_1", "gast_1", "RecognizerApi", "impl", "idx", "tokType", "options", "ruleToCall", "actionORMethodDef", "altsOrOpts", "name", "implementation", "config", "errMsg", "error", "ruleImplementation", "ruleErrors", "grammarRule", "args", "orgState", "e", "exports", "isEmpty_1", "__importDefault", "isArray_1", "flatten_1", "every_1", "uniq_1", "isObject_1", "has_1", "values_1", "reduce_1", "clone_1", "keys_1", "exceptions_public_1", "lookahead_1", "interpreter_1", "parser_1", "recoverable_1", "tokens_public_1", "tokens_1", "RecognizerEngine", "tokenVocabulary", "config", "acc", "tokType", "allTokenTypes_1", "uniqueTokens", "allTokenTypes", "noTokenCategoriesUsed", "tokenConstructor", "ruleName", "impl", "resyncEnabled", "recoveryValueFunc", "shortName", "invokeRuleWithTry", "args", "_i", "cst", "e", "wrappedGrammarRule", "resyncEnabledConfig", "isFirstInvokedRule", "reSyncEnabled", "recogError", "reSyncTokType", "partialCstResult", "actionORMethodDef", "occurrence", "key", "_this", "lookAheadFunc", "action", "predicate_1", "orgLookaheadFunction_1", "prodOccurrence", "laKey", "predicate_2", "orgLookaheadFunction_2", "notStuck", "options", "separator", "firstIterationLookaheadFunc", "separatorLookAheadFunc", "lookaheadFunction", "predicate_3", "orgLookaheadFunction_3", "firstIterationLaFunc", "nextTerminalAfterWalker", "beforeIteration", "afterIteration", "altsOrOpts", "alts", "laFunc", "altIdxToTake", "chosenAlternative", "firstRedundantTok", "errMsg", "ruleToCall", "idx", "ruleResult", "consumedToken", "nextToken", "eFromConsumption", "msg", "previousToken", "follows", "eFromInRuleRecovery", "savedErrors", "savedRuleStack", "newState", "fullName", "idxInCallingRule", "exports", "exceptions_public_1", "has_1", "__importDefault", "clone_1", "lookahead_1", "parser_1", "ErrorHandler", "config", "error", "newErrors", "occurrence", "prodType", "userDefinedErrMsg", "ruleName", "ruleGrammar", "lookAheadPathsPerAlternative", "insideProdPaths", "actualTokens", "i", "msg", "errMsgTypes", "previousToken", "errMsg", "exports", "interpreter_1", "first_1", "__importDefault", "isUndefined_1", "ContentAssist", "startRuleName", "precedingInput", "startRuleGast", "grammarPath", "topRuleName", "gastProductions", "topProduction", "nextPossibleTokenTypes", "exports", "last_1", "__importDefault", "isArray_1", "some_1", "forEach_1", "isFunction_1", "has_1", "gast_1", "lexer_public_1", "tokens_1", "tokens_public_1", "parser_1", "keys_1", "RECORDING_NULL_OBJECT", "HANDLE_SEPARATOR", "MAX_METHOD_IDX", "RFT", "RECORDING_PHASE_TOKEN", "RECORDING_PHASE_CSTNODE", "GastRecorder", "config", "_this", "idx", "arg1", "arg2", "i", "that", "impl", "grammarRule", "args", "howMuch", "name", "def", "newTopLevelRule", "originalError", "mutabilityError", "actionORMethodDef", "occurrence", "recordProd", "options", "altsOrOpts", "recordOrProd", "ruleToCall", "assertMethodIdxIsValid", "error", "getIdxSuffix", "prevProd", "ruleName", "newNoneTerminal", "tokType", "exports", "prodConstructor", "mainProdArg", "handleSep", "grammarAction", "newProd", "hasOptions", "alts", "newOrProd", "hasPredicates", "currAlt", "currAltFlat", "has_1", "__importDefault", "utils_1", "parser_1", "PerformanceTracer", "config", "userTraceInitPerf", "traceIsNumber", "phaseDesc", "phaseImpl", "indent", "_a", "time", "value", "traceMethod", "exports", "applyMixins", "derivedCtor", "baseCtors", "baseCtor", "baseProto", "propName", "basePropDescriptor", "exports", "isEmpty_1", "__importDefault", "map_1", "forEach_1", "values_1", "has_1", "clone_1", "utils_1", "follow_1", "tokens_public_1", "errors_public_1", "gast_resolver_public_1", "recoverable_1", "looksahead_1", "tree_builder_1", "lexer_adapter_1", "recognizer_api_1", "recognizer_engine_1", "error_handler_1", "context_assist_1", "gast_recorder_1", "perf_tracer_1", "apply_mixins_1", "checks_1", "exports", "ParserDefinitionErrorType", "EMPTY_ALT", "value", "Parser", "tokenVocabulary", "config", "that", "parserInstance", "_this", "defErrorsMsgs", "className", "currRuleName", "wrappedRule", "originalGrammarAction", "recordedRuleGast", "resolverErrors", "validationErrors", "lookaheadValidationErrors", "allFollows", "_b", "_a", "defError", "CstParser", "_super", "__extends", "configClone", "EmbeddedActionsParser", "gast_1", "map_1", "__importDefault", "flatten_1", "values_1", "some_1", "groupBy_1", "assign_1", "buildModel", "productions", "generator", "CstNodeDefinitionGenerator", "allRules", "rule", "exports", "_super", "__extends", "node", "rawElements", "grouped", "el", "properties", "group", "propertyName", "allNullable", "propertyType", "g", "getType", "definition", "override", "_this", "production", "require_castSlice", "__commonJSMin", "exports", "module", "baseSlice", "castSlice", "array", "start", "end", "length", "require_hasUnicode", "__commonJSMin", "exports", "module", "rsAstralRange", "rsComboMarksRange", "reComboHalfMarksRange", "rsComboSymbolsRange", "rsComboRange", "rsVarRange", "rsZWJ", "reHasUnicode", "hasUnicode", "string", "require_asciiToArray", "__commonJSMin", "exports", "module", "asciiToArray", "string", "require_unicodeToArray", "__commonJSMin", "exports", "module", "rsAstralRange", "rsComboMarksRange", "reComboHalfMarksRange", "rsComboSymbolsRange", "rsComboRange", "rsVarRange", "rsAstral", "rsCombo", "rsFitz", "rsModifier", "rsNonAstral", "rsRegional", "rsSurrPair", "rsZWJ", "reOptMod", "rsOptVar", "rsOptJoin", "rsSeq", "rsSymbol", "reUnicode", "unicodeToArray", "string", "require_stringToArray", "__commonJSMin", "exports", "module", "asciiToArray", "hasUnicode", "unicodeToArray", "stringToArray", "string", "require_createCaseFirst", "__commonJSMin", "exports", "module", "castSlice", "hasUnicode", "stringToArray", "toString", "createCaseFirst", "methodName", "string", "strSymbols", "chr", "trailing", "require_upperFirst", "__commonJSMin", "exports", "module", "createCaseFirst", "upperFirst", "flatten_1", "__importDefault", "isArray_1", "map_1", "reduce_1", "uniq_1", "upperFirst_1", "genDts", "model", "options", "contentParts", "node", "genCstNodeTypes", "genVisitor", "exports", "nodeCstInterface", "genNodeInterface", "nodeChildrenInterface", "genNodeChildrenType", "nodeInterfaceName", "getNodeInterfaceName", "childrenTypeName", "getNodeChildrenTypeName", "typeName", "property", "genChildProperty", "prop", "buildTypeString", "name", "nodes", "genVisitorFunction", "type", "typeNames", "t", "getTypeString", "typeString", "sum", "ruleName", "model_1", "generate_1", "defaultOptions", "generateCstDts", "productions", "options", "effectiveOptions", "__assign", "model", "exports", "version_1", "createSyntaxDiagramsCode", "grammar", "_a", "_b", "_c", "resourceBase", "_d", "css", "header", "cssHtml", "scripts", "diagramsDiv", "serializedGrammar", "initLogic", "exports", "version_1", "exports", "parser_1", "lexer_public_1", "tokens_public_1", "lookahead_1", "llk_lookahead_1", "errors_public_1", "exceptions_public_1", "lexer_errors_public_1", "gast_1", "gast_2", "cst_dts_gen_1", "clearCache", "render_public_1", "Parser"]
}
