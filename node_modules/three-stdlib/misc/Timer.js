import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';

class Timer {
  constructor() {
    _defineProperty(this, "_previousTime", void 0);

    _defineProperty(this, "_currentTime", void 0);

    _defineProperty(this, "_delta", void 0);

    _defineProperty(this, "_elapsed", void 0);

    _defineProperty(this, "_timescale", void 0);

    _defineProperty(this, "_useFixedDelta", void 0);

    _defineProperty(this, "_fixedDelta", void 0);

    _defineProperty(this, "_usePageVisibilityAPI", void 0);

    _defineProperty(this, "_pageVisibilityHandler", void 0);

    this._previousTime = 0;
    this._currentTime = 0;
    this._delta = 0;
    this._elapsed = 0;
    this._timescale = 1;
    this._useFixedDelta = false;
    this._fixedDelta = 16.67; // ms, corresponds to approx. 60 FPS

    this._usePageVisibilityAPI = typeof document !== 'undefined' && document.hidden !== undefined;
  } // https://github.com/mrdoob/three.js/issues/20575
  // use Page Visibility API to avoid large time delta values


  connect() {
    if (this._usePageVisibilityAPI) {
      this._pageVisibilityHandler = handleVisibilityChange.bind(this);
      document.addEventListener('visibilitychange', this._pageVisibilityHandler, false);
    }

    return this;
  }

  dispose() {
    if (this._usePageVisibilityAPI && this._pageVisibilityHandler) {
      document.removeEventListener('visibilitychange', this._pageVisibilityHandler);
    }

    return this;
  }

  disableFixedDelta() {
    this._useFixedDelta = false;
    return this;
  }

  enableFixedDelta() {
    this._useFixedDelta = true;
    return this;
  }

  getDelta() {
    return this._delta / 1000;
  }

  getElapsedTime() {
    return this._elapsed / 1000;
  }

  getFixedDelta() {
    return this._fixedDelta / 1000;
  }

  getTimescale() {
    return this._timescale;
  }

  reset() {
    this._currentTime = this._now();
    return this;
  }

  setFixedDelta(fixedDelta) {
    this._fixedDelta = fixedDelta * 1000;
    return this;
  }

  setTimescale(timescale) {
    this._timescale = timescale;
    return this;
  }

  update() {
    if (this._useFixedDelta === true) {
      this._delta = this._fixedDelta;
    } else {
      this._previousTime = this._currentTime;
      this._currentTime = this._now();
      this._delta = this._currentTime - this._previousTime;
    }

    this._delta *= this._timescale;
    this._elapsed += this._delta; // _elapsed is the accumulation of all previous deltas

    return this;
  } // For THREE.Clock backward compatibility


  get elapsedTime() {
    return this.getElapsedTime();
  } // private


  _now() {
    return (typeof performance === 'undefined' ? Date : performance).now();
  }

}

function handleVisibilityChange() {
  if (document.hidden === false) this.reset();
}

export { Timer };
