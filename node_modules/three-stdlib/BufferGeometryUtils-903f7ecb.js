"use strict";var e=require("three"),t=require("./types/helpers.cjs.js");const r=(t,r)=>{const n=null!==t[0].index,s=new Set(Object.keys(t[0].attributes)),i=new Set(Object.keys(t[0].morphAttributes)),u={},a={},f=t[0].morphTargetsRelative,l=new e.BufferGeometry;let c=0;if(t.forEach(((e,t)=>{let o=0;if(n!==(null!==e.index))return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+t+". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."),null;for(let r in e.attributes){if(!s.has(r))return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+t+'. All geometries must have compatible attributes; make sure "'+r+'" attribute exists among all geometries, or in none of them.'),null;void 0===u[r]&&(u[r]=[]),u[r].push(e.attributes[r]),o++}if(o!==s.size)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+t+". Make sure all geometries have the same number of attributes."),null;if(f!==e.morphTargetsRelative)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+t+". .morphTargetsRelative must be consistent throughout all geometries."),null;for(let r in e.morphAttributes){if(!i.has(r))return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+t+".  .morphAttributes must be consistent throughout all geometries."),null;void 0===a[r]&&(a[r]=[]),a[r].push(e.morphAttributes[r])}if(l.userData.mergedUserData=l.userData.mergedUserData||[],l.userData.mergedUserData.push(e.userData),r){let r;if(e.index)r=e.index.count;else{if(void 0===e.attributes.position)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+t+". The geometry must have either an index or a position attribute"),null;r=e.attributes.position.count}l.addGroup(c,r,t),c+=r}})),n){let e=0;const r=[];t.forEach((t=>{const o=t.index;for(let t=0;t<o.count;++t)r.push(o.getX(t)+e);e+=t.attributes.position.count})),l.setIndex(r)}for(let e in u){const t=o(u[e]);if(!t)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the "+e+" attribute."),null;l.setAttribute(e,t)}for(let e in a){const t=a[e][0].length;if(0===t)break;l.morphAttributes=l.morphAttributes||{},l.morphAttributes[e]=[];for(let r=0;r<t;++r){const t=[];for(let o=0;o<a[e].length;++o)t.push(a[e][o][r]);const n=o(t);if(!n)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the "+e+" morphAttribute."),null;l.morphAttributes[e].push(n)}}return l},o=t=>{let r,o,n,s=0;if(t.forEach((e=>(void 0===r&&(r=e.array.constructor),r!==e.array.constructor?(console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."),null):(void 0===o&&(o=e.itemSize),o!==e.itemSize?(console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."),null):(void 0===n&&(n=e.normalized),n!==e.normalized?(console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."),null):void(s+=e.array.length)))))),r&&o){const i=new r(s);let u=0;return t.forEach((e=>{i.set(e.array,u),u+=e.array.length})),new e.BufferAttribute(i,o,n)}},n=r=>{let o,n=0,s=0;for(let e=0,t=r.length;e<t;++e){const t=r[e];if(void 0===o&&(o=t.array.constructor),o!==t.array.constructor)return console.error("AttributeBuffers of different types cannot be interleaved"),null;n+=t.array.length,s+=t.itemSize}const i=new e.InterleavedBuffer(new o(n),s);let u=0;const a=[],f=["getX","getY","getZ","getW"],l=["setX","setY","setZ","setW"];for(let o=0,n=r.length;o<n;o++){const n=r[o],s=n.itemSize,c=n.count,m=new e.InterleavedBufferAttribute(i,s,u,n.normalized);a.push(m),u+=s;for(let e=0;e<c;e++)for(let r=0;r<s;r++){t.getWithKey(m,l[r])(e,t.getWithKey(n,f[r])(e))}}return a};function s(e){let t=0;for(let r in e.attributes){const o=e.getAttribute(r);t+=o.count*o.itemSize*o.array.BYTES_PER_ELEMENT}const r=e.getIndex();return t+=r?r.count*r.itemSize*r.array.BYTES_PER_ELEMENT:0,t}function i(t,r=1e-4){r=Math.max(r,Number.EPSILON);const o={},n=t.getIndex(),s=t.getAttribute("position"),i=n?n.count:s.count;let u=0;const a=Object.keys(t.attributes),f={},l={},c=[],m=["getX","getY","getZ","getW"];for(let e=0,r=a.length;e<r;e++){const r=a[e];f[r]=[];const o=t.morphAttributes[r];o&&(l[r]=new Array(o.length).fill(0).map((()=>[])))}const g=Math.log10(1/r),d=Math.pow(10,g);for(let e=0;e<i;e++){const r=n?n.getX(e):e;let s="";for(let e=0,o=a.length;e<o;e++){const o=a[e],n=t.getAttribute(o),i=n.itemSize;for(let e=0;e<i;e++)s+=~~(n[m[e]](r)*d)+","}if(s in o)c.push(o[s]);else{for(let e=0,o=a.length;e<o;e++){const o=a[e],n=t.getAttribute(o),s=t.morphAttributes[o],i=n.itemSize,u=f[o],c=l[o];for(let e=0;e<i;e++){const t=m[e];if(u.push(n[t](r)),s)for(let e=0,o=s.length;e<o;e++)c[e].push(s[e][t](r))}}o[s]=u,c.push(u),u++}}const h=t.clone();for(let r=0,o=a.length;r<o;r++){const o=a[r],n=t.getAttribute(o),s=new n.array.constructor(f[o]),i=new e.BufferAttribute(s,n.itemSize,n.normalized);if(h.setAttribute(o,i),o in l)for(let r=0;r<l[o].length;r++){const n=t.morphAttributes[o][r],s=new n.array.constructor(l[o][r]),i=new e.BufferAttribute(s,n.itemSize,n.normalized);h.morphAttributes[o][r]=i}}return h.setIndex(c),h}function u(t,r){if(r===e.TrianglesDrawMode)return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."),t;if(r===e.TriangleFanDrawMode||r===e.TriangleStripDrawMode){let o=t.getIndex();if(null===o){const e=[],r=t.getAttribute("position");if(void 0===r)return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),t;for(let t=0;t<r.count;t++)e.push(t);t.setIndex(e),o=t.getIndex()}const n=o.count-2,s=[];if(o)if(r===e.TriangleFanDrawMode)for(let e=1;e<=n;e++)s.push(o.getX(0)),s.push(o.getX(e)),s.push(o.getX(e+1));else for(let e=0;e<n;e++)e%2==0?(s.push(o.getX(e)),s.push(o.getX(e+1)),s.push(o.getX(e+2))):(s.push(o.getX(e+2)),s.push(o.getX(e+1)),s.push(o.getX(e)));s.length/3!==n&&console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");const i=t.clone();return i.setIndex(s),i.clearGroups(),i}return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",r),t}function a(t){if(!0!==t.geometry.isBufferGeometry)return console.error("THREE.BufferGeometryUtils: Geometry is not of type BufferGeometry."),null;const r=new e.Vector3,o=new e.Vector3,n=new e.Vector3,s=new e.Vector3,i=new e.Vector3,u=new e.Vector3,a=new e.Vector3,f=new e.Vector3,l=new e.Vector3;function c(e,t,c,m,g,d,h,b,p){r.fromBufferAttribute(c,d),o.fromBufferAttribute(c,h),n.fromBufferAttribute(c,b);const y=e.morphTargetInfluences;if(t.morphTargets&&m&&y){a.set(0,0,0),f.set(0,0,0),l.set(0,0,0);for(let e=0,t=m.length;e<t;e++){const t=y[e],c=m[e];0!==t&&(s.fromBufferAttribute(c,d),i.fromBufferAttribute(c,h),u.fromBufferAttribute(c,b),g?(a.addScaledVector(s,t),f.addScaledVector(i,t),l.addScaledVector(u,t)):(a.addScaledVector(s.sub(r),t),f.addScaledVector(i.sub(o),t),l.addScaledVector(u.sub(n),t)))}r.add(a),o.add(f),n.add(l)}e.isSkinnedMesh&&(e.boneTransform(d,r),e.boneTransform(h,o),e.boneTransform(b,n)),p[3*d+0]=r.x,p[3*d+1]=r.y,p[3*d+2]=r.z,p[3*h+0]=o.x,p[3*h+1]=o.y,p[3*h+2]=o.z,p[3*b+0]=n.x,p[3*b+1]=n.y,p[3*b+2]=n.z}const m=t.geometry,g=t.material;let d,h,b;const p=m.index,y=m.attributes.position,A=m.morphAttributes.position,B=m.morphTargetsRelative,w=m.attributes.normal,E=m.morphAttributes.position,x=m.groups,T=m.drawRange;let G,V,z,M,S,v,U,R;const X=new Float32Array(y.count*y.itemSize),D=new Float32Array(w.count*w.itemSize);if(null!==p)if(Array.isArray(g))for(G=0,z=x.length;G<z;G++)for(S=x[G],v=g[S.materialIndex],U=Math.max(S.start,T.start),R=Math.min(S.start+S.count,T.start+T.count),V=U,M=R;V<M;V+=3)d=p.getX(V),h=p.getX(V+1),b=p.getX(V+2),c(t,v,y,A,B,d,h,b,X),c(t,v,w,E,B,d,h,b,D);else for(U=Math.max(0,T.start),R=Math.min(p.count,T.start+T.count),G=U,z=R;G<z;G+=3)d=p.getX(G),h=p.getX(G+1),b=p.getX(G+2),c(t,g,y,A,B,d,h,b,X),c(t,g,w,E,B,d,h,b,D);else if(void 0!==y)if(Array.isArray(g))for(G=0,z=x.length;G<z;G++)for(S=x[G],v=g[S.materialIndex],U=Math.max(S.start,T.start),R=Math.min(S.start+S.count,T.start+T.count),V=U,M=R;V<M;V+=3)d=V,h=V+1,b=V+2,c(t,v,y,A,B,d,h,b,X),c(t,v,w,E,B,d,h,b,D);else for(U=Math.max(0,T.start),R=Math.min(y.count,T.start+T.count),G=U,z=R;G<z;G+=3)d=G,h=G+1,b=G+2,c(t,g,y,A,B,d,h,b,X),c(t,g,w,E,B,d,h,b,D);return{positionAttribute:y,normalAttribute:w,morphedPositionAttribute:new e.Float32BufferAttribute(X,3),morphedNormalAttribute:new e.Float32BufferAttribute(D,3)}}function f(t,r=Math.PI/3){const o=Math.cos(r),n=100*(1+1e-10),s=[new e.Vector3,new e.Vector3,new e.Vector3],i=new e.Vector3,u=new e.Vector3,a=new e.Vector3,f=new e.Vector3;function l(e){return`${~~(e.x*n)},${~~(e.y*n)},${~~(e.z*n)}`}const c=t.toNonIndexed(),m=c.attributes.position,g={};for(let t=0,r=m.count/3;t<r;t++){const r=3*t,o=s[0].fromBufferAttribute(m,r+0),n=s[1].fromBufferAttribute(m,r+1),a=s[2].fromBufferAttribute(m,r+2);i.subVectors(a,n),u.subVectors(o,n);const f=(new e.Vector3).crossVectors(i,u).normalize();for(let e=0;e<3;e++){const t=l(s[e]);t in g||(g[t]=[]),g[t].push(f)}}const d=new Float32Array(3*m.count),h=new e.BufferAttribute(d,3,!1);for(let e=0,t=m.count/3;e<t;e++){const t=3*e,r=s[0].fromBufferAttribute(m,t+0),n=s[1].fromBufferAttribute(m,t+1),c=s[2].fromBufferAttribute(m,t+2);i.subVectors(c,n),u.subVectors(r,n),a.crossVectors(i,u).normalize();for(let e=0;e<3;e++){const r=g[l(s[e])];f.set(0,0,0);for(let e=0,t=r.length;e<t;e++){const t=r[e];a.dot(t)>o&&f.add(t)}f.normalize(),h.setXYZ(t+e,f.x,f.y,f.z)}}return c.setAttribute("normal",h),c}var l=Object.freeze({__proto__:null,mergeBufferGeometries:r,mergeBufferAttributes:o,interleaveAttributes:n,estimateBytesUsed:s,mergeVertices:i,toTrianglesDrawMode:u,computeMorphedAttributes:a,toCreasedNormals:f});exports.BufferGeometryUtils=l,exports.computeMorphedAttributes=a,exports.estimateBytesUsed=s,exports.interleaveAttributes=n,exports.mergeBufferAttributes=o,exports.mergeBufferGeometries=r,exports.mergeVertices=i,exports.toCreasedNormals=f,exports.toTrianglesDrawMode=u;
